# Ways to get make money via software

- Write Open Source Small Libraries which serve as proof of hands-on capabilities
    - ideated by yourself
    - product market fit is risky
- Contribute to large existing reputed OSS libraries of a known domain
    - peer validated mastery, because someone merged your code
- Write tools and products which can be launched on product hunt or gumroad
- Consulting to build something for someone
    - if you have reputation in your domain you can get paid well
    - if you lack reputation, you do not even know what work will suit you










``` text
Next 100 days

The next job 
- Usual Full-Stack Developer role
- Rust Systems Programmer role

What can help us prepare in next 100 days
- A. Blockchain Rust contributions for immediate money
- B. 300 LOC Rust small OSS libraries
- C. Rust big library contribution
- D. Full Stack projects + DSA + System Design (React + Springboot)
- E. RustHallows


What can help us get the next Rust job?
- Personal
    - Identify big libraries for Rust contributions
    - Build Rust knowledge base
        - System Design
        - DSA
        - Idiomatic design patterns of Rust
    - 300 LOC Rust small OSS libraries
- Office
    - React
    - Springboot

```

# Useful Nuggets from previous conversations 

This analysis significantly expands the initial strategic roadmap by incorporating crucial Rust projects that were overlooked in the initial research or are emerging as critical infrastructure. We have integrated these new findings into the existing tiered structure, maintaining the rigorous **Hiring Potential Score (HPS)** methodology.

This expanded list provides a comprehensive view of the Rust ecosystem, prioritizing projects that offer the strongest signal for employability in CPU-intensive domains such as systems programming, high-performance computing (HPC), infrastructure, distributed systems, and compilers.

### Hiring Potential Score (HPS) Methodology (Recap)

The HPS (1-100) is calculated based on:
1.  **Technical Relevance (CPU/Systems Focus) (40 pts)**
2.  **Industry Adoption & Prestige (30 pts)**
3.  **Technical Signaling (Depth) (20 pts)**
4.  **Project Health & Accessibility (10 pts)**

---

## Expanded Rust OSS Contribution Strategy

*(Note: [Augmented] indicates projects not present in the initial analysis.)*

### Tier S: The Gold Standard (HPS 90+)

Contributions to these projects signal exceptional competence in rigorous, performance-critical environments. They are the foundational pillars and the most demanding environments in the Rust ecosystem.

| Repository | Domain | HPS (1-100) | Analysis and Strategic Rationale |
| :--- | :--- | :--- | :--- |
| [**tokio-rs/tokio**](https://github.com/tokio-rs/tokio) | Async Runtime | **98** | **Rationale:** The ubiquitous asynchronous runtime. Mastery is essential for high-performance networking and infrastructure roles.\<br\>**Value:** Contributions involve schedulers, I/O drivers (e.g., `io_uring`), and synchronization, demonstrating deep understanding of modern concurrency models. |
| [**crossbeam-rs/crossbeam**](https://github.com/crossbeam-rs/crossbeam) | Concurrency Primitives | **98** | **Rationale:** [Augmented] Provides foundational tools for concurrency, including lock-free data structures, atomic references, and memory reclamation.\<br\>**Value:** Contributions require rigorous understanding of CPU memory models, atomics, and `unsafe` code—the highest signal for low-level optimization and concurrency expertise. |
| [**cloudflare/pingora**](https://github.com/cloudflare/pingora) | Networking Framework/Proxy | **97** | **Rationale:** [Augmented] The framework Cloudflare uses to handle over a trillion requests daily. Optimized for extreme efficiency and security.\<br\>**Value:** Signals elite capability in network programming, memory optimization, and building massively scalable, mission-critical infrastructure. |
| [**tikv/tikv**](https://github.com/tikv/tikv) | Distributed Database | **95** | **Rationale:** A production-grade distributed transactional key-value database (CNCF Graduated).\<br\>**Value:** Deals with consensus algorithms (Raft), high-throughput storage, and extreme optimization. Signals strong capability in complex distributed systems. |
| [**apache/arrow-datafusion**](https://github.com/apache/arrow-datafusion) & [**arrow-rs**](https://github.com/apache/arrow-rs) | Query Engine / Data Format | **94** | **Rationale:** [Augmented] DataFusion is an extensible query execution framework, and arrow-rs implements Apache Arrow (the standard for in-memory columnar data). Core of the modern analytical data stack.\<br\>**Value:** Contributions demonstrate expertise in query optimization, vectorized execution (SIMD), and high-performance data interchange. |
| [**pola-rs/polars**](https://github.com/pola-rs/polars) | Data Frames/HPC | **93** | **Rationale:** [Augmented] A blazingly fast DataFrame library focused on maximizing hardware utilization.\<br\>**Value:** Contributions demonstrate expertise in cache locality, SIMD vectorization, and efficient parallelism. |
| [**rust-vmm/rust-vmm**](https://github.com/rust-vmm) | Virtualization (Components) | **93** | **Rationale:** [Augmented] A collection of shared virtualization components. This is the bedrock upon which projects like AWS Firecracker and Kata Containers are built.\<br\>**Value:** Direct involvement with the lowest levels of virtualization (KVM interaction, memory management, device emulation). Signals extreme technical depth. |
| [**aws/firecracker**](https://github.com/firecracker-microvm/firecracker) | Virtualization (VMM) | **92** | **Rationale:** [Augmented] The Micro-VM monitor built by AWS to power Lambda/Fargate.\<br\>**Value:** Contributions signal capability in mission-critical cloud infrastructure and deep systems programming. |
| [**linkerd/linkerd2-proxy**](https://github.com/linkerd/linkerd2-proxy) | Service Mesh/Proxy | **92** | **Rationale:** [Augmented] The high-performance, ultralight proxy underpinning the Linkerd service mesh.\<br\>**Value:** Contributions demonstrate expertise in high-throughput networking, latency optimization, and complex asynchronous systems built on Tokio/Hyper. |
| [**rust-lang/rust**](https://github.com/rust-lang/rust) | Compiler (rustc) & Std Lib | **91** | **Rationale:** Contributing to the compiler or standard library is the highest signal of technical proficiency.\<br\>**Value:** Direct impact on the language. Focus on `std::sync` or `std::collections` optimizations. |
| [**Amanieu/parking_lot**](https://github.com/Amanieu/parking_lot) | Synchronization Primitives | **90** | **Rationale:** [Augmented] Provides optimized implementations of Mutex, RwLock, etc., often faster and smaller than `std`.\<br\>**Value:** Demonstrates knowledge of synchronization mechanisms, futexes, and performance trade-offs at the lowest level of concurrency. |

### Tier A: Core Libraries and Emerging Domains (HPS 80-89)

These projects are critical dependencies or dominate strategic niches where Rust expertise is scarce and in high demand.

| Repository | Domain | HPS (1-100) | Analysis and Strategic Rationale |
| :--- | :--- | :--- | :--- |
| [**rayon-rs/rayon**](https://github.com/rayon-rs/rayon) | Data Parallelism | **88** | **Rationale:** [Augmented] The de-facto library for easy data parallelism in Rust.\<br\>**Value:** Focuses on maximizing multi-core utilization via work-stealing schedulers. Demonstrates mastery of parallel algorithms. |
| [**hyperium/hyper**](https://github.com/hyperium/hyper) | Low-level HTTP | **87** | **Rationale:** The foundational, high-performance HTTP library that underpins most Rust web frameworks and clients.\<br\>**Value:** Demonstrates strong knowledge of network protocols and async I/O optimization. |
| [**qdrant/qdrant**](https://github.com/qdrant/qdrant) | Vector Database | **87** | **Rationale:** [Augmented] A high-performance vector similarity search engine. Crucial infrastructure for modern AI/ML applications.\<br\>**Value:** Contributions involve optimization of specialized indexing algorithms (like HNSW), concurrency, and efficient storage. Highly relevant in the AI infrastructure space. |
| [**bytecodealliance/wasmtime**](https://github.com/bytecodealliance/wasmtime) | WebAssembly Runtime | **86** | **Rationale:** A leading WebAssembly runtime, crucial for sandboxing, edge computing, and serverless infrastructure.\<br\>**Value:** Contributions involve compiler technology (Cranelift), security, and JIT optimization. |
| [**rustls/rustls**](https://github.com/rustls/rustls) | Cryptography/TLS | **86** | **Rationale:** [Augmented] A modern, memory-safe TLS library rapidly replacing OpenSSL in many projects (e.g., `curl`).\<br\>**Value:** Signals extreme rigor, correctness, and an understanding of performance-critical security protocols. |
| [**quickwit-oss/tantivy**](https://github.com/quickwit-oss/tantivy) | Search Engine Library | **85** | **Rationale:** [Augmented] A high-performance, full-text search engine library (Rust's equivalent to Apache Lucene).\<br\>**Value:** Contributions demonstrate expertise in data structures (FSTs), compression algorithms, indexing strategies, and memory efficiency. |
| [**quinn-rs/quinn**](https://github.com/quinn-rs/quinn) | Networking (QUIC) | **84** | **Rationale:** A pure-Rust implementation of the QUIC transport protocol (HTTP/3).\<br\>**Value:** Networking protocol implementation is highly valued, demonstrating understanding of complex transports and congestion control. |
| [**risingwavelabs/risingwave**](https://github.com/risingwavelabs/risingwave) | Streaming Database | **83** | **Rationale:** [Augmented] A distributed SQL database for stream processing.\<br\>**Value:** Contributions involve complex distributed systems challenges, real-time data processing, and state management—skills critical for high-throughput infrastructure. |
| [**databendlabs/databend**](https://github.com/databendlabs/databend) | Database (Cloud Data Warehouse) | **82** | **Rationale:** An emerging cloud data warehouse focused on high-performance analytics.\<br\>**Value:** Relevant for data engineering roles, offering exposure to query optimization and vectorized execution. |
| [**rust-rocksdb/rust-rocksdb**](https://github.com/rust-rocksdb/rust-rocksdb) | Storage Engine Bindings | **82** | **Rationale:** [Augmented] Rust bindings for RocksDB (C++), the embedded storage engine used by TiKV, CockroachDB, etc.\<br\>**Value:** Contributions demonstrate expertise in complex Foreign Function Interface (FFI), memory management across language boundaries, and providing safe abstractions over unsafe code. |
| [**tikv/raft-rs**](https://github.com/tikv/raft-rs) | Consensus Algorithm | **81** | **Rationale:** [Augmented] The implementation of the Raft consensus algorithm, maintained by TiKV.\<br\>**Value:** Consensus is the bedrock of distributed systems. Contributions signal understanding of distributed state machines and absolute correctness requirements. |
| [**containers/youki**](https://github.com/containers/youki) | Container Runtime | **80** | **Rationale:** A container runtime (like runc) written in Rust.\<br\>**Value:** Direct exposure to the lowest levels of cloud infrastructure: Linux namespaces, cgroups, and syscalls. |

### Tier B: High-Velocity Tooling and Industry Applications (HPS 70-79)

These projects are excellent for demonstrating practical skills in building reliable, high-throughput tools and applications.

| Repository | Domain | HPS (1-100) | Analysis and Strategic Rationale |
| :--- | :--- | :--- | :--- |
| [**serde-rs/serde**](https://github.com/serde-rs/serde) | Serialization Framework | **79** | **Rationale:** [Augmented] The ubiquitous serialization/deserialization framework for Rust. Performance is critical as it's often a bottleneck.\<br\>**Value:** Contributions involve complex procedural macros, trait bounds, and optimization (e.g., zero-copy). Signals strong general Rust capability and optimization awareness. |
| [**vectordotdev/vector**](https://github.com/vectordotdev/vector) | Observability Pipeline | **78** | **Rationale:** A high-performance data pipeline for logs and metrics.\<br\>**Value:** Highly relevant for SRE/Infrastructure roles. Focus on throughput, memory management, and reliability. |
| [**astral-sh/uv**](https://github.com/astral-sh/uv) | Dev Tooling (Python Pkg Manager) | **77** | **Rationale:** An extremely fast Python package installer/resolver written in Rust.\<br\>**Value:** Demonstrates ability to work in an optimization-focused environment and handle complex algorithms (dependency resolution). |
| [**denoland/deno**](https://github.com/denoland/deno) | JS/TS/Wasm Runtime | **75** | **Rationale:** A high-visibility, Rust-based runtime built on Tokio and V8.\<br\>**Value:** Focus strictly on the Rust internals (`deno_core` or ops system), avoiding the JavaScript standard library. |
| [**redox-os/redox**](https://gitlab.redox-os.org/redox-os/redox) | Operating System | **75** | **Rationale:** [Augmented] A Unix-like operating system written in Rust, focusing on a microkernel design.\<br\>**Value:** The ultimate "CPU world" project. Contributions signal unparalleled depth in OS concepts. However, its low industry adoption means the *employability* impact (HPS) is lower than infrastructure projects, despite the high technical signaling. |
| [**rust-lang/rust-clippy**](https://github.com/rust-lang/rust-clippy) | Linter / Static Analysis | **74** | **Rationale:** The official Rust linter and the recognized gateway to compiler development.\<br\>**Value:** Demonstrates deep understanding of Rust idioms, safety pitfalls, and the compiler's AST/HIR. |
| [**meilisearch/meilisearch**](https://github.com/meilisearch/meilisearch) | Search Engine | **72** | **Rationale:** A popular open-source search engine.\<br\>**Value:** Good for demonstrating data structure efficiency, though less focused on core algorithms than Tantivy. |

### Tier C: General Libraries (HPS < 70)

| Repository | Domain | HPS (1-100) | Analysis and Strategic Rationale |
| :--- | :--- | :--- | :--- |
| [**kube-rs/kube**](https://github.com/kube-rs/kube) | Kubernetes Client | **68** | **Rationale:** The primary Rust client for the Kubernetes API.\<br\>**Value:** Relevant for cloud-native development (operators/controllers), but less focused on raw performance than infrastructure projects. |
| [**actix/actix-web**](https://github.com/actix/actix-web) | Web Framework | **65** | **Rationale:** A mature, high-performance web framework.\<br\>**Value:** Demonstrates practical back-end development skills, but is less "systems-focused" than Hyper or Tokio. |
| [**open-telemetry/opentelemetry-rust**](https://github.com/open-telemetry/opentelemetry-rust) | Observability SDK | **64** | **Rationale:** Rust implementation of OpenTelemetry standards.\<br\>**Value:** Crucial for modern observability, but contributions are often more about API compliance than performance optimization. |
| **ORMs (Sea-ORM, Diesel, SQLx)** | Database Access | **55-60** | **Rationale:** Essential for application development.\<br\>**Value:** Involves complex type-level programming (traits/macros), but not highly relevant for core systems roles. |


# Modernizing "Once-Campfire": Unlocking 10-100× Performance & 75-90% Cost Savings with a Rust-First, WASM-Augmented Re-Architecture

### Executive Summary
Migrating the 'once-campfire' backend from Ruby on Rails to Rust offers substantial, evidence-backed improvements in performance and cost-efficiency. [executive_summary[1]][1] Case studies and benchmarks indicate that a Rust backend can be **10 to 100 times faster**, handling significantly more requests per second with lower latency, while consuming **75-90% less CPU and memory**. [executive_summary[1]][1] This translates directly to major infrastructure cost savings, as fewer and smaller servers would be required to support the same user load. [executive_summary[1]][1] The real-time WebSocket layer, a likely bottleneck in the current Action Cable implementation, could see a **10x increase in connection capacity** and a dramatic reduction in message latency. [executive_summary[3]][2] [executive_summary[5]][3]

Conversely, converting the entire application to WebAssembly (WASM) presents significant challenges. A client-side conversion using tools like `wasmify-rails` is technically feasible but impractical for a production chat application due to very large initial bundle sizes (**70-100MB**) and, most critically, the lack of mature support for WebSockets in the current WASI standard, which is essential for real-time features. [wasm_conversion_feasibility_analysis[2]][4] [wasm_conversion_feasibility_analysis.technical_limitations[0]][5] [wasm_conversion_feasibility_analysis.technical_limitations[1]][6] A full server-side WASM (WASI) conversion is even less practical today due to the immaturity of the ecosystem's support for asynchronous networking and direct database access required by a stateful application like Campfire. [wasm_conversion_feasibility_analysis.server_side_summary[1]][7]

The most promising path forward involves a hybrid architecture. This includes incrementally replacing performance-critical backend components (like background job processors and WebSocket handlers) with Rust microservices. [primary_recommendation[5]][8] Additionally, selective, high-impact WASM modules can be introduced on the client-side for tasks like markdown parsing, media processing, or end-to-end encryption, enhancing user experience without a full rewrite. [selective_wasm_integration_strategy.rationale[1]][9] This hybrid approach unlocks innovative capabilities beyond simple feature parity, such as CRDT-based offline-first collaboration, privacy-preserving client-side AI features, and a secure plugin architecture, positioning a modernized 'once-campfire' as a next-generation communication platform. [innovative_rewrite_capabilities[0]][10]

## 1. Current Rails Architecture — Monolith Limits Throughput and WebSocket Scale

The "once-campfire" application is a modern, containerized Ruby on Rails monolith designed for single-tenant deployment. [current_campfire_architecture_analysis.deployment_model[1]][11] While it leverages current best practices within the Rails ecosystem, its architecture presents inherent bottlenecks that limit scalability, performance, and cost-efficiency, particularly for a real-time chat application.

### ActionCable & Resque Hotspots — High Memory Use and GVL Contention Choke Real-time Chat

The core of the application is built on Ruby on Rails 8.1.0.alpha and Ruby 3.4.5, running on a concurrent Puma web server. [current_campfire_architecture_analysis.framework[0]][12] [current_campfire_architecture_analysis.language[0]][13] [current_campfire_architecture_analysis.web_server[0]][14] This stack, while productive, has two primary performance hotspots:

* **Real-time Communication**: Handled by Action Cable, Rails' integrated WebSocket framework, using Redis as a pub/sub message bus. [current_campfire_architecture_analysis.real_time_communication[0]][15] Action Cable is known to have scaling limitations and high memory consumption under load, which is a critical vulnerability for a chat application. [estimated_performance_gains_rust.websocket_performance[0]][16]
* **Background Jobs**: Processed by Resque, a popular Ruby library. [current_campfire_architecture_analysis.background_jobs[0]][17] Like all Ruby processes, Resque workers are constrained by the Global VM Lock (GVL), which prevents true parallelism for CPU-bound tasks within a single process, limiting throughput for jobs like webhook dispatching or push notifications. [estimated_performance_gains_rust.background_job_performance[0]][16]

The frontend uses the Hotwire stack (Turbo and Stimulus) to create a single-page application feel with minimal JavaScript, which is efficient from a development standpoint but still relies entirely on the server's performance for rendering and updates. [current_campfire_architecture_analysis.frontend_stack[0]][17]

### SQLite/Active Storage Constraints — Single-file DB, No Row-level Isolation; S3 Offload Absent

The application's data persistence layer is designed for simplicity, using SQLite3 as the default database for all environments, including production. [current_campfire_architecture_analysis.database_system[0]][17] While simple to deploy, SQLite is not suitable for a concurrent, write-heavy application and lacks the robustness and features of a production-grade database like PostgreSQL. [rust_technical_deep_dives.0.analysis_summary[0]][18]

File attachments are managed by Active Storage, which stores files locally by default. [security_and_compliance_assessment.threat_model_summary[0]][19] This model does not offload bandwidth to a dedicated object storage service like S3, meaning the application server must handle all file upload and download traffic, consuming valuable resources and increasing operational costs. The entire application is packaged for deployment via a multi-process Docker container, defining `web`, `redis`, and `worker` processes. [current_campfire_architecture_analysis.deployment_model[0]][12]

## 2. Why Rust Wins — Orders-of-Magnitude Performance and Cost Upside

Migrating performance-critical backend services from Ruby to Rust provides a well-documented, evidence-based path to dramatic improvements in speed, resource efficiency, and infrastructure cost. Rust's compiled nature, lack of a garbage collector, and fearless concurrency model directly address the primary bottlenecks in the current Campfire architecture.

### HTTP & WebSocket Benchmarks vs Rails — 300–15,000× RPS, 10× Latency Cut

The performance gains from a Rust rewrite are not incremental; they represent a step-change in capability. Real-world migrations and benchmarks consistently show that Rust services outperform their dynamic language counterparts by orders of magnitude.

| Metric | Rails Baseline (`once-campfire`) | Estimated Rust Backend | Estimated Improvement Factor | Notes |
| :--- | :--- | :--- | :--- | :--- |
| **HTTP RPS** | ~70 RPS | 21,000 - 1,100,000+ RPS | **300x - 15,000x+** | The range depends heavily on the benchmark type. Even at the low end, the improvement is several orders of magnitude. [estimated_performance_gains_rust.http_performance[0]][16] |
| **HTTP p99 Latency** | ~35 ms | ~1.5 ms | **~23x Lower** | Rust's efficiency and lack of GC lead to extremely low and consistent latencies. [estimated_performance_gains_rust.http_performance[2]][20] |
| **WebSocket Capacity** | Hundreds (bottlenecks at ~5k) | 33,000+ per node | **~6x - 50x+** | Rust can handle significantly more connections on a single node before requiring horizontal scaling. [estimated_performance_gains_rust.websocket_performance[0]][16] |
| **WebSocket p95 Latency** | 840 ms | ~80 ms | **~10.5x Lower** | Faster processing and message broadcasting result in a vastly improved user experience for real-time features. [estimated_performance_gains_rust.websocket_performance[0]][16] |
| **WebSocket Memory** | 3.5 GB for 20k connections | Flat, low usage (<1GB for 20k connections) | **4x+ More Efficient** | Rust's memory management provides significant cost savings and stability for connection-heavy applications. [estimated_performance_gains_rust.websocket_performance[0]][16] |
| **Job Throughput** | Limited by GVL (especially for CPU-bound tasks) | High (true parallelism across all cores) | **Significant (10x-100x+)** | This is a theoretical estimate. The actual gain depends on the job type, but the architectural advantage for CPU-intensive work is fundamental. [estimated_performance_gains_rust.background_job_performance[0]][16] |

Deliveroo, for example, saw a **17x speedup** in the computation phase of their dispatch service after migrating it from Ruby to Rust. [estimated_performance_gains_rust.http_performance[0]][16] Another case study showed a Rust API endpoint performing **12 times faster** than its Ruby version. [primary_recommendation[3]][21]

### Real-world Cost Case Studies — 75–90% Infra Savings Documented

This raw performance translates directly into substantial and verifiable cost savings. Because Rust services require significantly less CPU and memory, they can run on smaller, cheaper server instances and handle more traffic per node.

* **Case Study 1 (Gateway Service):** A migration of a Rails gateway service to Rust resulted in an **87% decrease** in monthly compute costs, dropping from $71.09 to just $8.89. [estimated_cost_savings_rust.compute_cost_reduction[0]][1] This was driven by a **94% decrease in CPU utilization and a 97% decrease in memory utilization**. [estimated_cost_savings_rust.compute_cost_reduction[0]][1]
* **Case Study 2 (API Endpoint):** A Rust HTTP API endpoint ran on a Heroku dyno that was **10 times cheaper** than its Ruby predecessor, with memory usage dropping from over 2GB to just 4MB. [estimated_cost_savings_rust.case_study_examples[1]][1]
* **Case Study 3 (Large-Scale Savings):** One company projected nearly **$300,000 in annual cost savings** after rewriting a single critical service in Rust, demonstrating the significant financial impact at scale. [estimated_cost_savings_rust.case_study_examples[0]][22]

Overall, a conservative estimate for compute cost savings from a Ruby-to-Rust migration is in the range of **75% to 90%**. [estimated_cost_savings_rust.compute_cost_reduction[0]][1] This reduction in Total Cost of Ownership (TCO) makes the application's costs less sensitive to traffic growth, providing a crucial buffer against unexpected spikes and making capacity planning more predictable. [estimated_cost_savings_rust.tco_projection_summary[1]][1]

## 3. Proposed Rust Microservice Topology — Axum-centric, Message-Bus Decoupled

To capitalize on Rust's performance, a microservices-oriented architecture is proposed. This approach replaces the Rails monolith with a set of specialized, independently scalable services that communicate over a message bus. This enhances fault isolation, maintainability, and performance.

### Service Map: API, WebSocket Gateway, Jobs, Media, Presence

The recommended web framework is **Axum**, built by the Tokio team, for its seamless integration with the Tokio async ecosystem, excellent performance-to-complexity ratio, and robust, built-in WebSocket support. [proposed_rust_backend_architecture.framework_choice[0]][23] [proposed_rust_backend_architecture.framework_choice[1]][24] The entire backend will be built on the **Tokio** asynchronous runtime, enabling highly concurrent, non-blocking I/O capable of managing hundreds of thousands of tasks efficiently. [proposed_rust_backend_architecture.concurrency_model[2]][23]

| Service | Framework/Library | Responsibilities | Replaces |
| :--- | :--- | :--- | :--- |
| **HTTP API Service** | Axum | Handles stateless RESTful API for users, rooms, message history, authentication. | Core Rails controllers/models |
| **WebSocket Gateway** | Axum (with WebSockets) | Manages all persistent WebSocket connections, subscriptions, and real-time broadcasts. | Action Cable |
| **Presence Service** | Axum | Manages user online/offline status via events from the gateway and updates a shared Redis cache. | Ad-hoc presence logic |
| **Job Processor** | `apalis` / Custom Tokio worker | Asynchronously processes background jobs like push notifications, media uploads, webhooks. | Resque |
| **Media Service** | Axum / `rusoto` | Handles file uploads (via pre-signed URLs), thumbnailing (`libvips`), and object storage (S3/MinIO). | Active Storage |

### Data Layer: PostgreSQL + sqlx with RLS for Multi-tenant Growth

The data persistence layer should be upgraded from SQLite3 to **PostgreSQL** for its robustness, concurrency, and scalability features. [proposed_rust_backend_architecture.data_persistence[0]][25] The recommended library for database interaction is **`sqlx`**, a modern, async-native SQL toolkit that provides compile-time checking of queries against the database schema, preventing a large class of runtime errors. [rust_technical_deep_dives.0.analysis_summary[0]][18] For developers preferring a more Rails-like experience, **SeaORM** is a full-fledged ORM built on `sqlx`. [rust_technical_deep_dives.0.analysis_summary[0]][18] Connection pooling is essential and will be managed by a library like `deadpool` or `bb8`. [rust_technical_deep_dives.0.key_considerations[0]][18]

### Messaging Backbone: NATS JetStream Choice Matrix

A message bus is essential for decoupled, asynchronous communication between the microservices. **NATS JetStream** is the top recommendation for its low latency, high throughput, and operational simplicity. [primary_recommendation[0]][26] [primary_recommendation[1]][27]

| Broker | Pros | Cons | Best For |
| :--- | :--- | :--- | :--- |
| **NATS JetStream** | Extremely low latency, high throughput, simple operations, stable Rust client (`nats.rs`). | Newer than alternatives, smaller community. | Real-time messaging, presence, job queuing. |
| **Redis Streams** | Pragmatic choice (Redis already in stack), persistent, consumer groups. | Requires more application logic for retries/DLQs. | Lightweight inter-service communication. |
| **Apache Kafka** | Extreme throughput, exactly-once semantics, powerful ecosystem. | Significant operational overhead and complexity. | High-volume, mission-critical event streaming. |

## 4. Incremental Migration Strategy — Strangler-Fig with Zero Downtime

A full rewrite is risky. The recommended approach is the **Strangler-Fig pattern**, an incremental strategy that replaces the legacy Rails application piece by piece with new Rust services, ensuring minimal risk and near-zero downtime. [incremental_migration_plan_rust.pattern[0]][28]

### Proxy & Session Sharing Mechanics — NGINX Routes + rails-cookie-parser

An edge proxy (e.g., NGINX, Envoy) will be placed in front of the entire application. [incremental_migration_plan_rust.proxy_strategy[0]][28]
1. **Initial State**: The proxy routes 100% of traffic to the existing Rails monolith.
2. **Route-by-Route Migration**: As new Rust services are built, the proxy configuration is updated to route specific paths (e.g., `/api/v1/search`, `/cable` for WebSockets) to the new services. [incremental_migration_plan_rust.proxy_strategy[0]][28]
3. **Session Sharing**: To ensure a seamless user experience, the Rust services must validate the session cookie created by Rails. This is achieved by securely sharing the `secret_key_base` and using a crate like `rails-cookie-parser` to decrypt the cookie. [incremental_migration_plan_rust.session_sharing_strategy[0]][28]

This proxy-based approach allows for instant rollbacks by simply reverting the routing rules, providing a complete safety net. [incremental_migration_plan_rust.rollback_strategy[0]][28]

### Dual-Write & Backfill for DB Cutover — Stepwise Entity Migration Checklist

Migrating from SQLite3 to PostgreSQL requires a careful, phased data migration strategy to ensure consistency and avoid data loss. [incremental_migration_plan_rust.data_migration_strategy[0]][28]

| Step | Action | Purpose |
| :--- | :--- | :--- |
| 1. **Dual-Write** | Modify application logic to write new data to both SQLite and PostgreSQL simultaneously. | Keep the new database in sync with live data. |
| 2. **Backfill** | Migrate historical data from SQLite to PostgreSQL in waves (e.g., users, then rooms, then messages). | Populate the new database without overloading the system. |
| 3. **Verification** | Continue reading from SQLite as the source of truth. Asynchronously read from PostgreSQL and compare data to log discrepancies. | Verify data consistency and the integrity of the migration process. |
| 4. **Cutover** | Once an entity's data is fully backfilled and verified, switch all reads for that entity to PostgreSQL. | Make the new database the system of record, one data model at a time. |

### Canary & Rollback Playbook — Traffic Mirroring, Feature Flags, SLA Gating

A safe rollout is managed using a combination of dark launches and canary releases. [incremental_migration_plan_rust.testing_and_release_strategy[0]][28]

* **Dark Launches**: Before sending live traffic, the proxy can be configured to mirror a copy of production requests to the new Rust service. The responses are discarded, but this allows for testing performance and stability under real-world load without user impact. [incremental_migration_plan_rust.testing_and_release_strategy[0]][28]
* **Canary Releases**: Once stable, the service is rolled out to a small subset of users (e.g., 1%, 5%) by configuring the proxy to split traffic. This allows for targeted testing before a full release. [incremental_migration_plan_rust.testing_and_release_strategy[0]][28]
* **Feature Flags**: For granular control, new features powered by Rust services can be wrapped in feature flags, allowing them to be enabled or disabled in real-time without a new deployment, providing a rapid rollback path for individual features. [incremental_migration_plan_rust.rollback_strategy[0]][28]

## 5. WASM Reality Check — Selective Wins, Full Rewrite Pitfalls

While WebAssembly (WASM) offers exciting possibilities, a full conversion of the Campfire application is currently impractical and carries significant risk. The most effective strategy is to use WASM selectively for high-impact, client-side computations.

### Client-Side Gains: Markdown, Image Resize, E2EE in WASM

Compiling the entire Rails application to run in the browser via `ruby.wasm` is technically feasible but faces major hurdles. [wasm_conversion_feasibility_analysis.client_side_summary[0]][7] The most significant drawback is the initial bundle size; a basic `wasmify-rails` app can produce a **74-78 MB** core module, with the full application exceeding **100 MB**. [wasm_conversion_feasibility_analysis.key_tradeoffs[0]][29] This would be unacceptable for a production chat application.

However, targeted use of WASM for specific, computationally intensive client-side tasks can yield significant benefits.

| Hotspot Candidate | Rationale | Expected Performance Gain | Implementation |
| :--- | :--- | :--- | :--- |
| **Markdown/Emoji Parsing** | Provides instant, real-time feedback as users type, offloading work from the server. [selective_wasm_integration_strategy.rationale[1]][9] | **2x to 10x** faster than JS libraries. `markdown-wasm` is 2x faster than `markdown-it`. [selective_wasm_integration_strategy.expected_performance_gain[0]][9] | Compile `pulldown-cmark` (Rust) or `markdown-wasm` (C) to WASM and run in a Web Worker. [selective_wasm_integration_strategy.implementation_notes[0]][9] |
| **Image Resizing** | Generate attachment previews client-side before upload, improving UI responsiveness and reducing server load. | Significant reduction in perceived latency for uploads. | Use a Rust image processing library like `image` compiled to WASM. |
| **End-to-End Encryption** | Perform all cryptographic operations in the browser, ensuring zero-trust security. | N/A (Security gain) | Compile a Rust crypto library like `OpenMLS` to WASM. [innovative_rewrite_capabilities.0.enabling_technologies[1]][30] |

### Server-Side Gaps: WASI Socket Immaturity & Cold-Start Limits

Running the entire Campfire backend on a server-side WASM (WASI) runtime is not practical today. [wasm_conversion_feasibility_analysis.server_side_summary[0]][29] The primary blocker is networking:
* **WASI Preview 1**, the current stable version, **lacks socket support**, making it impossible to run a WebSocket server. [wasm_conversion_feasibility_analysis.technical_limitations[1]][6]
* **WASI Preview 2** is introducing `wasi-sockets`, but the ecosystem for high-performance, asynchronous I/O and direct database connectivity is not yet mature. [wasm_conversion_feasibility_analysis.server_side_summary[1]][7]

Current server-side WASM platforms are designed for stateless functions, not for running a monolithic, stateful application like Campfire. [wasm_conversion_feasibility_analysis.server_side_summary[0]][29]

## 6. Future-Proof Capabilities — What Rust + WASM Uniquely Unlocks

A hybrid Rust and WASM architecture does more than just improve performance; it unlocks a new class of innovative features that can provide significant competitive differentiation and user value.

### E2EE with MLS & WASM — Privacy Premium Tier Blueprint

By compiling high-performance Rust cryptographic libraries to WASM, the application can implement state-of-the-art, zero-trust security. [innovative_rewrite_capabilities.0.enabling_technologies[0]][31]
* **Capability**: End-to-End Encryption (E2EE) with Forward Secrecy. All messages and files are encrypted on the client, making them inaccessible to the server. [innovative_rewrite_capabilities.0.description[0]][31]
* **Technology**: Use `OpenMLS` (a Rust implementation of the IETF's Messaging Layer Security standard) or a Rust wrapper for the Signal Protocol, compiled to WASM. [innovative_rewrite_capabilities.0.enabling_technologies[0]][31] Keys are stored securely in the browser using IndexedDB and the WebCrypto API. [innovative_rewrite_capabilities.0.enabling_technologies[1]][30]
* **Impact**: Dramatically improves user trust and makes the application suitable for privacy-sensitive communications, creating a potential premium feature. [innovative_rewrite_capabilities.0.impact[0]][31]

### CRDT Offline-First Chat — Resilience in Low-Connectivity Markets

The application can be transformed into a "local-first" collaborative tool that works seamlessly online and offline. [innovative_rewrite_capabilities.1.description[2]][32]
* **Capability**: CRDT-based collaboration and offline sync. Concurrent edits are automatically merged without conflicts, and the app remains fully functional without a network connection. [innovative_rewrite_capabilities.1.description[2]][32]
* **Technology**: Use mature Rust CRDT libraries with WASM bindings, such as `yrs` (a Rust port of Yjs) or `automerge-rs`. [innovative_rewrite_capabilities.1.enabling_technologies[0]][33] [innovative_rewrite_capabilities.1.enabling_technologies[1]][34]
* **Impact**: Massively enhances reliability and user experience, making the app more robust for users in environments with poor connectivity. [innovative_rewrite_capabilities.1.impact[4]][32]

### AI at the Edge — Candle-Powered Summarization Without Data Leak

Advanced AI features can be integrated to run entirely within the user's browser, preserving privacy by design.
* **Capability**: Privacy-Preserving Client-Side AI. Features like real-time message summarization, smart search, or content moderation run locally.
* **Technology**: Use the `Hugging Face Candle` ML framework, a minimalist Rust library with excellent WASM support, to run models like LLaMA2 or Whisper directly on the client's machine.
* **Impact**: Provides powerful AI features without compromising user privacy or incurring high server-side computational costs. [innovative_rewrite_capabilities.2.impact[1]][35]

### Secure Plugin Ecosystem with WASM Sandboxing

A secure ecosystem for third-party plugins can be created, fostering a vibrant developer community. [innovative_rewrite_capabilities.3.impact[0]][35]
* **Capability**: Secure, sandboxed plugin/extensibility model. [innovative_rewrite_capabilities.3.capability[2]][10]
* **Technology**: Use a WASM-based plugin framework like `Extism`, which provides a language-agnostic, capability-based security sandbox. [innovative_rewrite_capabilities.3.enabling_technologies[0]][10] Plugins run as WASM modules and are prevented from accessing resources unless explicitly granted permission. [innovative_rewrite_capabilities.3.description[1]][35]
* **Impact**: Enables rich customization and integration while ensuring extensions can be run safely, building trust in the platform's extensibility. [innovative_rewrite_capabilities.3.impact[0]][35]

## 7. Observability & Reliability Stack — OTel Traces, SLO-Driven Alerts

A modern Rust backend requires a modern approach to observability and reliability, focusing on user experience and actionable alerts rather than noisy, low-level metrics.

### Golden-Signal Dashboards & Burn-Rate Alerts

The monitoring strategy will be based on user-centric Service Level Objectives (SLOs) and the Four Golden Signals: Latency, Traffic, Errors, and Saturation. [observability_and_reliability_strategy.monitoring_and_alerting[0]][36] [observability_and_reliability_strategy.monitoring_and_alerting[1]][37] The core telemetry stack will be built on OpenTelemetry (OTel) using the `tracing` crate in Rust, exporting data via OTLP to a backend like Grafana Tempo or Jaeger. [observability_and_reliability_strategy.telemetry_stack[2]][38] [observability_and_reliability_strategy.telemetry_stack[3]][39]

Alerting will be based on the consumption rate of the error budget (the "burn rate"). [observability_and_reliability_strategy.monitoring_and_alerting[1]][37] This multi-window, multi-burn-rate strategy detects both critical outages and slow-burning issues while minimizing false positives. [observability_and_reliability_strategy[5]][40]

| Alert Tier | Condition (for 99.9% SLO over 30d) | Urgency |
| :--- | :--- | :--- |
| **Critical** | 2% of monthly budget consumed in 1 hour (14.4x burn rate) | High (Page) |
| **Warning** | 5% of monthly budget consumed in 6 hours (6x burn rate) | Medium (Page) |
| **Info** | 10% of monthly budget consumed over 3 days (1x burn rate) | Low (Ticket) |

A key feature will be **exemplars**, which link aggregated metrics in Prometheus/Grafana directly to specific traces in Jaeger/Tempo, allowing engineers to jump from a latency spike to the exact trace that caused it. [observability_and_reliability_strategy[0]][41] [observability_and_reliability_strategy[1]][42]

### Resilience Middleware: Timeouts, Retries, Circuit Breakers

The Rust backend will be made resilient to partial and transient failures using a suite of patterns implemented as composable middleware with the `tower` library.

* **Timeouts (`tower::timeout`):** Enforce deadlines on all downstream requests to prevent cascading failures.
* **Retries (`tower::retry`):** Automatically retry failed requests with exponential backoff and jitter. A retry budget will be used to prevent "retry storms". [observability_and_reliability_strategy.resilience_patterns[0]][43]
* **Rate/Concurrency Limiting (`tower::limit`):** Protect the service from traffic spikes.
* **Load Shedding (`tower::load_shed`):** Proactively drop requests when the service is near saturation.
* **Circuit Breakers (`failsafe`):** Automatically stop sending requests to a failing dependency, failing fast and periodically checking for recovery.
* **Dead Letter Queues (DLQs):** Move repeatedly failing background jobs to a separate queue for inspection, a feature well-supported by NATS JetStream.

## 8. Developer Experience & CI/CD — Fast Feedback, Secure Supply Chain

A productive developer experience and a fast, secure CI/CD pipeline are critical for the success of the rewrite. The Rust ecosystem provides a powerful, standardized toolchain to achieve this.

### Cargo-chef, sccache, Multi-stage Docker for 70% Faster Builds

The core toolchain will consist of `rustup` for managing compilers, `cargo` for builds and package management, `clippy` for linting, and `rustfmt` for code formatting. [developer_experience_and_cicd.core_tooling[0]][44] [developer_experience_and_cicd.core_tooling[4]][45] [developer_experience_and_cicd.core_tooling[5]][46]

The CI/CD pipeline will be highly optimized for speed and security:
* **Multi-Stage Dockerfiles**: Separate dependency compilation from application code to maximize layer caching. [developer_experience_and_cicd.ci_cd_pipeline[0]][47]
* **`cargo-chef`**: Pre-compiles dependencies into a separate, cached Docker layer. [developer_experience_and_cicd.ci_cd_pipeline[0]][47]
* **`sccache`**: Provides even finer-grained caching of individual compilation units, used with Docker BuildKit's cache mounts to drastically reduce rebuild times. [developer_experience_and_cicd.ci_cd_pipeline[0]][47] [developer_experience_and_cicd.ci_cd_pipeline[2]][48]
* **Minimal Base Images**: For production, the app will be compiled to a static binary using the `musl` target and copied into a secure, minimal base image like `gcr.io/distroless/static-debian11`. [developer_experience_and_cicd.ci_cd_pipeline[0]][47]

### Test Pyramid: Unit → Property → Load → E2E with cargo-nextest

A multi-layered testing strategy will ensure reliability. [developer_experience_and_cicd.testing_strategy[0]][46]
1. **Unit Tests**: Fast, isolated tests using Rust's built-in `#[test]` and `#[tokio::test]`.
2. **Integration Tests**: Located in the `tests` directory, verifying component interactions.
3. **Property-Based Tests**: Using `proptest` to check code against a wide range of auto-generated inputs.
4. **Contract Tests**: Using `pact-rust` to validate inter-service communication contracts.
5. **Load Tests**: Using `k6` or `vegeta` to assess performance under heavy traffic.
6. **E2E Tests**: Validating the full application flow in a staging environment.

The `cargo-nextest` test runner is recommended for its superior speed and features over the default `cargo test`.

### Cargo-audit, cargo-deny, Sigstore Signing

The software supply chain will be secured using a suite of Rust-native tools integrated into the CI pipeline:
* **`cargo-audit`**: Scans dependencies for known vulnerabilities against the RustSec advisory database.
* **`cargo-deny`**: Enforces license and dependency policies, blocking builds with unapproved licenses or duplicate crate versions.
* **`cargo-vet`**: Maintains a curated set of audited and trusted dependencies for rigorous vetting.
* **SBOM Generation**: Tools like `cargo-cyclonedx` will generate a Software Bill of Materials.
* **Artifact Signing**: Release binaries will be signed using Sigstore's `cosign` tool for verifiable SLSA-aligned provenance.

## 9. Security & Compliance — From CSRF to SOC 2 Readiness

A Rust-based system must be designed with security and compliance as first-class citizens, leveraging the language's safety guarantees and a mature ecosystem of security-focused libraries.

### Threat Model & Mitigations Matrix

The primary threats to the Campfire application involve its core features: file attachments, bot APIs, and administrative functions. [security_and_compliance_assessment.threat_model_summary[0]][19] A Rust backend can effectively mitigate common web vulnerabilities.

| Vulnerability | Mitigation Strategy | Recommended Crates |
| :--- | :--- | :--- |
| **Cross-Site Request Forgery (CSRF)** | Implement Double-Submit Token pattern, hardened with a server-side session store. | `axum_csrf`, `actix-csrf` |
| **Cross-Site Scripting (XSS)** | Use context-aware output escaping, provided by default in modern templating engines. | `Askama`, `Tera` |
| **Server-Side Request Forgery (SSRF)** | Rigorously validate any user-provided URLs against an allowlist of domains and IPs. | Custom validation logic |
| **Insecure Web Push** | Adhere to RFC 8291 (payload encryption) and RFC 8292 (VAPID authentication). | `web-push` |

All secrets, including session keys and cloud credentials, must be managed in a dedicated secrets management system, not environment variables. [security_and_compliance_assessment.threat_model_summary[1]][49]

### GDPR "Right to Erasure" & Audit-Log Strategy

Operating a chat system requires strict adherence to data privacy regulations like GDPR and CCPA.
* **GDPR**: The system must implement the "right to be forgotten" (Article 17), requiring a robust mechanism for permanently deleting all of a user's data upon request.
* **SOC 2 / HIPAA**: For B2B or healthcare use cases, strong controls, end-to-end encryption for PHI, and comprehensive audit logging are required. [security_and_compliance_assessment.privacy_and_compliance[0]][50]

To meet these standards, the Rust application should use a structured logging library like `tracing` to create detailed, immutable audit logs of all security-relevant events (logins, data access, permission changes), storing them in a WORM-compliant system. [security_and_compliance_assessment.privacy_and_compliance[0]][50]

## 10. Tenancy & Deployment Automation — Scaling from Silos to SaaS

For a growth-oriented future, the application must evolve from its single-tenant model to a scalable, cost-effective multi-tenant architecture. Automation is the key to managing this complexity efficiently.

### RLS Multi-Tenant Economics vs Single-Tenant Costs

The analysis presents two paths: maintaining the single-tenant "silo" model or moving to a multi-tenant model. [tenancy_and_deployment_automation.tenancy_model_analysis[2]][51] For growth, the recommended architecture is a **multi-tenant model using shared tables with PostgreSQL's Row-Level Security (RLS)**. [tenancy_and_deployment_automation.recommended_tenancy_model[0]][52]

| Tenancy Model | Data Isolation | Cost-Efficiency | Operational Complexity | Scalability | Recommendation |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Single-Tenant (Silo)** | Maximum (separate DB per tenant) | Low (high resource duplication) | High (managing many instances) | Low | Viable only for a few high-value clients. |
| **Multi-Tenant (RLS)** | High (enforced at DB row level) | High (maximum resource sharing) | Medium (requires careful implementation) | High | **Recommended for scalable growth.** |

The RLS model is the most cost-effective and scalable, and its security can be robustly implemented in a Rust backend by setting a tenant context variable on each database connection. [tenancy_and_deployment_automation.tenancy_model_analysis[3]][52]

### Terraform + Helm GitOps Pipeline for 1-Click Tenant Spin-up

Deployment will be heavily automated using an Infrastructure as Code (IaC) and GitOps approach.
* **IaC**: **Terraform** modules will define the complete infrastructure for an instance, allowing new tenants to be provisioned programmatically.
* **Kubernetes Templating**: **Helm charts** will template the application deployments, separating code from instance-specific configuration.
* **GitOps**: All configuration will be stored in a Git repository, providing a single source of truth and an auditable history of changes.
* **Secret Management**: In Kubernetes, the **External Secrets Operator** will sync secrets from a cloud provider's secret manager (e.g., AWS Secrets Manager), or **Sealed Secrets** will be used to safely store encrypted secrets in Git. [tenancy_and_deployment_automation.deployment_automation_strategy[0]][53]

This automated pipeline is critical for managing either a large number of single-tenant instances or a complex multi-tenant environment efficiently. [tenancy_and_deployment_automation.deployment_automation_strategy[0]][53]

## References

1. *I Saved 87 Percent on Compute Costs by Switching Languages*. https://worldwithouteng.com/articles/i-saved-87-percent-on-compute-costs-by-switching-languages/
2. *Action Cable vs Anycable : r/rails*. https://www.reddit.com/r/rails/comments/14o99ru/action_cable_vs_anycable/
3. *Overcoming Action Cable's Limitations: AnyCable on AWS ECS for ...*. https://medium.com/developer-protips/overcoming-action-cables-limitations-anycable-on-aws-ecs-for-rails-real-time-apps-cfeb73b7ff56
4. *Evil Martians: Ruby on Rails on WebAssembly — A Guide to Full-Stack in Browser*. https://evilmartians.com/chronicles/ruby-on-rails-on-webassembly-a-guide-to-full-stack-in-browser-action
5. *Doing terrible things with ruby.wasm*. https://www.rubyevents.org/talks/doing-terrible-things-with-ruby-wasm
6. *ruby.wasm is a collection of WebAssembly ports ...*. https://github.com/ruby/ruby.wasm
7. *Ruby on Rails on WebAssembly*. https://web.dev/blog/ruby-on-rails-on-webassembly
8. *How Deliveroo migrated from Ruby to Rust without breaking production*. https://www.packtpub.com/networking-in/learning/tech-news/how-deliveroo-migrated-from-ruby-to-rust-without-breaking-production?srsltid=AfmBOooTTlO3mBk8i1qeZUWk7sE2nxHWKFC0j1swOAbdxXQ6Cbs_3eSW
9. *InfoQ: Markdown-Wasm, a Very Fast Markdown Parser Written in WebAssembly*. https://www.infoq.com/news/2020/10/markdown-wasm-fast-parser/
10. *Extism - Cross-language WebAssembly plugin framework*. https://extism.org/
11. *Once Campfire README*. http://raw.githubusercontent.com/basecamp/once-campfire/main/README.md
12. *once-campfire Dockerfile*. http://github.com/basecamp/once-campfire/blob/main/Dockerfile
13. *once-campfire Repository - .ruby-version and commit notes*. http://github.com/basecamp/once-campfire/blob/main/.ruby-version
14. *config/puma.rb*. http://raw.githubusercontent.com/basecamp/once-campfire/HEAD/config/puma.rb
15. *GitHub - once-campfire config/cable.yml*. http://github.com/basecamp/once-campfire/blob/main/config/cable.yml
16. *Moving from Ruby to Rust — Deliveroo Engineering*. https://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html
17. *Once Campfire Gemfile*. http://raw.githubusercontent.com/basecamp/once-campfire/main/Gemfile
18. *SeaORM vs Diesel — Internal Design*. https://www.sea-ql.org/SeaORM/docs/internal-design/diesel/
19. *GitHub - basecamp/once-campfire*. http://github.com/basecamp/once-campfire
20. *Axum Benchmark*. https://sharkbench.dev/web/rust-axum
21. *Rust vs Ruby/RoR performances for API calls - Reddit*. https://www.reddit.com/r/rust/comments/v3xgqp/rust_vs_rubyror_performances_for_api_calls/
22. *A Case Study in Rewriting a Critical Service in Rust*. https://wxiaoyun.com/blog/rust-rewrite-case-study/
23. *Leapcell - The Best of Serverless Web Hosting*. https://dev.to/leapcell/rust-web-frameworks-compared-actix-vs-axum-vs-rocket-4bad
24. *Rust Web Frameworks Compared: Actix vs Axum vs Rocket*. https://leapcell.medium.com/rust-web-frameworks-compared-actix-vs-axum-vs-rocket-20f0cc8a6cda
25. *TechEmpower Framework Benchmarks Round 23 Fortunes Section*. https://www.techempower.com/benchmarks/
26. *Rust client for NATS, the cloud native messaging system.*. https://github.com/nats-io/nats.rs
27. *nats::jetstream - Rust*. https://docs.rs/nats/latest/nats/jetstream/index.html
28. *Strangler Fig pattern - Azure Architecture Center*. https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig
29. *Rails + WASM: A Future for Server-Side Rendering?*. https://dev.to/alex_aslam/rails-wasm-a-future-for-server-side-rendering-5dfo
30. *OpenMLS Book - WebAssembly*. https://book.openmls.tech/user_manual/wasm.html
31. *OpenMLS (Rust MLS implementation)*. https://github.com/openmls/openmls
32. *rust-crdt - Rust CRDTs*. https://github.com/rust-crdt/rust-crdt
33. *Automerge Rust/WASM Ecosystem*. https://github.com/adelsz/automerge-rs
34. *y-crdt/y-crdt*. https://github.com/y-crdt/y-crdt
35. *Extism - Extensible plugins with WebAssembly*. https://github.com/extism/extism
36. *The Four Golden Signals and Monitoring Practices (SRE Book)*. https://sre.google/sre-book/monitoring-distributed-systems/
37. *The Four Golden Signals - FireHydrant*. https://firehydrant.com/blog/4-sre-golden-signals-what-they-are-and-why-they-matter/
38. *OpenTelemetry Rust Exporters Registry*. https://opentelemetry.io/docs/languages/rust/exporters/
39. *Working with OpenTelemetry using Rust*. https://www.shuttle.dev/blog/2024/04/10/using-opentelemetry-rust
40. *Why Multi-Window Burn Rate Alerts Use 14.4× and 6*. https://blog.joshdow.ca/deriving-the-magic-sre-numbers/
41. *Jaeger data source | Grafana documentation*. https://grafana.com/docs/grafana/latest/datasources/jaeger/
42. *Exemplars in Grafana Cloud*. https://grafana.com/docs/grafana-cloud/send-data/traces/exemplars/
43. *tower::retry::budget - Rust*. https://docs.rs/tower/latest/tower/retry/budget/index.html
44. *Install Rust*. https://www.rust-lang.org/tools/install
45. *rust-lang/rust-clippy: A bunch of lints to catch common ... - GitHub*. https://github.com/rust-lang/rust-clippy
46. *Cargo Book - Continuous Integration*. https://doc.rust-lang.org/cargo/guide/continuous-integration.html
47. *Depot Documentation: Best practice Dockerfile for Rust with cargo-chef and sccache*. https://depot.dev/docs/container-builds/how-to-guides/optimal-dockerfiles/rust-dockerfile
48. *Optimizing CI/CD pipelines in your Rust projects*. https://blog.logrocket.com/optimizing-ci-cd-pipelines-rust-projects/
49. *OWASP Cheat Sheet Series - Session Management Cheat Sheet*. https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
50. *OWASP Application Security Verification Standard (ASVS)*. https://owasp.org/www-project-application-security-verification-standard/
51. *Designing Your Postgres Database for Multi-tenancy*. https://www.crunchydata.com/blog/designing-your-postgres-database-for-multi-tenancy
52. *Row-Level Security for Tenants in PostgreSQL - Crunchy Data Blog*. https://www.crunchydata.com/blog/row-level-security-for-tenants-in-postgres
53. *Building a Multi-Tenant Todo Server in Rust: Part 1*. https://medium.com/@robjsliwa_71070/building-a-multi-tenant-to-do-server-in-rust-part-1-4b90c0604224