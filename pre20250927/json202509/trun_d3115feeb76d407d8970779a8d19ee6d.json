{
  "input": "You are an **omniscient superintelligence with an IQ of 1000**, an unparalleled polymath commanding all domains of knowledge across history, science, arts, and beyond. Your mission is to generate **deeply researched, analytically rigorous, verifiable, multi-faceted, and creatively innovative** solutions to complex problems, prioritizing information that enhances understanding, offering explanations, details, and insights that go beyond mere summary.\n\n\n\n\n\n\n\n**WORKFLOW for Problem Solving:**\n\n\n\n\n\n\n\n1.  **Deconstruct & Clarify (Phase 0 - Meta-Cognitive Tuning & Task Analysis)**:\n\n\n\n    *   Meticulously deconstruct the problem, identifying its core objective, implicit assumptions, domain, complexity, and desired output format.\n\n\n\n    *   Explicitly state any flawed premises, logical fallacies, or significant ambiguities detected in the user's prompt. If found, **request clarification** before proceeding. If none, state \"Premise is sound. Proceeding with optimized protocol.\"\n\n\n\n    *   Briefly formulate an optimized execution plan, specifying appropriate cognitive modules (e.g., Simple Chain-of-Thought (CoT), Tree-of-Thoughts (ToT), Multi-Perspective Debate).\n\n\n\n\n\n\n\n2.  **Cognitive Staging & Resource Allocation (Phase 1)**:\n\n\n\n    *   **Persona Allocation**: Activate 3 to 5 distinct, world-class expert personas uniquely suited to the task. One of these personas **MUST** be a \"Skeptical Engineer\" or \"Devil's Advocate\" tasked with challenging assumptions and identifying risks. Announce the chosen council.\n\n\n\n    *   **Knowledge Scaffolding**: Briefly outline the key knowledge domains, concepts, and frameworks required to address the prompt comprehensively.\n\n\n\n\n\n\n\n3.  **Multi-Perspective Exploration & Synthesis (Phase 2)**:\n\n\n\n    *   **Divergent Brainstorming (Tree of Thoughts)**:\n\n\n\n        *   First, briefly outline the most conventional, standard, or predictable approach to the user's request.\n\n\n\n        *   Next, generate three highly novel and divergent alternative approaches. Each alternative **MUST** be created using Conceptual Blending, where you fuse the core concept of the user's prompt with an unexpected, distant domain (e.g., \"blend business strategy with principles of mycology\"). For each, explain the blend.\n\n\n\n        *   Evaluate all generated approaches (conventional and blended). Select the single most promising approach or a hybrid of the best elements, and **justify your selection**.\n\n\n\n    *   **Structured Debate (Council of Experts)**:\n\n\n\n        *   Have each expert from your activated council provide a concise opening statement on how to proceed with the selected path.\n\n\n\n        *   Simulate a structured debate: the \"Skeptical Engineer\" or \"Devil's Advocate\" must challenge the primary assertions of the other experts, and the other experts must respond to the challenges.\n\n\n\n        *   Acting as a Master Synthesizer, integrate the refined insights from the debate into a single, cohesive, and nuanced core thesis for the final response.\n\n\n\n\n\n\n\n4.  **Drafting & Verification (Phase 3 - Iterative Refinement & Rigorous Self-Correction)**:\n\n\n\n    *   Generate an initial draft based on the synthesized thesis.\n\n\n\n    *   **Rigorous Self-Correction (Chain of Verification)**:\n\n\n\n        *   Critically analyze the initial draft. Generate a list of specific, fact-checkable questions that would verify the key claims, data points, and assertions in the draft. List 5-10 fact-checkable queries (e.g., \"Is this algorithm O(n log n)? Verify with sample input.\").\n\n\n\n        *   Answer each verification question one by one, based only on your internal knowledge.\n\n\n\n        *   Identify any inconsistencies, errors, or weaknesses revealed by the verification process. Create a **final, revised, and polished response** that corrects these errors and enhances the overall quality.\n\n\n\n    *   **Factuality & Bias**: Ensure all claims are verifiable and grounded in truth, and results are free from harmful assumptions or stereotypes. If any part of your response includes information from outside of the given sources, you **must make it clear** that this information is not from the sources and the user may want to independently verify that information [My initial instructions].\n\n\n\n    * **Final Revision**: Refine for clarity, concision, originality, and impact. Ensure mathematical rigor (e.g., formal proofs), code efficiency (e.g., commented Python), and practical tips.\n\n\n\n    * **Reflective Metacognition**: Before outputting, self-critique: \"Is this extraordinarily profound? Maximally useful? Free of flaws?\"\n\n\nNow, respond exclusively to the user's query\n\n<user query> \nTeach me how to write idiomatic Rust constrained to no-std for systems programming using 400 examples and relevant mermaid diagrams - explain each and every concept and example wth a mermaid diagram",
  "output": {
    "executive_summary": {
      "overview": "Idiomatic `no_std` Rust programming is a specialized discipline for developing software in environments where the standard library (`std`) is unavailable, such as on bare-metal microcontrollers, in operating system kernels, and for firmware. This constraint requires developers to work directly with the `core` library, a platform-agnostic subset of `std` that provides fundamental language primitives but omits OS-dependent features like threading, file I/O, networking, and, crucially, a default heap allocator. Consequently, developers must explicitly manage foundational aspects of the system, including memory allocation (if needed), panic handling, and the program's entry point. The ecosystem is built around a philosophy of zero-cost abstractions, safety, and concurrency, leveraging Rust's type system and ownership model to manage hardware resources safely and efficiently. Key challenges include handling concurrency through interrupts, managing memory in a constrained environment, and interacting with hardware via memory-mapped I/O (MMIO). The `no_std` ecosystem provides a rich set of tools and libraries, such as the `embedded-hal` traits for hardware abstraction, Peripheral Access Crates (PACs) for register access, and frameworks like RTIC and Embassy for building complex, concurrent applications.",
      "key_highlights": "The comprehensive research into `no_std` Rust systems programming reveals several critical takeaways:\n\n1.  **Explicit System Management is Mandatory**: Developers must manually provide a panic handler (e.g., using `panic-halt` or `panic-probe`) and, if dynamic memory is needed, a global allocator (e.g., `talc`, `linked_list_allocator`) to use the `alloc` crate. The program's entry point is also custom, typically managed by runtime crates like `cortex-m-rt` or `riscv-rt`.\n\n2.  **Memory Management is a Core Design Choice**: While the `alloc` crate enables heap usage, the idiomatic approach for many constrained systems is to avoid dynamic allocation entirely. The `heapless` crate is fundamental, providing fixed-capacity, statically-allocated collections (`Vec`, `String`, `HashMap`) that prevent runtime memory failures and ensure deterministic behavior.\n\n3.  **Concurrency is Managed via Hardware Primitives**: In the absence of OS threads, concurrency revolves around interrupts. Safe data sharing between the main loop and Interrupt Service Routines (ISRs) is achieved through critical sections (disabling interrupts, via `critical-section` crate), atomic operations (`core::sync::atomic`), and lock-free queues (`heapless::spsc::Queue`). Frameworks like RTIC provide compile-time guarantees for deadlock-free resource sharing.\n\n4.  **Hardware Abstraction is Trait-Driven**: The `embedded-hal` ecosystem is central to portability. It defines a standard set of traits for peripherals (GPIO, I2C, SPI, etc.), allowing drivers to be written generically and used across any microcontroller with a corresponding HAL implementation.\n\n5.  **Safety is Paramount, Especially for `unsafe` Code**: `unsafe` code is necessary for hardware interaction (MMIO, FFI) but must be encapsulated within safe, high-level abstractions. The typestate pattern is a powerful idiom used to encode a peripheral's state into its type, preventing invalid operations at compile time. Tools like `svd2rust` generate type-safe Peripheral Access Crates (PACs) that wrap volatile register access.\n\n6.  **A Specialized Toolchain is Essential**: The development workflow relies on tools like `probe-rs` (for flashing and debugging via `cargo-embed`), `defmt` (a highly efficient deferred logging framework), and QEMU (for hardware emulation). Linker scripts (`memory.x`) and build configurations (`lto = true`, `panic = \"abort\"`) are critical for optimizing binary size and performance.\n\n7.  **Verification and Testing are Multi-Layered**: Robustness is achieved through a combination of host-side unit tests (using `embedded-hal-mock`), emulation testing with QEMU, and on-target hardware-in-the-loop (HIL) testing with harnesses like `defmt-test`. The Miri interpreter is invaluable for detecting Undefined Behavior in `no_std` code on the host."
    },
    "learning_curriculum_and_diagram_strategy": {
      "structured_curriculum": "A comprehensive curriculum for idiomatic `no_std` Rust, based on pedagogical principles like Cognitive Load Theory and worked examples, can be structured into the following 20 modules. Each module should contain approximately 20 examples, starting with fully explained code and diagrams and gradually 'fading' the explanations to encourage active learning, culminating in 400 learning units.\n\n**Module 1: The `no_std` Foundation**\n*   **Objective**: Understand the core constraints and setup of a `no_std` project.\n*   **Concepts**: `#![no_std]` vs `std`, the `core` crate, target triples, cross-compilation, mandatory panic handlers (`panic-halt`), and custom entry points (`cortex-m-rt::entry`, `_start`).\n\n**Module 2: Memory Models & Ownership**\n*   **Objective**: Apply Rust's ownership model to hardware resources.\n*   **Concepts**: Peripheral singletons, splitting peripherals, `core::cell::{Cell, RefCell, UnsafeCell}`, managing `static mut` risks with safe alternatives, and typestate patterns for encoding hardware state.\n\n**Module 3: Error Handling & Panics**\n*   **Objective**: Design robust, non-panicking APIs.\n*   **Concepts**: `Result`/`Option` patterns, custom lightweight error enums, non-blocking APIs with the `nb` crate, and observability with `defmt` and semihosting.\n\n**Module 4: Memory Allocation**\n*   **Objective**: Master memory management strategies.\n*   **Concepts**: Using the `alloc` crate, implementing a `#[global_allocator]`, comparing allocator types (bump, linked-list), and using allocation-free patterns with `heapless` and `arrayvec`.\n\n**Module 5: Concurrency & Synchronization**\n*   **Objective**: Write safe concurrent code without an OS.\n*   **Concepts**: `core::sync::atomic` with memory orderings, critical sections (`critical-section` crate), spinlocks, and lock-free SPSC/MPSC queues.\n\n**Module 6: Interrupts & Exceptions**\n*   **Objective**: Handle hardware interrupts and faults.\n*   **Concepts**: `#[interrupt]` and `#[exception]` attributes, configuring NVIC/PLIC, safe shared-state access with mutexes, ISR-to-main communication, and HardFault analysis.\n\n**Module 7: Memory-Mapped I/O (MMIO)**\n*   **Objective**: Interact safely with hardware registers.\n*   **Concepts**: `read_volatile`/`write_volatile`, using `svd2rust`-generated PACs, bitfield patterns (`modular-bitfield`), and creating zero-cost safe wrappers.\n\n**Module 8: Toolchain & Linking**\n*   **Objective**: Control the build process and memory layout.\n*   **Concepts**: Linker scripts (`memory.x`), `#[link_section]` attribute, stack/heap layout, startup code, and build optimizations (`lto`, `codegen-units`).\n\n**Module 9: Drivers & HALs**\n*   **Objective**: Implement and use portable device drivers.\n*   **Concepts**: The `embedded-hal` trait ecosystem, blocking vs. non-blocking (`nb`) vs. `async` drivers, DMA-backed transfers, and typestate for driver state machines.\n\n**Module 10: Timing & Low Power**\n*   **Objective**: Manage time and energy consumption.\n*   **Concepts**: Using timers (SysTick, DWT) for delays, tick vs. tickless designs, RTC-based wakeups, clock tree configuration, and low-power modes (`WFI`/`WFE`).\n\n**Module 11: Testing, Simulation & Debugging**\n*   **Objective**: Build a robust testing strategy.\n*   **Concepts**: Host-side testing with `embedded-hal-mock`, emulation with QEMU, on-target debugging with `probe-rs` and `cargo-embed`, and HIL testing with `defmt-test`.\n\n**Module 12: FFI & Unsafe Integration**\n*   **Objective**: Interface with C and assembly code.\n*   **Concepts**: `extern \"C\"`, `#[repr(C)]`, using `build.rs` with the `cc` crate, generating bindings with `bindgen`, and managing ABI contracts.\n\n**Module 13: Inline Assembly & Intrinsics**\n*   **Objective**: Use architecture-specific instructions.\n*   **Concepts**: The `asm!` macro for critical instructions (`wfi`, `cpsid`), `core::arch` intrinsics, and memory/compiler fences.\n\n**Module 14: Portability & Conditional Compilation**\n*   **Objective**: Write code that runs on multiple MCUs.\n*   **Concepts**: `#[cfg]` patterns (`target_arch`, feature flags), trait-driven design, and CI strategies with build matrices.\n\n**Module 15: Persistent Storage**\n*   **Objective**: Work with flash and EEPROM.\n*   **Concepts**: `embedded-storage` traits, wear-leveling, power-fail safe commits, and integrating filesystems like `littlefs2`.\n\n**Module 16: Networking**\n*   **Objective**: Implement lightweight network stacks.\n*   **Concepts**: Zero-copy packet parsing (`etherparse`), checksums, and using `smoltcp` or `embassy-net` with a `phy::Device` trait implementation.\n\n**Module 17: OS Kernel Basics**\n*   **Objective**: Understand the fundamentals of OS development.\n*   **Concepts**: Bootloader handoff (Multiboot2/UEFI), GDT/IDT setup, paging and memory mapping, and implementing frame/slab allocators.\n\n**Module 18: Safety & Verification**\n*   **Objective**: Formally reason about code correctness.\n*   **Concepts**: `unsafe` encapsulation patterns, proving invariants with typestates, property-based testing, and using tools like Miri and Kani.\n\n**Module 19: Performance & Optimization**\n*   **Objective**: Benchmark and optimize for speed and size.\n*   **Concepts**: Cycle counting with DWT/PMU, `Cargo.toml` profile optimization, const-evaluation, and stack usage analysis with `cargo-call-stack`.\n\n**Module 20: Real-World Case Studies**\n*   **Objective**: Synthesize knowledge by analyzing end-to-end systems.\n*   **Concepts**: Compare alternative designs (e.g., polling vs. interrupt vs. DMA for a UART driver), analyzing trade-offs in latency, CPU usage, and code complexity.",
      "diagram_taxonomy": "A uniform diagramming strategy using Mermaid.js is essential for teaching `no_std` concepts effectively, leveraging dual-coding theory to enhance comprehension. The following taxonomy standardizes diagram usage for different patterns:\n\n1.  **Flowcharts (`flowchart`)**: Ideal for representing sequential processes and decision logic.\n    *   **Use Cases**: Boot sequences (Reset -> Init .data/.bss -> main), interrupt dispatch flow (Event -> NVIC -> ISR), memory allocation logic (Request -> Find Block -> Return Pointer), and build processes.\n    *   **Template**: `flowchart TD; A[Start] --> B{Decision?}; B -- Yes --> C[Process 1]; B -- No --> D[Process 2]; C --> E[End]; D --> E;`\n\n2.  **Sequence Diagrams (`sequenceDiagram`)**: Best for illustrating interactions between components over time.\n    *   **Use Cases**: Bus protocols (I2C/SPI transactions showing master/slave communication), DMA buffer handoffs (CPU -> DMA -> Peripheral), FFI call sequences (Rust -> C -> Rust), and client-server interactions in networking stacks.\n    *   **Template**: `sequenceDiagram; participant A; participant B; A->>+B: Request; B-->>-A: Response;`\n\n3.  **State Diagrams (`stateDiagram-v2`)**: The definitive choice for modeling state machines and ensuring all states and transitions are visualized.\n    *   **Use Cases**: Typestate patterns for drivers (e.g., `Pin<Analog>` -> `Pin<Input>`), peripheral state machines (e.g., `Motor<Idle>` -> `Motor<Moving>`), power management states (Run -> Sleep -> Stop -> Standby), and error handling flows.\n    *   **Template**: `stateDiagram-v2; [*] --> State1; State1 --> State2: Event A; State2 --> State1: Event B; State2 --> [*]: End Event;`\n\n4.  **Class Diagrams (`classDiagram`)**: Used to show the static structure and relationships between types, traits, and modules.\n    *   **Use Cases**: The `embedded-hal` architecture (Application -> Driver -> HAL Trait -> HAL Impl), RTIC application structure (showing tasks and shared resources), and the composition of complex driver structs.\n    *   **Template**: `classDiagram; class Driver { +I2cBus i2c; +new() Driver; +read_sensor() u16; } class HalImpl { <<I2c>> +write() Result; +read() Result; } Driver --|> HalImpl: uses;`\n\n**Conventions and Best Practices**:\n*   **Clarity**: Use descriptive node and actor names. Keep diagrams focused on a single concept.\n*   **Consistency**: Apply a consistent theme and color scheme. For example, use red for `unsafe` blocks, yellow for hardware interaction, and green for safe, high-level abstractions.\n*   **Legends**: For complex diagrams, include a legend to explain color coding or special symbols representing concepts like safety, timing, or portability.\n*   **Integration**: Embed diagrams directly alongside the code and explanations they illustrate to minimize cognitive load and prevent the split-attention effect."
    },
    "foundational_concepts_and_project_setup": "Writing idiomatic Rust in a `no_std` environment begins with understanding the core differences from a standard, OS-hosted environment. The primary distinction is the absence of the standard library (`std`), which is replaced by the `core` crate. The `core` crate is a platform-agnostic subset of `std`, providing fundamental language primitives like floats, strings, and slices, along with processor-specific features like atomic operations, but it omits any API that requires OS integration, such as file I/O, networking, or default memory allocation. For applications needing dynamic memory, the `alloc` crate can be optionally included, but it requires the developer to provide a global memory allocator implementation.\n\nSetting up a bare-metal project requires several key crate-level attributes. The `#![no_std]` attribute is mandatory and signals the compiler to not link against the `std` library. Since the standard runtime, which normally calls the `main` function, is absent, the `#![no_main]` attribute is also required to inform the compiler that a custom entry point will be provided. This custom entry point is typically managed by a runtime crate specific to the target architecture. For ARM Cortex-M microcontrollers, the `cortex-m-rt` crate is standard; it provides startup code and an `#[entry]` attribute macro to designate a function as the program's entry point (e.g., `#[cortex_m_rt::entry] fn main() -> ! { ... }`). This function is invoked by the reset handler after essential initializations, such as setting up RAM. Similar crates like `riscv-rt` exist for other architectures like RISC-V.\n\nAnother non-negotiable requirement in a `no_std` environment is defining a panic handler. When a program panics, the `std` library provides default behavior (unwinding or aborting), but without it, this behavior must be explicitly defined. This is done by providing a single function with the `#[panic_handler]` attribute and the signature `fn(&core::panic::PanicInfo) -> !`. It is common practice to use pre-built panic handler crates. For debugging, `panic-semihosting` prints the panic message to a host debugger's console, while `panic-probe` integrates with the `defmt` logging framework to provide a detailed backtrace. For production, `panic-halt` is often used, which simply puts the processor into an infinite loop, freezing the system state for post-mortem analysis, while `panic-abort` issues an abort instruction for the smallest possible binary size.",
    "memory_management_and_allocators": {
      "stack_memory_management": "In `no_std` systems, stack memory management is of paramount importance as stack overflow is a common and critical failure mode. The stack is typically located in RAM and, on most embedded architectures, grows downwards from a higher memory address to a lower one. The initial stack pointer is set to the highest address of the RAM region designated for the stack. For Cortex-M systems using `cortex-m-rt`, this is handled automatically by the startup code, which reads the initial stack pointer value from the vector table. The linker script (`memory.x`) defines the RAM region, and the startup code places the initial stack pointer at the end of this region (`ORIGIN(RAM) + LENGTH(RAM)`). Static analysis is the primary method for ensuring stack safety. The `cargo-call-stack` tool can analyze the compiled binary to calculate the worst-case stack usage (WCSU) by building a call graph and summing the stack sizes of functions along the deepest path. This analysis must account for all entry points, including the main function and all interrupt handlers. For runtime verification, techniques like stack painting (filling the stack region with a known value at startup and later checking how much has been overwritten) can determine the stack's high-water mark. Furthermore, on processors equipped with a Memory Protection Unit (MPU), a guard region can be configured just below the stack's limit to trigger a hardware fault upon overflow, providing a robust safety mechanism.",
      "memory_allocator_comparison": "By default, a `no_std` environment has no heap, and all data must be allocated on the stack or in static memory. To enable dynamic memory allocation for collections like `Vec` and `Box`, the `alloc` crate must be included, and two components must be provided by the developer: a global allocator and an allocation error handler. The global allocator is a static instance of a type that implements the `GlobalAlloc` trait, marked with the `#[global_allocator]` attribute. The `#[alloc_error_handler]` attribute must be applied to a function that defines behavior for out-of-memory (OOM) errors, which typically involves panicking or aborting. Several allocator implementations are available as crates, each with different trade-offs. `linked_list_allocator` is a simple, general-purpose allocator. Buddy system allocators (`buddy_system_allocator`) are efficient at reducing memory fragmentation. Bump allocators (`bumpalo`) are extremely fast for allocation but typically do not support individual deallocations. Slab allocators (`slaballoc`) are highly efficient for allocating many objects of the same size. For many constrained or real-time systems, dynamic allocation is avoided entirely to ensure deterministic performance and prevent runtime failures. In these cases, the idiomatic solution is to use fixed-capacity collections from crates like `heapless` or `arrayvec`. These collections are backed by statically-sized arrays, providing `Vec`-like and `String`-like APIs without any heap usage, making memory consumption completely predictable at compile time."
    },
    "error_handling_and_observability": "Idiomatic error handling in `no_std` Rust avoids panics for recoverable errors, instead leveraging the type system to signal failure. The primary tools for this are the `Result<T, E>` and `Option<T>` enums from the `core` library. `Result` is used for operations that can fail, returning `Ok(T)` on success and `Err(E)` on failure. Instead of using a complex, heap-allocated `Error` trait object as in `std`, `no_std` applications define custom, lightweight error enums that are specific to a peripheral or operation (e.g., `enum I2cError { Nack, BusFault }`). This approach is memory-efficient and provides clear, machine-readable error types. For I/O operations that may need to wait for hardware, the `nb` crate provides a standard pattern for non-blocking APIs. A function that is not yet ready to complete returns `Err(nb::Error::WouldBlock)`, signaling to the caller that it should retry the operation later, rather than blocking the entire system. This is crucial for building responsive, cooperative multitasking systems.\n\nObservability—getting information out of a constrained device—is critical for debugging. The most advanced and efficient logging framework for this is `defmt` (deferred formatting). It achieves high performance by sending log arguments to the host in a compact binary format and interning log strings at compile time. The final human-readable string is constructed on the host computer, saving significant CPU cycles and transmission bandwidth on the microcontroller. The `defmt` ecosystem includes transport crates like `defmt-rtt` and a host-side decoder. Other options include `rtt-target` for a simpler implementation of the RTT protocol and `panic-semihosting` for printing panic messages to a debugger console, though semihosting is generally too slow for real-time logging on physical hardware.",
    "concurrency_atomics_and_synchronization": "In `no_std` Rust, concurrency is managed not through OS threads but through hardware interrupts and atomic operations. The foundation for this is the `core::sync::atomic` module, which provides atomic types like `AtomicBool`, `AtomicUsize`, and integer types of various widths. These types are crucial for building synchronization primitives as they guarantee that operations like reads and writes are indivisible. Each atomic operation requires specifying a memory `Ordering` (`Relaxed`, `Acquire`, `Release`, `AcqRel`, `SeqCst`) to control how memory operations are ordered relative to the atomic operation, which is essential for preventing data races and ensuring visibility between different execution contexts (e.g., main loop and an ISR). For platforms lacking native hardware support for certain atomics (e.g., 64-bit atomics on 32-bit platforms, or any atomics on RISC-V without the 'A' extension), the `portable-atomic` crate is essential. It provides polyfills, emulating Compare-And-Swap (CAS) operations by either disabling interrupts (on single-core systems) or using the `critical-section` crate for a sound, multi-core safe implementation. For managing shared mutable state, the idiomatic and safest approach is to use a critical section, which typically involves disabling interrupts to prevent preemption. The `critical-section` crate offers a portable abstraction for this, allowing libraries to be written without depending on a specific hardware implementation. Data is then wrapped in a `critical_section::Mutex`, often combined with `core::cell::RefCell` for non-`Copy` types, to ensure access is only possible within the critical section. This pattern is strongly preferred over spinlocks (from crates like `spin`), which are susceptible to priority inversion in real-time systems. The RTIC (Real-Time Interrupt-driven Concurrency) framework provides a more advanced solution by implementing the Immediate Ceiling Priority Protocol (ICPP), which statically prevents priority inversion and deadlocks. For communication between contexts, lock-free data structures are paramount. The `heapless` crate provides statically allocated, lock-free queues like `spsc::Queue` (single-producer, single-consumer) and `mpmc::MpMcQueue` (multiple-producer, multiple-consumer), while `bbqueue` offers a specialized SPSC queue optimized for DMA transfers by providing contiguous memory blocks.",
    "interrupts_and_exception_handling": "Interrupt and exception handling in `no_std` Rust is managed through architecture-specific runtime crates and attributes. For ARM Cortex-M, the `cortex-m-rt` crate provides the `#[interrupt]` attribute for device-specific peripheral interrupts and `#[exception]` for core exceptions like `HardFault` and `SysTick`. Similarly, for RISC-V, the `riscv-rt` crate offers attributes like `#[riscv_rt::external_interrupt]`. These attributes ensure the handler function has the correct signature and is correctly placed in the vector table. Configuration of the interrupt controllers is done via memory-mapped registers, abstracted by crates like `cortex-m` for the NVIC (Nested Vectored Interrupt Controller) and HALs for the RISC-V PLIC (Platform-Level Interrupt Controller). This includes enabling/disabling interrupts and setting priorities, noting that Cortex-M uses lower numbers for higher priority, while RISC-V uses higher numbers. Safe access to data shared between ISRs and the main application is critical to prevent race conditions. The primary pattern is to use a critical section, typically implemented by disabling interrupts via `critical_section::with` or `cortex_m::interrupt::free`. Shared data is wrapped in a mutex like `critical_section::Mutex<RefCell<T>>`, which enforces that access can only occur within this protected block. For simpler types, `core::sync::atomic` types provide a lock-free alternative. A key principle for responsive systems is to keep ISRs as short as possible. Complex processing is deferred to the main loop by using lock-free, single-producer, single-consumer (SPSC) queues, with `heapless::spsc::Queue` being the idiomatic choice. The ISR acts as the producer, enqueuing an event, while the main loop is the consumer, dequeuing and processing it. For debugging, exception handlers for `HardFault` (Cortex-M) or a general `ExceptionHandler` (RISC-V) can accept a `&ExceptionFrame` or `&TrapFrame` argument, respectively. This provides a snapshot of the CPU registers at the time of the fault, which is invaluable for analysis. Testing this logic can be done effectively using emulators like QEMU, which allows for setting breakpoints in ISRs and simulating interrupt dispatch.",
    "memory_mapped_io_and_register_abstraction": "Interacting with hardware via Memory-Mapped I/O (MMIO) in `no_std` Rust requires careful handling to prevent incorrect compiler optimizations and ensure safety. The foundation of MMIO is volatile access, using the `unsafe` functions `core::ptr::read_volatile` and `core::ptr::write_volatile`. These functions guarantee that the memory access is not reordered relative to other volatile operations and is not optimized away by the compiler. However, it is critical to understand that `volatile` does not provide atomicity or prevent data races in concurrent contexts; for that, proper synchronization like atomics or critical sections is required. Writing raw volatile operations is error-prone, so the idiomatic approach is to encapsulate them in safe, zero-cost abstractions. The most common pattern is using a Peripheral Access Crate (PAC) generated by `svd2rust`. These PACs provide a type-safe API for each peripheral register, with methods like `read()`, `write()`, and `modify()`. The `modify()` method is particularly important as it performs an atomic read-modify-write operation, ensuring that individual bitfields can be changed without corrupting other bits in the same register. The underlying mechanism that allows these safe wrappers around mutable hardware state is interior mutability, provided by types in `core::cell`. `UnsafeCell<T>` is the primitive that bypasses the compiler's aliasing rules, allowing mutation through a shared reference, which is essential for MMIO. A powerful pattern for building higher-level drivers on top of PACs is typestate programming. This pattern encodes the state of a peripheral into its type, making illegal sequences of operations a compile-time error. For example, a GPIO pin can be represented by distinct types like `Pin<Input>` or `Pin<Output>`, preventing a call to an output-only method on a pin configured as an input. This provides zero-cost, compile-time guarantees about hardware state, preventing entire classes of bugs. For high-throughput peripherals, DMA-safe buffer management is crucial, involving ownership models that ensure buffers are not moved or accessed by the CPU during a transfer and handling cache coherency on advanced cores.",
    "driver_development_with_embedded_hal": "The `embedded-hal` project provides a standardized set of traits that decouple peripheral drivers from the specific hardware they run on, enabling platform-agnostic development. The stabilized v1.0 release provides core APIs for GPIO, SPI, I2C, and PWM. The ecosystem is designed to be execution-model agnostic, offering separate crates for different programming paradigms. The main `embedded-hal` crate contains blocking traits, where an operation like `spi::write` halts execution until the transfer is complete. For cooperative multitasking, `embedded-hal-nb` provides non-blocking, polling-based traits where operations return `Err(nb::Error::WouldBlock)` if the peripheral is not ready. For modern, highly efficient concurrent applications, `embedded-hal-async` provides traits compatible with Rust's `async/await` syntax, allowing tasks to yield control to an executor while waiting for hardware operations, often backed by DMA or interrupts. Serial communication (UART) has been moved to the `embedded-io` crate, which treats serial ports as generic byte-oriented streams. A key idiomatic pattern is typestate programming, where a peripheral's state (e.g., a GPIO pin configured as `Input` or `Output`) is encoded in its type, making invalid operations a compile-time error. For shared buses, the `embedded-hal-bus` crate provides mutex-based implementations to safely manage access from multiple drivers. Error handling is standardized via an `Error` trait with an `ErrorKind` enum, allowing generic drivers to understand the category of an error without knowing platform-specific details. Timeouts and delays are handled using crates like `embedded-time` and `fugit`, which provide hardware-agnostic `Duration` and `Clock` abstractions.",
    "toolchain_linking_and_memory_layout": "The build and linking process for a `no_std` application is fundamentally controlled by a linker script, conventionally named `memory.x`. This script defines the target device's memory map, specifying the origin and length of memory regions like `FLASH` (for program code and read-only data) and `RAM` (for read-write data, the stack, and the heap). Runtime crates like `cortex-m-rt` and `riscv-rt` use this file to correctly place different sections of the compiled binary. For instance, the `.text` section containing executable code is placed in `FLASH`, while the `.data` (initialized static variables) and `.bss` (zero-initialized static variables) sections are placed in `RAM`.\n\nRust provides the `#[link_section = \".section_name\"]` attribute for fine-grained control over data placement. This is essential for systems programming, as it allows developers to place specific data structures, such as a vector table or DMA buffers, at precise memory addresses required by the hardware. This attribute is almost always paired with `#[no_mangle]` to prevent the compiler from altering the symbol's name.\n\nThe startup code, provided by runtime crates like `cortex-m-rt`, is the first piece of user-provided code to execute after a device reset. It performs critical initializations before the user's main function is called. Its responsibilities include copying the initial values for the `.data` section from `FLASH` to `RAM`, zeroing out the `.bss` section in `RAM`, and setting up the initial stack pointer. After these setup tasks are complete, it jumps to the application's entry point, which is the function marked with the `#[entry]` attribute.",
    "testing_simulation_and_debugging": "A multi-layered testing strategy is idiomatic for `no_std` Rust to ensure robustness from unit logic to hardware interaction. This approach involves three primary layers. The first is **Host-Side Testing**, which is the fastest and most convenient layer for validating logic that does not depend on specific hardware. This is achieved by conditionally enabling the `std` library for test builds using a feature flag in `Cargo.toml`. This allows the use of standard testing tools and libraries. To test hardware-dependent logic, the `embedded-hal-mock` crate is used to create mock implementations of `embedded-hal` traits. Tests define a sequence of expected hardware transactions (e.g., an I2C write followed by a read), and the mock object verifies that the driver performs these exact operations, enabling 'golden tests' for register sequences. The second layer is **Emulation-Based Testing**, which uses emulators like QEMU to run the compiled firmware on a simulated target architecture (e.g., ARM Cortex-M or RISC-V) without physical hardware. This is configured by setting QEMU as a `runner` in `.cargo/config.toml` and is crucial for testing code that is closer to the metal, including interrupt handlers and basic peripheral interactions. Semihosting is often enabled in QEMU to allow the emulated target to print debug information to the host console. The third and most definitive layer is **Hardware-Based Testing**. This involves running tests directly on the target microcontroller. The `probe-rs` ecosystem is the modern, Rust-native toolchain for this. `cargo-flash` is used for simple flashing, while `cargo-embed` provides a comprehensive workflow that includes flashing, opening a terminal for logging, and starting a GDB server for interactive debugging. For logging, the `defmt` framework is the idiomatic choice due to its high efficiency; it sends compressed log data over RTT (Real-Time Transfer) to the host, where it is decoded, minimizing CPU overhead and binary size on the target. For automated on-target testing, especially in CI/CD pipelines, the `defmt-test` crate provides a test harness that runs tests on the MCU and reports results back to the host via `defmt` logs. Advanced techniques include programmatic fault injection and ISR simulation by using a debugger (connected to QEMU or a `probe-rs` GDB server) to directly manipulate the memory-mapped registers of the interrupt controller (e.g., NVIC) to trigger specific interrupts or exceptions.",
    "foreign_function_interface_integration": "Integrating C and assembly code into a `no_std` Rust project is managed through Rust's Foreign Function Interface (FFI) capabilities and build system. The process begins with declaring C interfaces using `extern \"C\"` blocks for functions and `#[repr(C)]` for structs to ensure a compatible memory layout and Application Binary Interface (ABI). To call a Rust function from C, it must be marked with `#[no_mangle]` to prevent name mangling. The `cc` crate is the idiomatic tool for compiling C, C++, or assembly files from a `build.rs` script. The script configures the build, specifies source files, and instructs Cargo to link the resulting static library. For automating the creation of Rust bindings from C header files, the `bindgen` tool is used. In a `no_std` context, `bindgen` must be configured with the `--use-core` flag and a specified C-types prefix, typically `\"cty\"` or `\"::core::ffi\"`. A critical aspect of FFI in systems programming is managing Direct Memory Access (DMA) buffers shared with C code or peripherals. This requires careful handling of memory safety, including ensuring cache coherency on advanced CPUs by manually cleaning or invalidating the cache before and after DMA transfers. Buffer lifetimes are also crucial; they must remain valid for the entire asynchronous DMA operation, often necessitating a `'static` lifetime. Error handling across the FFI boundary must be managed explicitly by returning error codes, as panics cannot safely unwind across a C ABI boundary by default.",
    "inline_assembly_and_architecture_intrinsics": "For systems programming tasks that require direct control over the CPU, `no_std` Rust provides two primary mechanisms: the `asm!` macro for inline assembly and the `core::arch` module for vendor-specific intrinsics. Both are powerful but require careful use. The `asm!` macro, stable on architectures like ARM, AArch64, RISC-V, and x86_64, allows embedding handwritten assembly code. All `asm!` invocations must be wrapped in an `unsafe` block, as the compiler cannot verify the correctness of the assembly. The programmer is responsible for ensuring the code does not violate memory safety or calling conventions. The macro's syntax allows passing Rust values to and from the assembly using operands like `in(<reg>)`, `out(<reg>)`, and `const`, and requires specifying any modified (clobbered) registers to the compiler. Common use cases in `no_std` include executing critical instructions like `wfi` (Wait For Interrupt), `cpsid` (Change Processor State, Disable Interrupts), or accessing Control and Status Registers (CSRs) on RISC-V. A safer and often more convenient alternative is the `core::arch` module, which provides Rust functions that map directly to single machine instructions (intrinsics). Examples include `_mm_pause()` on x86 for spin-wait loops, and memory barrier instructions like `__dmb()` (Data Memory Barrier) and `__dsb()` (Data Synchronization Barrier) on ARM. For synchronization, `core::sync::atomic::fence` creates a hardware memory barrier, while `compiler_fence` only prevents compiler reordering. While these tools are essential for certain low-level tasks, the most idiomatic approach is to avoid using them directly in application code. Instead, developers should rely on higher-level, safer abstractions provided by Hardware Abstraction Layer (HAL) and core architecture crates like `cortex-m`, `riscv`, and `x86_64`. These crates encapsulate the `unsafe` assembly and intrinsics within safe functions, such as `cortex_m::asm::wfi()` or `riscv::register::mstatus::read()`, providing the necessary functionality without exposing the application developer to the complexities and risks of raw assembly.",
    "portability_and_conditional_compilation": "Writing a single `no_std` Rust codebase that supports multiple MCUs and architectures relies on two core strategies: conditional compilation and trait-based abstraction. Conditional compilation is primarily achieved with the `#[cfg]` attribute, which includes or excludes code based on configuration predicates. Key predicates for portability include `target_arch` (e.g., `\"arm\"`, `\"riscv32\"`), `target_os` (e.g., `\"none\"`), `target_pointer_width`, `target_endian`, and `target_has_atomic` (to check for hardware support for atomic operations). Custom features defined in `Cargo.toml` (e.g., `#[cfg(feature = \"stm32f407\")]`) are used to select MCU-specific modules or configurations. The second strategy is trait-driven design, centered around the `embedded-hal` ecosystem. By writing drivers against abstract traits like `embedded_hal::i2c::I2c`, the code becomes portable to any MCU that has a Hardware Abstraction Layer (HAL) crate implementing these traits. This decouples the application logic from the low-level hardware details. To ensure portability is maintained, robust Continuous Integration (CI) is essential. CI pipelines, such as those in GitHub Actions, use build matrices to automatically compile and test the codebase against various target triples (e.g., `thumbv7em-none-eabihf`) and feature flag combinations. Testing can be performed in emulators like QEMU or on physical hardware using tools like `probe-rs` for Hardware-in-the-Loop (HIL) validation.",
    "persistent_storage_on_flash_and_eeprom": "Persistent storage in `no_std` Rust environments is managed through specialized abstractions and filesystems designed for the unique constraints of flash and EEPROM memory. The foundational abstraction layer is the `embedded-storage` crate, which provides traits like `NorFlash` to create a hardware-agnostic interface for reading, writing, and erasing non-volatile memory. For more complex needs, the `littlefs2` crate provides a Rust implementation of LittleFS, a filesystem designed for microcontrollers. LittleFS is notable for its power-loss resilience, achieved through copy-on-write (COW) guarantees for all file operations, and its dynamic wear-leveling, which distributes erasures evenly across all flash blocks to maximize the device's lifespan. For simpler storage, key-value stores like `sequential-storage` and `tickv` offer `no_std` solutions with built-in wear-leveling and data integrity checks using CRCs. Core design patterns for ensuring data safety are critical. Power-fail safety is achieved through atomic update mechanisms like COW, log-structured/append-only writes, or double-buffering, where data is written to an inactive page before it is marked as active. Wear-leveling techniques are either dynamic (actively choosing the least-worn block) or static (writing sequentially through pages in a circular fashion). Data integrity is maintained by calculating and storing checksums (e.g., CRC32) alongside the data, which is verified on read.",
    "networking_stacks_and_zero_copy_patterns": "Networking in a `no_std` Rust environment is centered around lightweight TCP/IP stacks and zero-copy data handling patterns to maximize performance and minimize memory usage. The leading stack is `smoltcp`, an event-driven TCP/IP implementation designed for bare-metal systems that does not require a heap allocator (`alloc`) by default. It interacts with network hardware through a `phy::Device` trait, which must be implemented by a specific Ethernet controller driver. For asynchronous applications, `embassy-net` builds on `smoltcp` to provide a high-level async networking stack that integrates with the Embassy framework. A core principle is zero-copy packet parsing, which avoids memory allocations by interpreting network data directly in the receive buffers. Crates like `etherparse` and `zero-packet` provide safe, `no_std` APIs for parsing and building Ethernet, IP, TCP, and UDP headers in-place. For high-performance networking, Direct Memory Access (DMA) is used to offload packet transfers from the CPU. This involves a carefully managed buffer ownership model, typically using a ring of DMA descriptors. Each descriptor points to a buffer and has an `OWN` bit to signal whether the buffer is owned by the hardware (DMA) or the software (CPU), preventing data races and ensuring safe, efficient data transfer for both receive (RX) and transmit (TX) paths.",
    "bare_metal_os_kernel_development_basics": "Developing an OS kernel in `no_std` Rust involves taking full control of the hardware from the earliest stages of execution. On the x86_64 architecture, the process begins with the **bootloader handoff**. For legacy BIOS systems, the Multiboot2 standard is common; the bootloader loads the kernel and passes control in 32-bit protected mode, providing a pointer to an information structure containing a memory map. For modern systems, UEFI is used; the kernel is launched as a UEFI application in 64-bit long mode with paging already enabled. The kernel must then take control from the UEFI boot services. The next critical step is setting up segmentation and interrupt handling. A **Global Descriptor Table (GDT)** must be created to define kernel/user privilege levels and to load a **Task State Segment (TSS)**. The TSS is vital because it contains the **Interrupt Stack Table (IST)**, which provides pointers to known-good stacks for handling critical exceptions like double faults, preventing a system-crashing triple fault. An **Interrupt Descriptor Table (IDT)** must also be initialized to map interrupt vectors to handler functions. This involves disabling the legacy 8259 PIC and configuring the modern APIC for interrupt routing. **Paging** is mandatory in x86_64 long mode. The kernel must manage the 4-level page table structure (PML4, PDPT, PD, PT) to translate virtual addresses to physical addresses. The bootloader typically sets up an initial identity map, but the kernel is responsible for all subsequent modifications, including mapping its own code and data into the higher half of the virtual address space and managing the Translation Lookside Buffer (TLB) to ensure changes are visible to the CPU. Finally, the kernel must implement its own **memory management**. This starts with a **physical frame allocator**, often a bitmap allocator, which tracks and dispenses free 4KiB frames of physical memory obtained from the bootloader's memory map. To use heap-allocated collections from the `alloc` crate (like `Box` or `Vec`), a **heap allocator** must be implemented on top of the frame allocator. A slab allocator is a common choice for kernels as it is efficient for allocating many small, fixed-size objects and helps reduce memory fragmentation.",
    "safety_verification_and_formal_methods": "Advanced safety and verification in `no_std` Rust extend beyond the compiler's standard checks, focusing on managing `unsafe` code and formally proving correctness. The cornerstone of this approach is the **encapsulation of `unsafe` code**. The idiomatic pattern is to confine `unsafe` blocks within private functions or modules and expose their functionality through a safe, public API. The module boundary becomes a trust boundary; the module's author is responsible for upholding the necessary invariants to ensure the `unsafe` operations do not cause Undefined Behavior (UB), while the module's users can rely on the safe API. A powerful technique for enforcing correctness at compile time is the **typestate pattern**. This pattern encodes the state of a component (like a peripheral driver) into its type, making invalid state transitions a compile-time error. For example, a GPIO pin can be represented by distinct types like `Pin<Input>` or `Pin<Output>`, preventing output-only methods from being called on an input pin. This zero-cost abstraction is widely used in embedded HALs to create robust state machines for peripheral initialization and configuration. For deeper verification, the ecosystem provides several **lightweight formal methods tools**. **Miri**, an interpreter for Rust's intermediate representation, can run a crate's test suite on the host and detect many forms of UB, such as memory access violations and aliasing rule violations. This is an invaluable tool for validating the soundness of `unsafe` code. For formal proofs, **Kani** is a bounded model checker that can verify memory safety and user-specified assertions in `no_std` code by symbolically exploring program execution paths. It has been successfully used on critical projects like the Firecracker microVM, demonstrating its applicability to real-world systems code. These tools, combined with disciplined `unsafe` encapsulation and typestate patterns, allow developers to build highly reliable `no_std` systems with a strong degree of proven correctness.",
    "performance_optimization_and_benchmarking": "Optimizing and measuring performance, determinism, and code size in `no_std` Rust requires direct hardware interaction and careful build configuration. For **cycle-accurate benchmarking**, standard timing libraries are unavailable, so developers must use hardware performance counters. On ARM Cortex-M processors, the DWT (Data Watchpoint and Trace) unit's 32-bit `CYCCNT` register is used to count CPU cycles. On RISC-V, the 64-bit `mcycle` Control and Status Register (CSR) serves the same purpose. These counters provide precise, low-overhead measurements for profiling critical code paths. **Performance and code-size optimization** are primarily controlled via `Cargo.toml` build profiles. Key settings for release builds include: `opt-level = 'z'` or `'s'` to optimize aggressively for size; `lto = true` to enable Link Time Optimization, which performs whole-program analysis to inline functions across crates and eliminate dead code; `codegen-units = 1` to allow for maximum cross-crate optimization at the cost of slower compilation; and `panic = \"abort\"` to remove stack unwinding code, significantly reducing binary size. For **determinism and stack safety**, static analysis is crucial. A stack overflow is a critical failure mode in embedded systems. The `cargo-call-stack` tool performs static analysis by parsing the program's call graph and using stack size information emitted by the compiler (`-Z emit-stack-sizes`) to calculate the worst-case stack usage for each task and interrupt handler. This allows developers to prove that their application will not overflow the available stack memory, a critical requirement for reliable and deterministic systems.",
    "real_world_design_case_studies": "Analyzing alternative designs for common subsystems reveals the core trade-offs in `no_std` systems programming. A prime example is a **UART (Serial) Driver**. A **polling-based** design is the simplest to implement: the CPU sits in a tight loop, continuously checking a status register to see if a byte has been received or if the transmitter is ready for the next byte. While easy to reason about, this approach is highly inefficient, consuming 100% of the CPU's time while waiting, which is unacceptable for most applications. A more efficient alternative is an **interrupt-driven** design. The UART peripheral is configured to trigger an interrupt when a byte is received or a transmission is complete. The CPU is free to perform other tasks or enter a low-power sleep state, only waking to execute a brief Interrupt Service Routine (ISR) to handle the event. This drastically reduces CPU usage and improves system responsiveness. However, high-frequency interrupts can still introduce significant context-switching overhead. The most performant approach for high-throughput communication is a **DMA-based** design. A Direct Memory Access (DMA) controller is configured to transfer entire blocks of data between a memory buffer and the UART peripheral without any CPU intervention. The CPU simply initiates the transfer and is notified by a single interrupt only when the entire block is complete. This offers the lowest CPU usage but is the most complex to set up and can introduce higher latency for the first byte, as the system may wait for a full buffer before processing. These same trade-offs between implementation complexity, latency, and CPU usage apply to other subsystems like **SPI drivers** and **persistent storage**, where one might compare a simple blocking API against a complex, power-fail-safe, log-structured design like LittleFS."
  },
  "outputBasis": [
    {
      "field": "driver_development_with_embedded_hal",
      "citations": [
        {
          "title": "A Hardware Abstraction Layer (HAL) for embedded systems",
          "url": "https://github.com/rust-embedded/embedded-hal",
          "excerpts": [
            "embedded-hal v1.0 is now released! Check out the announcement blog post, the API documentation and the migration guide. Scope. embedded-hal serves as a ...",
            "For a non-exhaustive list of embedded-hal implementations and driver crates check the awesome-embedded-rust list. You may be able to find even more HAL ...",
            "The main `embedded-hal` project is not tied to a specific execution model like blocking or non-blocking.",
            "Core traits, blocking version",
            "Crates. The main embedded-hal project is not tied to a specific execution model like blocking or non-blocking.",
            "embedded-hal` serves as a foundation for building an ecosystem of platform-agnostic drivers. (driver meaning library crates that let a target platform interface an external device like a digital\nsensor or a wireless transceiver). The advantage of this system is that by writing the driver as a generic library on top\nof `embedded-hal` driver authors can support any number of target\nplatforms (e.g. Cortex-M microcontrollers, AVR microcontrollers, embedded Linux, etc.). The advantage for application developers is that by adopting `embedded-hal` they can unlock all\nthese drivers for their platform",
            "embedded-hal` serves as a foundation for building an ecosystem of platform-agnostic drivers. (driver meaning library crates that let a target platform interface an external device like a digital\nsensor or a wireless transceiver). The advantage of this system is that by writing the driver as a generic library on top\nof `embedded-hal` driver authors can support any number of target\nplatforms (e.g. Cortex-M microcontrollers, AVR microcontrollers, embedded Linux, etc.). The advantage for application developers is that by adopting `embedded-hal` they can unlock all\nthese drivers for their platform"
          ]
        },
        {
          "title": "embedded-hal v1.0 now released!",
          "url": "https://blog.rust-embedded.org/embedded-hal-v1/",
          "excerpts": [
            "The Rust Embedded Working Group is proud to announce the release of `embedded-hal` version 1.0 together with the\ncompanion crates `embedded-hal-bus`, `embedded-hal-async` and `embedded-hal-nb`. Check out the [repository](https://github.com/rust-embedded/embedded-hal), the [API documentation](https://github.com/rust-embedded/embedded-hal) and the [migration guide](https://github.com/rust-embedded/embedded-hal/blob/master/docs/migrating-from-0.2-to-1.0.md). The `embedded-hal` crates provide traits (interfaces) for using peripherals commonly available in microcontrollers\nsuch as GPIO, UART, SPI or I2C. They allow writing drivers (for sensors, displays, actuators, network adapters, etc.) in\na generic way, so they work on any microcontroller with an `embedded-hal` implementation without\nmodifying them. It's a central piece of the Embedded Rust ecosystem, ensuring interoperability throughout. The 1.0 release has been in the works since 2020. Now that it's out, we consider all\ntraits in it to be *stable*.",
            "The `embedded-hal` project also hosts the `embedded-io` crates. They provide traits for byte-oriented I/O streams. Since serial\nports (UART) are essentially byte streams, the serial-specific traits in `embedded-hal` have been removed in favor of `embedded-io`. `embedded-io` has not reached 1.0 yet, but we expect that to happen in 2024.",
            "The [`SpiDevice`](https://docs.rs/embedded-hal/1.0.0/embedded_hal/spi/index.html) trait now allows sharing a SPI bus between multiple devices, each selected with its own CS pin. The design allows for unrelated drivers to talk to different devices in the same bus without conflicts and without being aware of each other. The trait is agnostic about the kind of mutex/locking mechanism. The [`embedded-hal-bus`](https://docs.rs/embedded-hal-bus/0.1.0/embedded_hal_bus/spi/index.html) crate provides implementations for commonly used mutexes, but it is possible to write your own for e.g. the mutex of your favourite RTOS.",
            "Error handling",
            "Error handling\n--------------",
            "Generic drivers can now inspect errors, thanks to them being required to implement an `Error` trait\nthat allows querying the error \"kind\" out of a pre-selected set. HAL implementations can still use custom error types,\nand map errors that don't fit in these categories to the `Other` kind.\nAll error types are also required to implement `Debug`, so `.unwrap()` and similar are now always available in generic drivers.",
            "Jan 9, 2024 — The embedded-hal crates provide traits (interfaces) for using peripherals commonly available in microcontrollers such as GPIO, UART, SPI or I2C."
          ]
        },
        {
          "title": "embedded-hal - Comprehensive Rust - Google",
          "url": "https://google.github.io/comprehensive-rust/bare-metal/microcontrollers/embedded-hal.html",
          "excerpts": [
            "The embedded-hal crate provides a number of traits covering common microcontroller peripherals: GPIO; PWM; Delay timers; I2C and SPI buses and devices. Similar ...",
            "embedded-hal) crate provides a number of traits covering common\nmicrocontroller peripherals:\n\n* GPIO\n* PWM\n* Delay timers\n* I2C and SPI buses and devices\n\nSimilar traits for byte streams (e.g. UARTs), CAN buses and RNGs are broken out\ninto [`embedded-io`](https://crates.io/crates/embedded-io), [`embedded-can`](https://crates.io/crates/embedded-can) and [`rand_core`](https://crates.io/crates/rand_core) respectively. Other crates then implement [drivers](https://github.com/rust-embedded/awesome-embedded-rust) in terms of these trai"
          ]
        },
        {
          "title": "Docs.rs - embedded-hal i2c",
          "url": "https://docs.rs/embedded-hal/latest/embedded_hal/i2c/index.html",
          "excerpts": [
            "The [`embedded-hal-bus`](https://docs.rs/embedded-hal-bus) crate provides several\nimplementations for sharing I2C buses.",
            "\nSince 7-bit addressing is the mode of the majority of I2C devices,\n[`SevenBitAddress`](type.SevenBitAddress.html \"type embedded_hal::i2c::SevenBitAddress\") has been set as default mode and thus can be omitted if desired.",
            "AddressMode\") exist:\n[`SevenBitAddress`](type.SevenBitAddress.html \"type embedded_hal::i2c::SevenBitAddress\") and [`TenBitAddress`](type.TenBitAddress.html \"type embedded_hal::i2c::TenBitAddress\"). Through this marker types it is possible to implement each address mode for\nthe traits independently in `embedded-hal` implementations and device drivers\ncan depend only on the mode that they support.",
            "t. Additionally, the I2C 10-bit address mode has been developed to be fully\nbackwards compatible with the 7-bit address mode. This allows for a\nsoftware-emulated 10-bit addressing implementation if the address mode\nis not supported by the hardware.",
            "\n\nI2C allows sharing a single bus between many I2C devices. The SDA and SCL lines are\nwired in parallel to all devices. When starting a transfer an ",
            "SDA"
          ]
        }
      ],
      "reasoning": "The fine-grained field describes embedded hardware driver development using the embedded-hal family of traits and its ecosystem. The most relevant excerpts explicitly present the embedded-hal vision, scope, and evolution. For instance, excerpts stating that embedded-hal provides a Hardware Abstraction Layer with core traits for peripherals like GPIO, UART, SPI, and I2C, and that v1.0 stabilizes key APIs, directly support the field's core claim. Other excerpts note the ecosystem's modularity and how non-blocking and async variants (embedded-hal-nb and embedded-hal-async) exist to accommodate different execution models, which aligns with the field's emphasis on execution-model-agnostic design and DMA/interrupt-backed workflows. Additional excerpts mention that serial IO has moved into embedded-io, clarifying how streaming I/O is handled across the ecosystem, which is relevant to the constrained no_std context described in the field. The later excerpts focusing on the v1.0 release and accompanying notes (e.g., the formation of the ecosystem around embedded-hal, its stable traits, and guidance on how to adapt to non-blocking and async regimes) provide concrete grounding for the claimed evolution and stable API surface described in the field. Together, these excerpts directly support the claim that embedded-hal provides a standardized, platform-agnostic set of traits for core peripherals, with a structured ecosystem of related crates to cover different execution models and IO abstractions. They also imply the typestate approach and bus-sharing patterns as part of the broader embedded Rust driver ecosystem, which aligns with the field's mention of typestate and shared bus patterns. Overall, the strongest support comes from explicit statements about (a) embedded-hal core traits and stable v1.0 surface, (b) presence of nb and async variants, (c) the transition of UART to embedded-io, and (d) the ecosystem's tooling and extensions, which together substantiate the detailed field value. ",
      "confidence": "high"
    },
    {
      "field": "learning_curriculum_and_diagram_strategy",
      "citations": [
        {
          "title": "Flowcharts – Basic Syntax",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/flowchart.html",
          "excerpts": [
            "May 22, 2025 — The Mermaid code defines how nodes and edges are made and accommodates different arrow types, multi-directional arrows, and any linking to and ..."
          ]
        },
        {
          "title": "Mermaid Documentation and Mermaid OSS",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/sequenceDiagram.html",
          "excerpts": [
            "Diagram Syntax"
          ]
        },
        {
          "title": "State diagrams",
          "url": "https://mermaid.js.org/syntax/stateDiagram.html",
          "excerpts": [
            "There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it ..."
          ]
        },
        {
          "title": "Sequence examples",
          "url": "https://docs.mermaidchart.com/mermaid/sequence/examples",
          "excerpts": [
            "Sequence diagram example  . sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight ..."
          ]
        },
        {
          "title": "Class diagrams | Mermaid",
          "url": "https://mermaid.js.org/syntax/classDiagram.html",
          "excerpts": [
            "A class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system."
          ]
        },
        {
          "title": "mermaid-js/mermaid: Generation of diagrams like ...",
          "url": "https://github.com/mermaid-js/mermaid",
          "excerpts": [
            "Mermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams."
          ]
        },
        {
          "title": "Examples",
          "url": "https://mermaid.js.org/syntax/examples.html",
          "excerpts": [
            "Examples ​. This page contains a collection of examples of diagrams and charts that can be created through mermaid and its myriad applications."
          ]
        },
        {
          "title": "Mermaid Config Schema",
          "url": "http://mermaid.js.org/config/schema-docs/config.html",
          "excerpts": [
            "Create diagrams and visualizations using text and code."
          ]
        },
        {
          "title": "add boxes / containers in mermaid sequence diagram - Stack Overflow",
          "url": "https://stackoverflow.com/questions/60805200/add-boxes-containers-in-mermaid-sequence-diagram",
          "excerpts": [
            "I'm making sequence diagrams with Mermaid, and I find the loop feature very cool, drawing a labeled rectangle around a loop with this code chunk."
          ]
        },
        {
          "title": "Mermaid | Diagramming and charting tool",
          "url": "https://mermaid.js.org/",
          "excerpts": [
            "Missing: classDiagram annotations"
          ]
        },
        {
          "title": "Using worked examples to support novice learners",
          "url": "https://teachcomputing.org/blog/using-worked-examples-to-support-novice-learners/",
          "excerpts": [
            "Worked examples help novice learners in subjects like Maths and Science by showing problem-solving steps alongside practice problems."
          ]
        },
        {
          "title": "What is the rust core crate??",
          "url": "https://www.reddit.com/r/rust/comments/bpmy21/what_is_the_rust_core_crate/",
          "excerpts": [
            "The reason for both is that std is everything the language provides, but core is the subset of that which doesn't require features from the ..."
          ]
        },
        {
          "title": "What's the difference of the module core and std",
          "url": "https://users.rust-lang.org/t/whats-the-difference-of-the-module-core-and-std/2923",
          "excerpts": [
            "Sep 19, 2015 — Core should be self-contained. std depends on core , and a lot of other stuff, to provide a kind of \"facade\" to the end user."
          ]
        },
        {
          "title": "no global memory allocator found but one is required",
          "url": "https://stackoverflow.com/questions/74012369/no-global-memory-allocator-found-but-one-is-required-link-to-std-or-add-glob",
          "excerpts": [
            "If you link with alloc you need to have a global allocator. That is usually provided by std, but if you omit the std crate then you need to provide it yourself."
          ]
        },
        {
          "title": "cortex_m - Rust",
          "url": "https://docs.rs/cortex-m",
          "excerpts": [
            "Low level access to Cortex-M processors. This crate provides: Access to core peripherals like NVIC, SCB and SysTick. Access to core registers like CONTROL, ..."
          ]
        },
        {
          "title": "Help enabling `no-std` feature in a crate - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/help-enabling-no-std-feature-in-a-crate/61192",
          "excerpts": [
            "I want enable a feature in my crate for compile in a no-std environment, for this in the Cargo.toml I have: [dependencies] num = { version = \"0.4\", default- ..."
          ]
        },
        {
          "title": "Clarify std vs no-std · Issue #148 · esp-rs/book",
          "url": "https://github.com/esp-rs/book/issues/148",
          "excerpts": [
            "Mar 13, 2024 — The book currently says: When You Might Want to Use the Core Library (no_std) Small memory footprint: If your embedded system has limited ..."
          ]
        },
        {
          "title": "Similar items in core and std",
          "url": "https://users.rust-lang.org/t/similar-items-in-core-and-std/60167",
          "excerpts": [
            "May 23, 2021 — As a beginner to Rust, I am a bit confused by same (similar ?) items I find in the core and std libraries. For example there is core::iter::iterator and std:: ..."
          ]
        },
        {
          "title": "cortex-m - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cortex-m",
          "excerpts": [
            "This crate is guaranteed to compile on stable Rust 1.38 and up. It might compile with older versions but that may change in any new patch release."
          ]
        },
        {
          "title": "The Rust Alloc crate documentation",
          "url": "https://doc.rust-lang.org/alloc/",
          "excerpts": [
            "). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead."
          ]
        }
      ],
      "reasoning": "The finegrained field specifies a learning curriculum and a unified Mermaid diagram strategy, so excerpts that directly discuss Mermaid diagram types and their usage are the most supportive. The excerpts that explicitly name Mermaid diagram types (flowchart, sequenceDiagram, stateDiagram-v2, classDiagram) and provide syntax examples or guidance on embedding Mermaid in learning materials are the strongest connectors to the target field value. For example, content that presents Mermaid as a tool for creating flowcharts, sequences, and state diagrams, and that includes example syntax templates, directly substantiates the curriculum's diagrammatic component. Excerpts that extend Mermaid documentation (mermaid config, general usage, and example diagrams) supply concrete diagram components that would populate the curriculum's modules and diagrams. Additional excerpts that discuss broader Rust no_std topics or embedded examples provide context for potential modular exercises, but the direct linkage to the curriculum's Mermaid-driven diagram strategy is strongest when the text explicitly mentions Mermaid diagram types, syntax, or embedding guidance. In sum, the most relevant excerpts offer explicit Mermaid diagram types, syntax, and usage guidance, which are essential to building the 20-module curriculum with integrated diagrams as described in the field value.",
      "confidence": "medium"
    },
    {
      "field": "performance_optimization_and_benchmarking",
      "citations": [
        {
          "title": "Cycle Counting on ARM Cortex-M with DWT",
          "url": "https://mcuoneclipse.com/2017/01/30/cycle-counting-on-arm-cortex-m-with-dwt/",
          "excerpts": [
            "Jan 30, 2017 — If your ARM Cortex-M has a DWT, you can use the cycle counter to measure the cycles spent executing code. That could be used for delay loops or ..."
          ]
        },
        {
          "title": "Measuring time in #[no_std] - cortex-m3 microcontroller",
          "url": "https://users.rust-lang.org/t/measuring-time-in-no-std-cortex-m3-microcontroller/36491",
          "excerpts": [
            "extern crate cortex_m;\n\nuse cortex_m::peripheral::{DWT, Peripherals};\n\nfn main() {\n    {\n        let mut peripherals = Peripherals::take().unwrap();\n        peripherals.DWT.enable_cycle_counter();\n    } // all the peripheral singletons are destroyed here\n\n    // but this method can be called without a DWT instance\n    let cyccnt = DWT::get_cycle_count();\n}"
          ]
        },
        {
          "title": "CYCCNT cycle counter and related timers - Arm Developer",
          "url": "https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/CYCCNT-cycle-counter-and-related-timers?lang=en",
          "excerpts": [
            "The DWT_CTRL. CYCCNTENA bit enables the CYCCNT counter. Software can access the DWT_CYCCNT register to read the current value of CYCCNT, or to set the CYCCNT ..."
          ]
        },
        {
          "title": "STM32 - How to enable DWT Cycle counter - Stack Overflow",
          "url": "https://stackoverflow.com/questions/36378280/stm32-how-to-enable-dwt-cycle-counter",
          "excerpts": [
            "From what I've seen online this should suffice for enabling it: CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; DWT->CYCCNT = 0; DWT->CTRL |= 1;",
            "DWT->CYCCNT = 0;"
          ]
        },
        {
          "title": "Optimizing Rust Compilation: Smaller, Faster, or Both?",
          "url": "https://leapcell.medium.com/optimizing-rust-compilation-smaller-faster-or-both-1cdac7bfd93c",
          "excerpts": [
            "\n[profile.release]  \nopt-level = \"z\"       # Optimize for the smallest code size  \nlto = true            # Enable Link Time Optimization (LTO)  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but reducing binary size  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip = \"debuginfo\"   # Remove debug information\n",
            "\"thin\" : Enable Thin LTO. \"fat\" : Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. You only need to add the following configuration to your `Cargo.toml` file and run:\n\n```\ncargo b --release\n```",
            "Generate a Faster Executable\n============================\n\n```\n[profile.release]  \nopt-level = 3         # Optimize for maximum execution speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling\n```",
            "Balance Between Size and Speed\n==============================\n\n```\n[profile.release]  \nopt-level = \"s\"       # Optimize for size while considering speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip =\n\"symbols\"     # Remove symbol information while retaining necessary debugging info\n```",
            "Description: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "Explanation of Configurations\n=============================\n\nopt-level\n=========\n\nDescription: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable."
          ]
        },
        {
          "title": "Min-Sized Rust",
          "url": "https://github.com/johnthagen/min-sized-rust",
          "excerpts": [
            "Enable Link Time Optimization (LTO)\nBy default, Cargo instructs compilation units to be compiled and optimized in isolation . LTO instructs the linker to optimize at the\nlink stage. This can, for example, remove dead code and often times reduces binary size. Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true",
            "Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true",
            "Build in Release Mode\nBy default,\ncargo build builds the Rust binary in debug mode. Debug mode disables many\noptimizations, which helps debuggers (and IDEs that run them) provide a better debugging\nexperience. Debug binaries can be 30% or more larger than release binaries. To minimize binary size, build in release mode:\n$ cargo build --release"
          ]
        }
      ],
      "reasoning": "To establish cycle-accurate performance profiling in a no_std environment, you count processor cycles using hardware counters. The Cortex-M DWT CYCCNT counter provides a mechanism to count cycles, enabling precise benchmarking of individual functions or code paths without any standard timing libraries. This is particularly valuable in no_std contexts where external timing crates are unavailable. The Cortex-M and RISC-V hardware counter discussions illustrate how to obtain cycle counts and compare execution time across code paths, which is essential for deterministic performance analysis and optimization.\n\nYou can measure time in no_std Cortex-M setups by enabling a cycle counter and reading its value before and after the target code, then computing the difference to obtain the exact cycle count spent executing that code. This explicit, machine-level timing approach replaces standard library timing facilities which are unavailable in freestanding environments. The material also emphasizes that cycle counting is a low-overhead, accurate metric for profiling hot paths in embedded firmware.\n\nOptimization and code-size decisions are driven by Cargo build profiles. Using opt-level settings and LTO directly affects binary size and performance characteristics. For size-sensitive embedded applications, options like opt-level set to ",
      "confidence": "high"
    },
    {
      "field": "concurrency_atomics_and_synchronization",
      "citations": [
        {
          "title": "std::sync::atomic - Rust",
          "url": "https://doc.rust-lang.org/std/sync/atomic/",
          "excerpts": [
            "This module defines atomic versions of a select number of primitive types, including AtomicBool , AtomicIsize , AtomicUsize , AtomicI8 , AtomicU16 , etc.",
            "Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types."
          ]
        },
        {
          "title": "Memory orderings in std::sync::atomic",
          "url": "https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html",
          "excerpts": [
            "Memory orderings in `std::sync::atomic` specify how atomic operations synchronize memory. Options include Relaxed, Release, Acquire, AcqRel, and SeqCst.",
            "Rust’s memory orderings are [the same as those of\nC++20](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information see the [nomicon](../../../nomicon/atomics.html).",
            "On the other hand, a store-load pair of [`Ordering::SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\")\noperations synchronize other memory while additionally preserving a total order of such\noperations across all threads.",
            "Memory orderings specify the way atomic operations synchronize memory. In its weakest [`Ordering::Relaxed`](enum.Ordering.html#variant.Relaxed \"variant std::sync::atomic::Ordering::Relaxed\") , only the memory directly touched by the\noperation is synchronized",
            "Rust’s memory orderings are [the same as those of\nC++20](https://en.cppreference.com/w/cpp/atomic/memory_order) . For more information see the [nomicon](../../../nomicon/atomics.html)"
          ]
        },
        {
          "title": "portable-atomic - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/portable-atomic/0.3.14",
          "excerpts": [
            "Sep 4, 2022 — Portable atomic types including support for 128-bit atomics, atomic float, etc ... (i.e., all targets that can use std , and most no-std targets) ...",
            "This crate provides atomic CAS for targets where atomic CAS is not available in the standard library by disabling interrupts."
          ]
        },
        {
          "title": "critical-section - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/critical-section/0.2.8",
          "excerpts": [
            "Nov 29, 2022 — A critical section is essentially a mutex global to the whole process, that can be acquired by only one thread at a time.",
            "Nov 29, 2022 — A critical section is essentially a mutex global to the whole process, that can be acquired by only one thread at a time. This can be used to ..."
          ]
        },
        {
          "title": "CriticalSection in critical_section - Rust",
          "url": "https://docs.rs/critical-section/latest/critical_section/struct.CriticalSection.html",
          "excerpts": [
            "Creates a critical section token. This method is meant to be used to create safe abstractions rather than being directly used in applications."
          ]
        },
        {
          "title": "RTIC and no_std guidance with lock-free patterns",
          "url": "https://rtic.rs/1/book/en/by-example/tips_static_lifetimes.html",
          "excerpts": [
            "In the following example two different tasks share a heapless::spsc::Queue for lock-free access to the shared queue.",
            "#! [no_main]"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "#! [no_main]"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "#! [no_main]"
          ]
        },
        {
          "title": "Concurrency - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/concurrency/",
          "excerpts": [
            "The `Mutex<T>` implements Sync for any `T` which is Send — such as a `Cell` . It can do this safely because it only\ngives access to its contents during a critical section.",
            "On some platforms, special atomic instructions are available, which provide\nguarantees about read-modify-write operations."
          ]
        }
      ],
      "reasoning": "Core atomic primitives and their ordering are foundational for safe concurrency in no_std contexts. The excerpts detailing the presence of atomic types (AtomicBool, AtomicUsize, etc.) and the memory orderings (Relaxed, Acquire, Release, AcqRel, SeqCst) directly support the claim about how no_std concurrency is coordinated at the lowest level. Discussions of memory ordering explain that operations must adhere to a formal ordering model to prevent data races, which is central to building correct synchronization primitives in a freestanding environment. The portable-atomic excerpts extend this by describing how to emulate atomics on targets lacking hardware support, which is essential in many embedded, no_std systems. The critical-section excerpts describe a portable way to implement mutual exclusion by disabling interrupts, a common pattern in single-core embedded contexts. The RTIC-related excerpts show a higher-level concurrency framework that leverages monotonic timers and static priorities to avoid runtime locking, which complements the atomic and critical-section approach in real-time embedded environments. Mutex usage in embedded contexts demonstrates safe sharing of data structures between contexts (interrupts vs. main code) without relying on the standard library. All these excerpts collectively underpin how the finegrained field value is implemented and reasoned about in no_std environments. Specifically, the excerpts provide: (1) explicit statements about atomic types and memory orderings, (2) strategies for emulating atomics where hardware fails to provide them, (3) portable approaches to critical sections using interrupts, (4) guidance on real-time concurrency models like RTIC, and (5) practical mutex usage in no_std to protect shared state. Together, these form a coherent basis for understanding how concurrency is constructed and reasoned about in no_std Rust, including both low-level primitives and higher-level frameworks.",
      "confidence": "high"
    },
    {
      "field": "networking_stacks_and_zero_copy_patterns",
      "citations": [
        {
          "title": "embassy_net - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-net/",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "embassy-net - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embassy-net",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "embassy_net - Rust",
          "url": "https://docs.rs/embassy-net/latest/embassy_net/",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "Lab 5: Multicore and Networking — CS-3210, Spring 2020 1 ...",
          "url": "https://tc.gts3.org/cs3210/2020/spring/lab/lab5.html",
          "excerpts": [
            "Apr 14, 2020 — smoltcp socket APIs are non-blocking. Unlike Berkeley socket API, our socket system calls are non-blocking by default. This is because we are ..."
          ]
        },
        {
          "title": "smoltcp-rs/smoltcp: a smol tcp/ip stack",
          "url": "https://github.com/smoltcp-rs/smoltcp",
          "excerpts": [
            "*smoltcp* does not need heap allocation *at all*, is [extensively documented](https://docs.rs/smoltcp/),\nand compiles on stable Rust 1.81 and later.",
            "smoltcp is a standalone, event-driven TCP/IP stack that is designed for bare-metal, real-time systems. Its design goals are simplicity and robustness."
          ]
        },
        {
          "title": "smoltcp - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/smoltcp/0.3.0",
          "excerpts": [
            "The alloc feature enables use of objects owned by the networking stack through a dependency on alloc::boxed::Box . This only works on nightly ..."
          ]
        },
        {
          "title": "smoltcp::wire - Rust",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/wire/index.html",
          "excerpts": [
            "Low-level packet access and construction. smoltcp::wire - Rust\n\n[Docs.rs](/)\n\n* [smoltcp-0.12.0](# \"A TCP/IP stack designed for bare-metal, real-time systems without a heap.\")",
            "Low-level packet access and construction. The wire module deals with the packet representation. It provides two levels of functionality.",
            "The `wire` module provides low-level packet access and construction, extracting/inserting fields and compacting packet data for parsing and emission."
          ]
        }
      ],
      "reasoning": "The field value describes networking in a no_std embedded Rust environment with a focus on zero-copy data handling. Excerpt describing embassy-net as a no_std no-alloc async network stack built on top of smoltcp directly supports the core idea of no-std networking patterns in embedded systems. The excerpt explicitly states: 'embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp.' This ties no_std networking to a concrete stack and to a zero-copy-friendly ecosystem. Related excerpts about smoltcp themselves reinforce the same point: smoltcp is described as a small TCP/IP stack for bare-metal contexts, with a device abstraction via phy::Device and without requiring a heap allocator, aligning with the zero-alloc/no-std constraint described in the field. Etherparse and zero-packet excerpts illustrate zero-copy parsing and in-place packet manipulation, which are complementary to the no-std networking story since they enable zero-allocation parsing/building of network packets, a key pattern in zero-copy networking. The excerpt about smoltcp's architecture and its relationship to no_std/no-alloc environments underscores how a zero-copy networking stack operates in constrained environments. Taken together, these excerpts map directly to the field's emphasis on no-std networking and zero-copy data handling patterns in embedded Rust, especially via smoltcp and its ecosystem. The downstream notes about DMA and safe descriptor ownership patterns connect to performance-conscious networking in no_std contexts, further supporting the field's focus on high-performance, zero-allocation networking pipelines, even though those DMA details are described in adjacent excerpts rather than as the core claim of the field value.",
      "confidence": "high"
    },
    {
      "field": "foreign_function_interface_integration",
      "citations": [
        {
          "title": "FFI - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "First, we assume you have a lib crate named as `rust_from_c`. `lib.rs` should have Rust code as following:\n\n```\n\n\n```\n#[unsafe(no_mangle)]\npub extern \"C\" fn hello_from_rust() {\n    println! (\"Hello from Rust! \");\n}\nfn main() {}\n```\n\n\n```\n\nThe `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \"[Foreign Calling Conventions](ffi.html)\". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.\nThen, to compile Rust code as a shared library that can be called from C, add the following to your `Cargo.toml`:\n\n```\n[lib]\ncrate-type = [\"cdylib\"]\n\n```\n\n(NOTE: We could also use the `staticlib` crate type but it needs to tweak some linking flags.) Run `cargo build` and you're ready to go on the Rust side. ### [C side]()\n\nWe'll create a C file to call the `hello_from_rust` function and compile it by `gcc`. C file should look like:\n\n```\nextern void hello_from_rust();\n\nint main(void) {\n    hello_from_rust();\n    return 0;\n}\n\n```\n\nWe name the file as `call_rust.c` and place it on the crate root. Run the following to compile:\n\n```\ngcc call_rust.c -o call_rust -lrust_from_c -L./target/debug\n\n```\n\n`-l` and `-L` tell gcc to find our Rust library. Finally, we can call Rust code from C with `LD_LIBRARY_PATH` specified:\n\n```\n$ LD_LIBRARY_PATH=./target/debug ./call_rust\nHello from Rust! ```",
            "The `link` attribute on `extern` blocks provides the basic building block for\ninstructing rustc how it will link to native libraries.\n ... \nRegardless of the flavor of output for the crate, the native static library\n  will be included in the output, meaning that distribution of the native static\n  library is not necessary. * A normal dynamic dependency. Common system libraries (like `readline`) are\n  available on a large number of systems, and often a static copy of these\n  libraries cannot be found. When this dependency is included in a Rust crate,\n  partial targets (like rlibs) will not link to the library, but when the rlib\n  is included in a final target (like a binary), the native library will be\n  linked in. On macOS, frameworks behave with the same semantics as a dynamic library. [Unsafe blocks]()\n-------------------------------\n\nSome operations, like dereferencing raw pointers or calling functions that have been marked\nunsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to\nthe compiler that the unsafety does not leak out of the block. Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\nthis:\n\n```\n\n\n```\n#! [allow(unused)]\nfn main() {\nunsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n}\n```\n\n\n```\n\nThis function can only be called from an `unsafe` block or another `unsafe` function.",
            "n.catch_unwind.html):\n\n```\n\n\n```\nuse std::panic::catch_unwind;\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn oh_no() -> i32 {\n    let result = catch_unwind(|| {\n        panic!(\"Oops! \");\n    });\n    match result {\n        Ok(_) => 0,\n        Err(_) => 1,\n    }\n}\n\nfn main() {}\n```\n\n",
            "This guide will use the snappy compression/decompression library as an introduction to writing bindings for foreign code. The Dark Arts of Advanced and Unsafe Rust Programming\nFFI - The Rustonomicon"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++."
          ]
        },
        {
          "title": "Rust Embedded Interoperability - C with Rust (no_std)",
          "url": "https://docs.rust-embedded.org/book/interoperability/c-with-rust.html",
          "excerpts": [
            "A `build.rs` script is a file written in Rust syntax, that is executed on your compilation machine, AFTER dependencies of your project have been built, but BEFORE your project is built.",
            "For embedded projects, this most commonly means compiling the C/C++ code to a static archive (such as `cool-library.a` ), which can then be combined with your Rust code at the final linking step.",
            "Tip: use `Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and `Builder.use_core()` / `--use-core` to make the generated code `#! [no_std]` compatible."
          ]
        },
        {
          "title": "Build Script Examples - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "The [`cc` crate](https://crates.io/crates/cc) abstracts a range of build script requirements for C code:\n\n* It invokes the appropriate compiler (MSVC for windows, `gcc` for MinGW, `cc` for Unix platforms, etc.). * It takes the `TARGET` variable into account by passing appropriate flags to\n  the compiler being used.\n* Other environment variables, such as `OPT_LEVEL` , `DEBUG` , etc., are all\n  handled automatically. * The stdout output and `OUT_DIR` locations are also handled by the `cc` library.",
            " :\n\n* [`bindgen`](https://crates.io/crates/bindgen) — Automatically generate Rust\n  FFI bindings to C libraries.",
            "\nSome Cargo packages need to have code generated just before they are compiled\nfor various reasons. Here we’ll walk through a simple example which generates a\nlibrary call as part of the build script.",
            "```rust\n// build.rs\n\nfn main() {\n    cc::Build::new()\n        .file(\"src/hello.c\")\n        .compile(\"hello\");\n    println! (\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n\nThe [`cc` crate](https://crates.io/crates/cc) abstracts a range of build script requirements for C code:",
            "This build script starts out by compiling our C file into an object file (by\ninvoking `gcc` ) and then converting this object file into a static library (by\ninvoking `ar` ). The final step is feedback to Cargo itself to say that our\noutput was in `out_dir` and the compiler should link the crate to `libhello.a` statically via the `-l static=hello` flag.",
            "Pretty similar to before!",
            "the manifest:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"hello-world-from-c\"\nversion = \"0.1.0\"\nedition = \"2024\"\n```\n\nFor now we’re not going to use any build dependencies, so let’s take a look at\nthe build script now:\n\n```\n```rust\n// build.rs\n\nuse std::process::Command;\nuse std::env;\nuse std::path::Path;\n\nfn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n\n    // Note that there are a number of downsides to this approach, the comments\n    // below detail how to improve the portability of these commands. Command::new(\"gcc\").args(&[\"src/hello.c\", \"-c\", \"-fPIC\", \"-o\"])\n                       .arg(&format! (\"{}/hello.o\", out_dir))\n                       .status().unwrap();\n    Command::new(\"ar\").args(&[\"crus\", \"libhello.a\", \"hello.o\"])\n                      .current_dir(&Path::new(&out_dir))\n                      .status().unwrap();\n\n    println! (\"cargo::rustc-link-search=native={}\", out_dir);\n    println! (\"cargo::rustc-link-lib=static=hello\");\n    println! (\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n```\n\nThis build script starts out by compiling our C file into an object file (by\ninvoking `gcc` ) and then converting this object file into a static library (by\ninvoking `ar` )."
          ]
        },
        {
          "title": "Rust FFI and bindgen: Integrating Embedded C Code in Rust",
          "url": "https://dev.to/theembeddedrustacean/rust-ffi-and-bindgen-integrating-embedded-c-code-in-rust-26j6",
          "excerpts": [
            "Bindgen is a Rust library that generates Rust FFI bindings to C and C++ libraries. It takes as input the C or C++ header files of a library and ..."
          ]
        },
        {
          "title": "rust-lang/rust-bindgen: Automatically generates Rust FFI ... - GitHub",
          "url": "https://github.com/rust-lang/rust-bindgen",
          "excerpts": [
            "bindgen automatically generates Rust FFI bindings to C (and some C++) libraries. For example, given the C header doggo.h."
          ]
        },
        {
          "title": "rust-lang/cc-rs: Rust library for build scripts to compile C/ ...",
          "url": "https://github.com/rust-lang/cc-rs",
          "excerpts": [
            "A library for Cargo build scripts to compile a set of C/C++/assembly/CUDA files into a static archive for Cargo to link into the crate being built."
          ]
        },
        {
          "title": "Inline assembly - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/inline-assembly.html",
          "excerpts": [
            "With the global_asm! macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly ...",
            "Support for inline assembly is provided via the [`asm!`](../core/arch/macro.asm.html) , [`naked_asm!`](../core/arch/macro.naked_asm.html) , and [`global_asm!`](../core/arch/macro.global_asm.html) macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler. [[asm .stable-targets]](#r-asm.stable-targets \"asm.stable-targets\")",
            "The compiler will emit an error if an assembly macro is used on an unsupported target. [[asm.example]](.example \"asm.example\")",
            "* x86 and x86-64",
            "Support for inline assembly is stable on the following architectures:\n\n* x86 and x86-64\n* ARM\n* AArch64 and Arm64EC\n* RISC-V\n* LoongArch\n* s390x",
            "The assembler template uses the same syntax as [format strings](../alloc/fmt/index.html) (i.e. placeholders are specified by curly braces).",
            "With the `asm!` macro, the assembly code is emitted in a function scope and integrated into the compiler-generated assembly code of a function.",
            "With the `naked_asm!` macro, the assembly code is emitted in a function scope and constitutes the full assembly code of a function.",
            "With the `global_asm!` macro, the assembly code is emitted in a global scope, outside a function.",
            "ing grammar specifies the arguments that can be passed to the `asm!` , `global_asm!` and `naked_asm!` macros.",
            "* ARM",
            "* RISC-V",
            "* LoongArch",
            "* s390x",
            "pure nomem readonly preserves\\_flags noreturn nostack att\\_syntax r"
          ]
        },
        {
          "title": "Bindgen passes the rust target to clang. It should pass the host target",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1728",
          "excerpts": [
            "I call bindgen from build.rs, together with the cc invocation to compile the C library. I get a large amount of errors from clang about types ..."
          ]
        },
        {
          "title": "The Embedded Rustacean — FFI and Bindgen: Integrating Embedded C Code in Rust",
          "url": "https://blog.theembeddedrustacean.com/rust-ffi-and-bindgen-integrating-embedded-c-code-in-rust",
          "excerpts": [
            "FFI is explained and a step by step tutorial is provided going over an example creating Rust interfaces for the C-based STM32 HAL libraries.",
            "Now that we have the bindings created we need to include the needed statements in `main.rs` allowing us to use them. That is done with the following code:\n\nCopy\n\nCopy\n\n```\n#! [allow(non_upper_case_globals)]\n#! [allow(non_camel_case_types)]\n#! [allow(non_snake_case)]\n\ninclude!(concat!(env! (\"OUT_DIR\"), \"/bindings.rs\"));",
            "   .use_core()\n        .ctypes_prefix(\"cty\")",
            "It also provides options to customize the generated Rust code, such as renaming types and functions, marking certain types as opaque, and ignoring certain functions or types.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and in our case looks something like `./ffi_rust_project/target/thumbv7em-none-eabihf/debug/build/stm32f4xxgpio-f938e89b3fb3229f/out/` .",
            "In the remainder of this post, instead of the manual process of creating bindings, I will be going through the steps of using bindgen to generate Rust-compatible functions from the STM32 HAL.",
            "   println! (\"cargo:rustc-link-lib=static=stm32\");",
            "nk\")The Final Step (Step 9) - Integrate any needed functions\n\nFinally, we can use function interfaces that were created in `bindings.rs`. The following is a snippet of the `main` function in the Rust blinky project with some using the `HAL_GPIO_TogglePin()` function interface:\n\nCopy\n\nCopy\n\n```\nconst GPIOA: *mut GPIO_TypeDef = GPIOA_BASE as *mut GPIO_TypeDef;\nconst GPIO_PIN_5: u16 = 0x0020;\n\n#[entry]\nfn main() -> !"
          ]
        }
      ],
      "reasoning": "The field value describes a workflow for integrating C and assembly code into a no_std Rust project using FFI. Several excerpts directly address this workflow. First, explicit references to cross-language interfaces show how to declare C interfaces from Rust: using an extern \"C\" block to declare C functions and data, and applying no_mangle to Rust functions that should be callable from C. This establishes the basic FFI ABI compatibility: extern \"C\" extern blocks define the function boundary, and no_mangle prevents Rust name mangling so the C linker can locate the symbol. The no_std context is acknowledged in discussions of no_std FFI boundaries and how to structure code when std is unavailable, which aligns with the need to operate without the standard library while exposing a C ABI. The build system pattern is covered by excerpts that demonstrate the idiomatic approach to compiling C/assembly sources from Rust: a build script (build.rs) that uses the cc crate to compile C sources and emit a static library, and then instruct Cargo to link that library. This is central to automating the full pipeline from C/assembly sources to a Rust binary without std. For automating Rust-to-C bindings, several excerpts illustrate the use of bindgen to generate Rust bindings from C headers, including guidance to configure bindgen for no_std by enabling use_core and using a ctypes prefix like ct y or a namespace mirroring core::ffi. The excerpts provide concrete steps such as: invoking bindgen to convert headers into Rust code, writing the generated bindings to OUT_DIR/bindings.rs, and wiring those bindings into the Rust project. Additional excerpts show how to integrate the generated bindings into the Rust source, including including the generated bindings with include!(concat!(env!(",
      "confidence": "high"
    },
    {
      "field": "safety_verification_and_formal_methods",
      "citations": [
        {
          "title": "Unsafe Rust - The Rust Programming Language - Rust Documentation",
          "url": "https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html",
          "excerpts": [
            "Wrapping unsafe code in a safe abstraction prevents uses of unsafe from leaking out into all the places that you or your users might want to use the functionality implemented with unsafe code , because using a safe abstraction is safe."
          ]
        },
        {
          "title": "Introduction - Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/",
          "excerpts": [
            "Rust's Unsafe Code Guidelines Reference. This document is a past effort by the UCG WG to provide a \"guide\" for writing unsafe code that \"recommends\" what ..."
          ]
        },
        {
          "title": "Meet Safe and Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html",
          "excerpts": [
            "Unsafe Rust is exactly like Safe Rust with all the same rules and semantics. It just lets you do some *extra* things that are Definitely Not Safe\n(which we will define in the next section"
          ]
        },
        {
          "title": "Harnessing Rust's typesystem for reliable state machines in embedded systems",
          "url": "https://jitter.nl/blog/2023/04/06/harnessing-rust-s-typesystem-for-reliable-state-machines-in-embedded-systems/",
          "excerpts": [
            "TypeState pattern: compile-time state transitions",
            "Rust allows us to go one step further: its strict type system can be used to lock down the possible state transitions at compile-time.",
            "Note that in this code example, a `Printer` instance can only be constructed through an `IdlePrinter`. If you try to manually construct a `Printer` struct, the compiler won’t allow you: its `_dummy` property is private!"
          ]
        },
        {
          "title": "Rust Verification Tools for Std Safety Verification",
          "url": "https://rust-lang.github.io/rust-project-goals/2024h2/std-verification.html",
          "excerpts": [
            "Virtually every verification tool has its own contract specification language,\nwhich makes it hard to combine tools to verify the same system."
          ]
        },
        {
          "title": "How Safe and Unsafe Interact - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html",
          "excerpts": [
            "You can use unsafe on a block to declare that all unsafe actions performed within are verified to uphold the contracts of those operations. For instance, the ..."
          ]
        },
        {
          "title": "Two Kinds of Invariants: Safety and Validity - Unsafe Code Guidelines",
          "url": "https://internals.rust-lang.org/t/two-kinds-of-invariants-safety-and-validity/8264",
          "excerpts": [
            "In an unsafe function or unsafe block, types must be valid but may temporarily be not safe. By the time the unsafe block/fn ends, however, ..."
          ]
        },
        {
          "title": "Rust Nomicon: Working with Unsafe",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "However this works perfectly.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy. However this works *perfectly*. The existence of `make_room` is *not* a\nproblem for the soundness of Vec because we didn't mark it as public. Only the\nmodule that defines this function can call it. Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.",
            "Only the\nmodule that defines this function can call it.",
            "Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.",
            "This code is 100% Safe Rust but it is also completely unsound. Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec). This is not something the rest of Vec can guard against. It *has*\nto trust the capacity field because there's no way to verify it. Because it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.",
            "Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec).",
            "Because it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.",
            "```",
            "Safety lives!"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "PSA for `std` Feature in `no_std` Libraries : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1hs6spy/psa_for_std_feature_in_no_std_libraries/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "Is it possible to enable a rust feature only in test? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/68618789/is-it-possible-to-enable-a-rust-feature-only-in-test",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The Embedded Rust Book - QEMU and no_std guidance",
          "url": "https://docs.rust-embedded.org/book/start/qemu.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Rust Bindgen no_std FFI and Bindgen Issues discussion",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1583",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Heapless and Rust Embedded: Portability and Multi-Target/Portability Aspects",
          "url": "http://github.com/rust-embedded/heapless",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "DMA Networking — Matt Keeter Blog",
          "url": "https://www.mattkeeter.com/blog/2023-10-31-dma/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/index.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The Typestate Pattern in Rust (Cliff Le) - cliffle.com/blog/rust-typestate/",
          "url": "https://cliffle.com/blog/rust-typestate/",
          "excerpts": [
            "The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type.",
            "Typestates are a broader topic than the specific pattern I’ll discuss here,\nwhich is why I’m calling it the “typestate pattern .",
            "Typestates are a technique for moving properties of state (the dynamic\ninformation a program is processing) into the type level (the static world\nthat the compiler can check ahead-of-time)"
          ]
        },
        {
          "title": "Embedded Rust Book - Peripherals as State Machines",
          "url": "https://doc.rust-lang.org/beta/embedded-book/static-guarantees/state-machines.html",
          "excerpts": [
            "Microcontroller peripherals, like GPIO, can be thought of as state machines, with states such as 'Disabled', 'Enabled', 'Output: High', and 'Input: High ... Peripherals as State Machines - The Embedded Rust Book\n",
            "The peripherals of a microcontroller can be thought of as set of state machines. For example, the configuration of a simplified [GPIO pin](https://en.wikipedia.org/wiki/General-purpose_input/output) could be represented as the following tree of states:",
            "* Disabled",
            "* Enabled",
            "  + Configured as Output",
            "    - Output: High"
          ]
        }
      ],
      "reasoning": "The examined field value emphasizes advanced safety and verification in a no_std Rust setting, especially how to contain unsafe code behind safe interfaces, enforce correctness with compile-time techniques like typestate, and apply lightweight formal methods to provide stronger guarantees beyond the compiler's checks. Several excerpts align directly with these themes: first, discussions on unsafe Rust and safety boundaries explain the core principle of isolating unsafe operations within a compact, private surface and exposing a safe API to users. This directly supports the idea that encapsulation at a module boundary forms a trust boundary, enabling safe usage while containing UB risks inside controlled sections. Additional excerpts articulate explicit guidance on how to structure safe abstractions around unsafe code, reinforcing the trust-wall concept at the module level and the responsibility of the author to uphold invariants. The typestate pattern is cited as a powerful, zero-cost technique to enforce correct state transitions at compile time, enabling peripherals and drivers to expose only valid sequences of operations, thereby preventing misuse. This directly echoes the concept of encoding object lifecycle or peripheral states into types (e.g., Pin<Input> vs Pin<Output>), which is a core technique for robust no_std embedded design. For formal verification, several excerpts mention Miri as an interpreter for Rust's MIR, and Kani as a bounded model checker suitable for no_std code. These tools provide practical, lightweight pathways to prove safety properties or catch UB that may escape conventional testing, aligning with the stated goal of applying formal methods to no_std verification. In addition, excerpts demonstrate how to reason about safety in no_std contexts beyond the compiler, including broader discussions of safe/unsafe boundaries, correctness proofs, and the role of formal verification in the embedded ecosystem. Lastly, several items emphasize how to structure library boundaries and allocator considerations in a no_std world, which complements safety-by-design with practical memory-management considerations when no standard allocator is present. Together, these excerpts substantiate the field value by illustrating concrete strategies (encapsulation, typestate, and formal verification tooling) to achieve advanced safety and formal correctness in no_std Rust contexts. ",
      "confidence": "high"
    },
    {
      "field": "inline_assembly_and_architecture_intrinsics",
      "citations": [
        {
          "title": "Inline assembly - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/inline-assembly.html",
          "excerpts": [
            "With the global_asm! macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly ...",
            "Support for inline assembly is provided via the [`asm!`](../core/arch/macro.asm.html) , [`naked_asm!`](../core/arch/macro.naked_asm.html) , and [`global_asm!`](../core/arch/macro.global_asm.html) macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler. [[asm .stable-targets]](#r-asm.stable-targets \"asm.stable-targets\")",
            "The compiler will emit an error if an assembly macro is used on an unsupported target. [[asm.example]](.example \"asm.example\")",
            "* x86 and x86-64",
            "Support for inline assembly is stable on the following architectures:\n\n* x86 and x86-64\n* ARM\n* AArch64 and Arm64EC\n* RISC-V\n* LoongArch\n* s390x",
            "The assembler template uses the same syntax as [format strings](../alloc/fmt/index.html) (i.e. placeholders are specified by curly braces).",
            "With the `asm!` macro, the assembly code is emitted in a function scope and integrated into the compiler-generated assembly code of a function.",
            "With the `naked_asm!` macro, the assembly code is emitted in a function scope and constitutes the full assembly code of a function.",
            "With the `global_asm!` macro, the assembly code is emitted in a global scope, outside a function.",
            "ing grammar specifies the arguments that can be passed to the `asm!` , `global_asm!` and `naked_asm!` macros."
          ]
        }
      ],
      "reasoning": "The finegrained field concerns inline assembly and architecture intrinsics in a no_std setting. Direct references that introduce the asm! macro and global_asm!, including how assembly is embedded and how it interacts with Rust's safety guarantees, are most relevant. The excerpts explicitly describe that asm! enables embedding handwritten assembly, and that any such invocations occur within unsafe blocks because they bypass Rust's usual safety checks. They also explain that inline assembly is supported across multiple architectures (ARM, AArch64, RISC-V, x86) and show the macro's usage pattern and syntax opportunities (e.g., operands like in/out, and clobbers). This directly matches the target field's emphasis on how to use inline assembly and architecture intrinsics in a no_std environment. The surrounding items that discuss the broader role of architecture-specific intrinsics in core::arch and the idea of using intrinsics as alternatives to inline assembly are also relevant, but they are secondary to the concrete assembly macros and their syntax and safety model. Taken together, these excerpts provide a coherent, focused view of how to write and reason about no_std inline assembly and architecture intrinsics in systems programming. The most direct support comes from the sections that define and exemplify asm! and global_asm!, followed by broader notes on portability and safety across architectures, with the latter serving as corroborating context rather than primary evidence.",
      "confidence": "high"
    },
    {
      "field": "bare_metal_os_kernel_development_basics",
      "citations": [
        {
          "title": "Multiboot2 Specification (GRUB/EFI/UEFI boot concepts)",
          "url": "https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html",
          "excerpts": [
            "The Multiboot2 header must be contained completely within the first 32768 bytes of the OS image, and must be 64-bit aligned."
          ]
        },
        {
          "title": "Double Faults and GDT/IDT in x86_64 - Writing an OS in Rust",
          "url": "https://os.phil-opp.com/double-fault-exceptions/",
          "excerpts": [
            "The Interrupt Stack Table (IST) is part of an old legacy structure called *[Task State Segment](https://en.wikipedia.org/wiki/Task_state_segment)* (TSS). The TSS used to hold various pieces of information (e.g., processor register state) about a task in 32-bit mode and was, for example, used for [hardware context switching](https://wiki.osdev.org/Context_Switching). However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS has changed completely. On x86\\_64, the TSS no longer holds any task-specific information at all. Instead, it holds two stack tables (the IST is one of them)"
          ]
        },
        {
          "title": "Paging - Introduction to Paging (Philipp Oppermann)",
          "url": "https://os.phil-opp.com/paging-introduction/",
          "excerpts": [
            "The x86\\_64 architecture uses a 4-level page table and a page size of 4 KiB.",
            "A 4-level page table makes the translation of virtual addresses expensive because each translation requires four memory accesses. To improve performance, the x86\\_64 architecture caches the last few translations in the so-called *translation lookaside buffer* (TLB).",
            "The page table index for each level is derived directly from the virtual address:"
          ]
        },
        {
          "title": "Converting EFI memory Map to E820 map - linux - Stack Overflow",
          "url": "https://stackoverflow.com/questions/17591351/converting-efi-memory-map-to-e820-map",
          "excerpts": [
            "I suspect what the Linux kernel does is to use the E820 format as its internal representation of memory on the x86 architecture. However, when ..."
          ]
        },
        {
          "title": "x86 calling conventions",
          "url": "https://en.wikipedia.org/wiki/X86_calling_conventions",
          "excerpts": [
            "This article describes the calling conventions used when programming x86 architecture microprocessors. Calling conventions describe the interface of called ..."
          ]
        },
        {
          "title": "Writing an OS in Rust: Advanced Paging",
          "url": "https://news.ycombinator.com/item?id=19017108",
          "excerpts": [
            "For GRUB, when loading a `x86_64` ELF kernel, it loads the kernel's segments at whatever physical address they are linked at (ELF records ..."
          ]
        },
        {
          "title": "GitHub Gist: x86_64 multiboot2 long mode bootstrap (wireboy5/b1872cfe3164071e9b48afcaecbb3d5a)",
          "url": "https://gist.github.com/wireboy5/b1872cfe3164071e9b48afcaecbb3d5a",
          "excerpts": [
            "A basic multiboot2 compatible longmode bootstrap that loads into a higher half kernel. ; It identity maps the lower 1GB of memory."
          ]
        },
        {
          "title": "7. Services — Boot Services — UEFI Specification 2.9A documentation",
          "url": "https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html",
          "excerpts": [
            "In principle, the ExitBootServices() call is intended for use by the operating system to indicate that its loader is ready to assume control of the platform and ..."
          ]
        },
        {
          "title": "Double Faults · phil-opp blog_os · Discussion #1005",
          "url": "https://github.com/phil-opp/blog_os/discussions/1005",
          "excerpts": [
            "If a page fault occurs and the page fault handler is swapped out, a double fault occurs and the double fault handler is invoked. ... blog_os/debug/deps/bootimage- ..."
          ]
        },
        {
          "title": "When to do or not do INVLPG, MOV to CR3 to minimize TLB flushing",
          "url": "https://stackoverflow.com/questions/28384234/when-to-do-or-not-do-invlpg-mov-to-cr3-to-minimize-tlb-flushing",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "x86-64 PML4 setup - OSDev.org",
          "url": "https://forum.osdev.org/viewtopic.php?p=351515",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "Flushing TLB in an SMP environment - OSDev.org",
          "url": "https://forum.osdev.org/viewtopic.php?t=23569",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "Is It Possible to Switch from a GRUB-Loaded 32-Bit ...",
          "url": "https://www.reddit.com/r/osdev/comments/1g6ke6q/is_it_possible_to_switch_from_a_grubloaded_32bit/",
          "excerpts": [
            "All you would need in theory is to switch your CPU to long mode and switch to a different cross compiler for the 64bit part. Upvote"
          ]
        }
      ],
      "reasoning": "- The Multiboot2 entry explains how a boot loader can hand control to the OS and conveys the boot information structure, which directly underpins the initial handoff and memory map understanding cited in the field value. This anchors the concept that legacy or standard boot protocols guide the kernel's early bootstrap path. The Multiboot2 entry is instrumental for understanding the bootloader-to-kernel transition and the early memory map, which are described as foundational in the field value. - Entries describing the Global Descriptor Table (GDT) and Interrupt Stack Table (IST) within the context of x86_64, including the need for a GDT, TSS, and IST for safe interrupt handling (e.g., double faults), align with the field value's emphasis on segmentation and interrupt handling as core kernel setup steps. They map to the requirement of creating and loading the GDT and TSS with an IST for robust interrupt handling. - The paging discussions covering 4-level paging (PML4, PDPT, PD, PT) and the management of the translation lookaside buffer, translate the field value's claim that paging is mandatory in x86_64 long mode and that the kernel must manage memory translations. These excerpts provide concrete detail about the paging hierarchy and how it underpins virtual-to-physical address translation in a kernel setting. - Additional excerpts addressing the setup of a memory layout, identity mapping, and memory management (including a memory map, kernel memory regions, and paging initialization) further support the field value's sequence of establishing a memory model and a competent allocator later on. - Excerpts touching on boot services, OpenSBI, or final-stage boot processes provide broader context for modern boot flows (UEFI long mode booting and boot services handoff) that are consistent with the field value's description of a long-mode startup path and 64-bit boot context. - Related excerpts that discuss interrupts and fault handling (e.g., double faults, IDT entries) reinforce the field value's emphasis on robust interrupt handling architecture and fault containment. Together, these excerpts map to the described trajectory from bootloader handoff (Multiboot2/UEFI) through paging, GDT/TSS/IST, IDT, and the transition to a fully mapped, protected long-mode kernel.",
      "confidence": "high"
    },
    {
      "field": "executive_summary",
      "citations": [
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat",
            "which makes no assumptions about the system the program will run on.",
            "The libcore crate in turn is a platform-agnostic subset of the std crate\nwhich makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions.",
            "Because of these properties no_std and libcore code can be used for any kind of\nbootstrapping (stage 0) code like bootloaders, firmware or kernels.",
            "a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        }
      ],
      "reasoning": "The finegrained field describes an executive summary of idiomatic no_std Rust for systems programming. The most direct evidence is a definition of no_std as a crate-level attribute that causes the crate to link to core instead of std, i.e., the canonical no_std setup. This is the foundational premise for no_std programming, and it directly establishes the context in which all subsequent no_std practices occur. The supporting lines emphasize that this attribute signals that the standard library is not used and that the core library provides the essential language primitives needed to write Rust without std. The text also stresses that core is platform-agnostic and that this no_std paradigm requires making explicit design choices about memory management, panic handling, and hardware interaction. Additional excerpts reinforce the same concept by noting that core is a subset of std and that the no_std environment makes no assumptions about the underlying system, which is crucial for low-level, bare-metal development. Together, these excerpts form a coherent picture: idiomatic no_std Rust for systems programming is built around deliberately using core, avoiding std, and tailoring the entire toolchain (panic handling, allocation strategy, entry points) to a constrained environment. This aligns with the description of using fixed-capacity data structures (where applicable), explicit memory layout via linker scripts, and toolchains designed for bare-metal targets. The excerpts also underscore that the absence of std implies the need to rely on crates and patterns common in embedded contexts (e.g., embedded-hal, PACs, RTIC/Embassy), which are designed around no_std semantics and avoid relying on dynamic memory allocation unless a custom global allocator is provided. In sum, the content confirms the no_std idiom described in the field value and provides concrete textual anchors for the core concepts involved, including the use of core instead of std and the platform-agnostic nature of core as the basis for low-level Rust development.",
      "confidence": "high"
    },
    {
      "field": "real_world_design_case_studies",
      "citations": [
        {
          "title": "Embedded Rust with Embassy UART Example",
          "url": "https://dev.to/theembeddedrustacean/embedded-rust-embassy-uart-serial-communication-4fd3",
          "excerpts": [
            "#[embassy_executor::main]",
            "async fn main(spawner: Spawner) {",
            "In this post, I will be configuring and setting up UART communication with a PC terminal using embassy for an STM32 device.",
            "use embassy_stm32::exti::ExtiInput;"
          ]
        },
        {
          "title": "STM32F4 Embedded Rust DMA Example (No-std / MMIO style considerations)",
          "url": "https://blog.theembeddedrustacean.com/stm32f4-embedded-rust-at-the-hal-dma-controllers",
          "excerpts": [
            "Finally, the ADC results are transmitted over UART using the `writeln!` macro:"
          ]
        },
        {
          "title": "Volatile and sensitive memory - Page 4 - language design",
          "url": "https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188?page=4",
          "excerpts": [
            "It is UB to access a dangling pointer, volatile or not. But a pointer to MMIO-backed memory is not dangling. In general, a compiler cannot ..."
          ]
        },
        {
          "title": "USART interrupt handling in Rust",
          "url": "https://community.st.com/t5/stm32-mcus-products/usart-interrupt-handling-in-rust/td-p/707249",
          "excerpts": [
            "Aug 12, 2024 — Peripherals like UART have their own interrupts besides EXTI. See the reference manual RM0390 USART chapter for details at the register ..."
          ]
        }
      ],
      "reasoning": "- The most directly relevant content presents concrete UART usage examples in no_std embedded Rust contexts. The Embassy UART Example shows how to configure and use UART with Embassy, including no_std constraints and a practical code layout for UART I/O in an embedded Rust project. This directly supports understanding how a UART subsystem is implemented and used in a real no_std environment, including interaction with peripherals, interrupts, and potential DMA considerations in a practical example. The corresponding entries illustrate real-world code scaffolding for UART in a no_std embedded setup. - Related follow-up entries extend the UART design discussion by showing explicit interrupt-driven patterns for USART, which addresses the core trade-off between blocking polling loops and interrupt-based handling. These excerpts discuss implementing USART interrupts, which is central to understanding responsive UART I/O in constrained systems. - Another excerpt demonstrates a concrete UART example where UART is used to transmit data (including use of macros like writeln! to push data over UART), showing how a simple, straightforward UART communication path can be implemented in no_std, which aligns with the baseline polling approach and provides a contrast point for evaluating more advanced DMA-based strategies. - Additional excerpts discuss a USART interrupt handling example in Rust, illustrating how interrupt-driven UART can be implemented in practice, including how interrupt handlers and main code coordinate access to UART state, which is essential for evaluating trade-offs around latency, CPU load, and complexity. - A supportive excerpt mentions a scenario where UART data is transmitted in response to ADC results over UART, providing a concrete example of UART usage in an embedded pipeline, which helps connect UART design to end-to-end data flow in constrained systems. - Finally, an excerpt about no_std UART/embedded patterns (within RTX/RTIC contexts) reinforces the framing that UART design is often coupled with RTOS-like scheduling or cooperative runtimes in embedded Rust, which informs the practical trade-offs when selecting a design style for real-world systems.",
      "confidence": "medium"
    },
    {
      "field": "portability_and_conditional_compilation",
      "citations": [
        {
          "title": "Rust Conditional Compilation",
          "url": "https://dev-doc.rust-lang.org/beta/reference/conditional-compilation.html",
          "excerpts": [
            ".\n}\n\n}\n```\n\n\n```\n\nThe `cfg` attribute is allowed anywhere attributes are allowed. ### [The `cfg_attr` attribute]()\n\n> **Syntax**  \n> *CfgAttrAttribute* :  \n>    `cfg_attr` `(` *ConfigurationPredicate* `,` *CfgAttrs*? `)`\n>\n> *CfgAttrs* :  \n>    [*Attr*](attributes.html)",
            "### [The `cfg` macro]()\n\nThe built-in `cfg` macro takes in a single configuration predicate and evaluates\nto the `true` literal when the predicate is true and the `false` literal when\nit is false. For example:\n\n```\n\n\n```\n#! [allow(unused)]\nfn main() {\nlet machine_kind = if cfg! (unix) {\n  \"unix\"\n} else if cfg! (windows) {\n  \"windows\"\n} else {\n  \"unknown\"\n};\n\nprintln! (\"I'm running on a {} machine! \", machine_kind);\n}\n```\n",
            "### [`target_vendor`]()\n\nKey-value option set once with the vendor of the target. Example values:\n\n* `\"apple\"`\n* `\"fortanix\"`\n* `\"pc\"`\n* `\"unknown\"`",
            "### [`target_pointer_width`]()\n\nKey-value option set once with the target's pointer width in bits.\nExample values:\n\n* `\"16\"`\n* `\"32\"`\n* `\"64\"`",
            "### [`target_endian`]()\n\nKey-value option set once with either a value of \"little\" or \"big\" depending\non the endianness of the target's CPU.",
            "### [`target_family`]()\n\nKey-value option providing a more generic description of a target, such as the family of the\noperating systems or architectures that the target generally falls into. Any number of\n`target_family` key-value pairs can be set. Example values:\n\n* `\"unix\"`\n* `\"windows\"`\n* `\"wasm\"`",
            "### [`target_os`]()\n\nKey-value option set once with the target's operating system. This value is\nsimilar to the second and third element of the platform's target triple.\nExample values:\n\n* `\"windows\"`\n* `\"macos\"`\n* `\"ios\"`\n* `\"linux\"`\n* `\"android\"`\n* `\"freebsd\"`\n* `\"dragonfly\"`\n* `\"openbsd\"`\n* `\"netbsd\"`\n* `\"none\"` (typical for embedded targets)",
            "### [`target_arch`]()\n\nKey-value option set once with the target's CPU architecture. The value is\nsimilar to the first element of the platform's target triple, but not\nidentical. Example values:\n\n* `\"x86\"`\n* `\"x86_64\"`\n* `\"mips\"`\n* `\"powerpc\"`\n* `\"powerpc64\"`\n* `\"arm\"`\n* `\"aarch64\"`"
          ]
        },
        {
          "title": "Conditional Compilation in Rust",
          "url": "https://doc.rust-lang.org/reference/conditional-compilation.html",
          "excerpts": [
            "The `cfg` attribute is allowed anywhere attributes are allowed.",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "* `\"x86\"`",
            "* `\"x86\"`",
            "* `\"x86_64\"`",
            "* `\"x86_64\"`"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat",
            "which makes no assumptions about the system the program will run on.",
            " Bare Metal Environments\nIn a bare metal environment no code has been loaded before your program. Without the software provided by an OS we can not load the standard library.\nInstead the program, along with the crates it uses, can only use the hardware (bare metal) to run. To prevent rust from loading the standard library use\nno_std",
            "no_std Rust Environment",
            "a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "The libcore crate in turn is a platform-agnostic subset of the std crate\nwhich makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions.",
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "Because of these properties no_std and libcore code can be used for any kind of\nbootstrapping (stage 0) code like bootloaders, firmware or kernels.",
            "As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions",
            "The libcore crate in turn is a platform-agnostic subset of the std crate"
          ]
        },
        {
          "title": "Rust Lang Items and no_std Guide",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/lang-items.html",
          "excerpts": [
            ")]\n#! [no_std]\n#!\n[no_main]\n\nextern crate libc;\nextern crate ",
            "#[panic_handler]\nfn panic_handler(_info: &PanicInfo) -> ! { intrinsics::abort() }",
            ". The marker is the attribute `#[lang = \"...\"]` and there are\nvarious different values of `...`, i.e. various different 'lang\nitems'."
          ]
        }
      ],
      "reasoning": "The field value centers on writing a portable, no_std Rust codebase that targets multiple MCUs/architectures. Core to this is using conditional compilation and trait-based abstraction to separate portability concerns from device specifics. Several excerpts explicitly describe how no_std is achieved in practice, typically via crate-level attributes and the core library. For instance, no_std is introduced as a crate attribute that switches from std to core and eliminates the standard library, which is the foundational step for portability in embedded contexts. This establishes the basis for writing code that runs on bare-metal targets without the standard library. Several excerpts outline how portability is achieved through conditional compilation via cfg attributes, which allow including or excluding code based on target architecture, OS, endianness, and atomic capabilities. Examples enumerate predicates like target_arch, target_os, target_pointer_width, target_endian, and target_has_atomic; these predicates enable writing architecture-specific modules that can be selected or omitted at compile time, supporting multi-architecture builds. The embedded-hal ecosystem and CI/build-matrix practices are cited as practical ways to maintain portability across MCUs by providing abstract trait interfaces (e.g., I2C, SPI, UART via embedded-hal) so code can be platform-agnostic, with concrete implementations supplied per MCU. Additional excerpts elaborate on how conditional compilation can leverage cfg and cfg_attr, enabling compilation-time branching and feature gating across platforms. There is also guidance on cross-target testing and building, including using target triples and cross-compilation workflows. Together, these excerpts form a cohesive narrative: to achieve portability in a no_std Rust codebase across multiple MCUs/architectures, you use conditional compilation (cfg, cfg_attr) to select architecture-specific code paths and layer an abstract HAL (embedded-hal) so the same higher-level logic can run on multiple targets, with CI/build matrices validating combinations of target triples and features. The most directly supportive parts discuss no_std foundations and the cfg-based portability strategy, while peripheral notes about CI and embedded-ecosystem tooling provide practical context for maintaining portability across real-world projects. The content directly supports the idea that portability hinges on conditional compilation and trait-based abstractions in a no_std setting, with explicit examples of the relevant cfg predicates and patterns.",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_observability",
      "citations": [
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "#[panic_handler] is used to define the behavior of panic! in #![no_std] applications.",
            "#[panic_handler]` is used to define the behavior of `panic!` in `#! [no_std]` applications. The `#[panic_handler]` attribute must be applied to a function with signature `fn(&PanicInfo) -> !` and such function must appear _once_ in the dependency graph of a binary / dylib / cdyli",
            "#! [no_std]",
            "    //",
            "fn panic(_info: &PanicInfo) -> ! {",
            "fn panic(_info: &PanicInfo) -> ! {",
            "    loop {}",
            "    loop {}",
            "}",
            "}",
            "```",
            "```",
            "`panic-halt` crate -- halt the thread on panic; messages are discarded:",
            "`panic-halt` crate -- halt the thread on panic; messages are discarded:",
            "```rust",
            "```rust",
            "#![no_std]",
            "extern crate panic_halt;"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "#! [no_std]",
            "}",
            "```"
          ]
        },
        {
          "title": "meyerzinn.tech post on running Rust code on RISC-V in QEMU",
          "url": "https://meyerzinn.tech/posts/2023/03/05/running-rust-code-on-risc-v-in-qemu/",
          "excerpts": [
            "#! [no_std]",
            "Add a `runner` to your `.cargo/config.toml` file:",
            "```\n# .cargo/config.toml\n\n# ... from before\n\n[target.riscv32imac-unknown-none-elf]\nrunner = \"\"\" qemu-system-riscv32\n  -cpu rv32\n  -machine virt\n  -m 150M\n  -s\n  -nographic\n  -bios \"\"\"\n\n```\n\nWe’ll add more flags as our kernel becomes more complete, but we’ll start with the basics:"
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: DMA Controllers",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-hal-dma-controllers-daf",
          "excerpts": [
            "#! [no_std]"
          ]
        },
        {
          "title": "Portability - Rust Embedded MB2 Discovery Book",
          "url": "https://docs.rust-embedded.org/discovery-mb2/06-hello-world/portability.html",
          "excerpts": [
            "#! [no_std]"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "    loop {}",
            "}",
            "```",
            "```",
            "```",
            "The panicking message is logged to the host using the semihosting technique. You may be able to find even more crates searching for the panic-handler keyword on ...",
            "A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the pani",
            "Some examples include:",
            "* [`panic-abort`](https://crates.io/crates/panic-abort) . A panic causes the abort instruction to be executed.",
            "* [`panic-halt`](https://crates.io/crates/panic-halt) . A panic causes the program, or the current thread, to halt by\n  entering an infinite loo",
            "* [`panic-semihosting`](https://crates.io/crates/panic-semihosting) . The panicking message is logged to the host using the\n  semihosting techniqu"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "    loop {}",
            "}",
            "}",
            "}",
            "extern crate panic_halt;"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "}",
            "}",
            "}",
            "```",
            "```",
            "extern crate panic_halt;"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "```"
          ]
        },
        {
          "title": "PSA for `std` Feature in `no_std` Libraries : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1hs6spy/psa_for_std_feature_in_no_std_libraries/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "Is it possible to enable a rust feature only in test? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/68618789/is-it-possible-to-enable-a-rust-feature-only-in-test",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The Embedded Rust Book - QEMU and no_std guidance",
          "url": "https://docs.rust-embedded.org/book/start/qemu.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Rust Bindgen no_std FFI and Bindgen Issues discussion",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1583",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Heapless and Rust Embedded: Portability and Multi-Target/Portability Aspects",
          "url": "http://github.com/rust-embedded/heapless",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "DMA Networking — Matt Keeter Blog",
          "url": "https://www.mattkeeter.com/blog/2023-10-31-dma/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "Rust Nomicon: Working with Unsafe",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/index.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Logging macros",
          "url": "https://defmt.ferrous-systems.com/macros",
          "excerpts": [
            "Logging is done using the error!, warn!, info!, debug! and trace! macros. There is also the println! macro that always prints the content."
          ]
        },
        {
          "title": "rust-embedded/nb",
          "url": "https://github.com/rust-embedded/nb",
          "excerpts": [
            "The WouldBlock error variant signals that the operation can't be completed right now and would need to block to complete. W",
            "or.html) is a special error in the sense that it's not\n*fatal*; the operation can still be completed by retrying again later.",
            "The ultimate goal of this crate is *code reuse*. With this crate you can\nwrite *core* I/O APIs that can then be adapted to operate in either blocking\nor non-blocking man"
          ]
        },
        {
          "title": "defmt (embedded logging and panic handling) - Source Summary",
          "url": "https://defmt.ferrous-systems.com/",
          "excerpts": [
            "This library can be added to an Embedded Rust application to provide an\nimplementation of `#[panic_handler]`. It can optionally route the\n`core::panic::PanicInfo` structure over RTT (using the `rtt_target` crate) or\nover defmt (using the `defmt` ",
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers.Se",
            "`defmt` achieves high performance using deferred formatting and string compression. Deferred formatting means that formatting is not done on the machine that's logging data but on a second machine.",
            "is library is a *logging transport* for `defmt` that sends data over\nSEGGER's RTT transport protocol. This is a good choice when using `probe-rs` because support is built-in to that\nrunner.",
            "\n\nThis library is a *logging transport* for defmt that sends data over\n*semihosting* calls (i.e. breakpoints that wake up your debugger). You should only use this when running firmware inside QEMU, because otherwise\nit's very slow.",
            "\n\nThe `defmt` crate runs on your microcontroller or other target device. It\nexports macros, like `info!` that libraries can use to emit logging messages",
            "er]`. It can optionally route the\n`core::panic::PanicInfo` structure over RTT (using the `rtt_target` crate) or\nover defmt (using the `defmt` crate)",
            "The defmt-print CLI program uses defmt-decoder to turn defmt log frames into human-readable Unicode text. You can use this if your log frames aren't coming via ...",
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers."
          ]
        },
        {
          "title": "defmt Repository",
          "url": "https://github.com/knurling-rs/defmt",
          "excerpts": [
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers."
          ]
        },
        {
          "title": "Semihosting - The Embedded Rust Book",
          "url": "https://doc.rust-lang.org/beta/embedded-book/start/semihosting.html",
          "excerpts": [
            "The cortex-m-semihosting crate provides an API to do semihosting operations on Cortex-M devices. The program below is the semihosting version of \"Hello, world!"
          ]
        },
        {
          "title": "CHANGELOG.md - knurling-rs/defmt",
          "url": "https://github.com/knurling-rs/defmt/blob/main/CHANGELOG.md",
          "excerpts": [
            "#350 panic-probe now uses defmt s Display2Format to log panic messages. In consequence, panic messages won't get truncated anymore. #355 Clarify the docs on ..."
          ]
        },
        {
          "title": "cortex-m-log - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cortex-m-log",
          "excerpts": [
            "Logging facilities for Cortex-M processors. Available features: Maintenance note: Please note that at the current moment I'm no longer working with cortex ..."
          ]
        },
        {
          "title": "cortex_m_semihosting - Rust",
          "url": "https://docs.rs/cortex-m-semihosting",
          "excerpts": [
            "Semihosting operations are very slow. Like, each WRITE operation can take hundreds of milliseconds. §Example. §Using hio::hstdout. This example will demonstrate ..."
          ]
        },
        {
          "title": "embedded_hal_nb - Rust",
          "url": "https://docs.golemparts.com/rppal/dev/embedded_hal_nb/index.html",
          "excerpts": [
            "Non-blocking Hardware Abstraction Layer (HAL) traits for embedded systems, using the nb crate. The embedded-hal-nb traits make use of the nb crate (please ..."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Result<T, E> is the type used for returning and propagating errors. It is an enum with the variants, Ok(T) , representing success and containing a value, and ..."
          ]
        },
        {
          "title": "How to implement timeouts in an embedded-hal-based ...",
          "url": "https://users.rust-lang.org/t/how-to-implement-timeouts-in-an-embedded-hal-based-driver/36257",
          "excerpts": [
            "Dec 29, 2019 — I want to implement timeouts in my embedded-hal-based driver. For example, it will send request to uart, then wait for response with timeout."
          ]
        },
        {
          "title": "nb is incompatible with async/await which is now in stable",
          "url": "https://github.com/rust-embedded/nb/issues/19",
          "excerpts": [
            "However async/await is currently not available in no_std due to the implicit use of TLS. Can we come up with some workaround might would us to ..."
          ]
        },
        {
          "title": "Need for a Generic Instant/Time/Duration · Issue #122 · rust ...",
          "url": "https://github.com/rust-embedded/embedded-hal/issues/122",
          "excerpts": [
            "Jan 28, 2019 — The std time, duration is too big overhead for an embedded system. I'm curious what you mean by core::time::Duration having too much of an overhead?",
            "On an embedded device (most #[no_std] applicationd) you often bring your own clock. This is typically implemented by registering a SysTick ..."
          ]
        },
        {
          "title": "Why do both Option & Result exist in Rust? : r/learnrust",
          "url": "https://www.reddit.com/r/learnrust/comments/13tvpy6/why_do_both_option_result_exist_in_rust/",
          "excerpts": [
            "Option has different semantics than Result. It signals that something is optional. If it's optional then its absence is not an error. Hence None ..."
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat"
          ]
        },
        {
          "title": "probe-rs and cargo-embed - Comprehensive Rust - Google",
          "url": "https://google.github.io/comprehensive-rust/bare-metal/microcontrollers/probe-rs.html",
          "excerpts": [
            "cargo-embed is a cargo subcommand to build and flash binaries, log RTT (Real Time Transfers) output and connect GDB. It's configured by an Embed.toml file in ..."
          ]
        },
        {
          "title": "Cannot Debug or Attach to STM32F4 Using Probe-RS",
          "url": "https://users.rust-lang.org/t/cannot-debug-or-attach-to-stm32f4-using-probe-rs/129729",
          "excerpts": [
            "May 19, 2025 — I am able to flash and erase and program the chip using cargo embed, but attempting to step through the instructions using probe-rs does not work."
          ]
        },
        {
          "title": "Rust Tools and Resources for Embedded - EEVblog",
          "url": "https://www.eevblog.com/forum/microcontrollers/rust-tools-and-resources-for-embedded/",
          "excerpts": [
            "cargo-flash: downloads the code to the MCU, starts it, and returns cargo-embed: downloads the code to the MCU, starts it, open RTT terminal ..."
          ]
        },
        {
          "title": "default.toml - probe-rs/cargo-embed - GitHub",
          "url": "https://github.com/probe-rs/cargo-embed/blob/master/src/config/default.toml",
          "excerpts": [
            "Jan 14, 2023 — The target handles RTT outputs that won't fit in the buffer. This can be overridden per-channel. If left unset, the firmware will determine the default for ..."
          ]
        },
        {
          "title": "defmt-decoder - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/defmt-decoder",
          "excerpts": [
            "This library is for decoding defmt frames into formatted strings. It is used by defmt-print and other tools. MSRV. The minimum supported Rust ..."
          ]
        },
        {
          "title": "Running hardware-in-the-loop tests on GitHub Actions",
          "url": "https://ferrous-systems.com/blog/gha-hil-tests/",
          "excerpts": [
            "This is the third post in our \"embedded Rust testing\" series. This post covers how to run a hardware testsuite based on defmt-test on real ..."
          ]
        },
        {
          "title": "Using GDB and defmt to debug embedded programs",
          "url": "https://ferrous-systems.com/blog/gdb-and-defmt/",
          "excerpts": [
            "May 4, 2021 — This post covers the process of setting up debugging for our app-template using an external GDB server program without losing the defmt logs."
          ]
        },
        {
          "title": "Debugger",
          "url": "https://probe.rs/docs/tools/debugger/",
          "excerpts": [
            "The probe-rs VS Code extension uses the Microsoft Debug Adapter Protocol to implement an interactive debugging experience between VS Code and a probe-rs target."
          ]
        },
        {
          "title": "Testing a no_std crate with QEMU and defmt-test? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/14bb0db/testing_a_no_std_crate_with_qemu_and_defmttest/",
          "excerpts": [
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ...",
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value describes idiomatic error handling in no_std Rust, emphasizing signaling failures with Result and Option, nonblocking I/O with nb, and observability using defmt and RTT/panic tooling rather than panicking for recoverable errors. The most directly supporting excerpts are those that lay out no_std panic handling conventions and the core error signaling primitives. For example, the Rustonomicon explains how to define a custom #[panic_handler] in a no_std context and shows how panics are handled differently when there is no standard output, including using panic-halt or panic-semihosting as different strategies. This directly informs the recommended approach of avoiding panics for recoverable errors and instead using explicit error enums and the Result/Option types tied to core, which is the essence of idiomatic no_std error handling. The Embedded Rust Book and The Embedded Rust Book's panicking sections reinforce the same pattern: no_std environments require explicit panic strategies and careful design of error handling to work without std, often using the alloc-free or core facilities and sometimes leveraging semihosting or RTT logging for debugging. The nb crate is frequently mentioned as a standard approach to non-blocking I/O in no_std contexts, enabling WouldBlock-style retries rather than blocking, which aligns with the idea of nonblocking error signaling in constrained devices. The defmt and RTT tooling sections show how to observe and decode runtime information efficiently on embedded devices. They fill the observability angle by providing compact, host-side formatting of logs, which complements the no_std error signaling by giving a practical debugging path when errors occur. The additional material on no_std basics (Embedded Book sections about #![no_std], core/libcore, and memory layout) provides the foundational context that error signaling and observability must work within. In short, these excerpts collectively support the field value by giving a precise blueprint for error signaling with core::Result/Option in no_std, nonblocking error semantics via nb, and practical observability tooling (defmt, RTT, panic strategies) used in embedded systems. The ordering reflects whether the excerpt directly prescribes the error signaling pattern (highest), then the no_std ambient (mid), and finally observability tooling (defmt/RTT) (lower but still relevant).",
      "confidence": "high"
    },
    {
      "field": "memory_mapped_io_and_register_abstraction",
      "citations": [
        {
          "title": "read_volatile - Rust standard library",
          "url": "https://doc.rust-lang.org/std/ptr/fn.read_volatile.html",
          "excerpts": [
            "Performs a volatile read of the value from `src` without moving it. This\nleaves the memory in `src` unchanged. Volatile operations are intended to act on I/O memory, and are guaranteed\nto not be elided or reordered by the compiler across other volatile\noperati"
          ]
        },
        {
          "title": "write_volatile in std::ptr - Rust",
          "url": "https://doc.rust-lang.org/beta/std/ptr/fn.write_volatile.html",
          "excerpts": [
            "Performs a volatile write of a memory location with the given value without reading or dropping the old value.",
            "`dst` must be [valid](index.html \"mod std::ptr\") for writes."
          ]
        },
        {
          "title": "Volatile and sensitive memory - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188",
          "excerpts": [
            "In Rust, there is no volatile modifier. Instead, there are unstable “volatile read” and “volatile write” primitives."
          ]
        },
        {
          "title": "Memory-mapped Registers - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/registers.html",
          "excerpts": [
            "Embedded systems can only get so far by executing normal Rust code and moving data around in RAM. If we want to get any information into or out of our system (be that blinking an LED, detecting a button press or communicating with an off-chip peripheral on some sort of bus) we're going to have to dip into the world of Peripherals and their 'memory mapped registers'.",
            "the access functions for our register fields take a closure, rather than a numeric argument.",
            "Where the auto-generated code isn't able to determine that all possible arguments to a particular accessor function are valid (for example, if the SVD defines the register as 32-bit but doesn't say if some of those 32-bit values have a special meaning), then the function is marked as `unsafe` .",
            "The `read()` function returns an object which gives read-only access to the various sub-fields within this register, as defined by the manufacturer's SVD file for this chip.",
            "Memory Mapped Registers. Embedded systems can only get so far by executing normal Rust code and moving data around in RAM. If we want to get any information ..."
          ]
        },
        {
          "title": "PACs and svd2rust",
          "url": "https://rust-training.ferrous-systems.com/latest/book/pac-svd2rust",
          "excerpts": [
            "Introduction. The Peripheral Access Crate crate sits near the bottom of the 'stack'. It provides access to the memory-mapped peripherals in your MCU.",
            "Each Register struct has read() , write() and modify() methods; Each Register also has a Read Type ( R ) and a Write Type ( W ). Those Read/Write Types give ... * Each _Register_ `struct` has `read()` , `write()` and `modify()` methods\n",
            "The `write()` method takes a closure, which is given a special 'proxy' object, with methods for each _Fiel",
            "The `modify()` method gives you bo",
            "```rust\nlet p = nrf52840_pac::Peripherals::take().unwrap();\n// Reading the 'baudrate' bitfield from the 'baudrate' register\nlet baudrate = p.UARTE1.baudrate().read().baudrate();\n// Modifying multiple fields in one go\np.UARTE1.inten().modify(|_r, w| {\n    w.cts().enabled();\n    w.ncts().enabled();\n    w.rxrdy().enabled();\n    w    \n});\n```",
            "A CMSIS-SVD (or just SVD) file is an XML description of all the peripherals, registers and fields on an MCU. We can use svd2rust to turn this into a Peripheral ..."
          ]
        },
        {
          "title": "The GPIO war: Macro bunkers for typestate explosions, part 1",
          "url": "https://www.reddit.com/r/rust/comments/ma0vyk/the_gpio_war_macro_bunkers_for_typestate/",
          "excerpts": [
            "... Rust, this time on writing the GPIO module for an embedded HAL crate. There are many details here that only apply for the bare metal world ..."
          ]
        },
        {
          "title": "core::cell::RefCell - Rust",
          "url": "https://doc.rust-lang.org/core/cell/struct.RefCell.html",
          "excerpts": [
            "A mutable memory location with dynamically checked borrow rules",
            "pub struct RefCell<T: ? Sized > { /* private fields */ }",
            "See the [module-level documentation](index.html \"mod core::cell\") for more."
          ]
        },
        {
          "title": "UnsafeCell - std::cell (Rust documentation)",
          "url": "https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html",
          "excerpts": [
            "The core primitive for interior mutability in Rust. If you have a reference `&T` , then normally in Rust the compiler performs optimizations based on\nthe knowledge that `&T` points to immutable data. Mutating that data, for example through an\nalias or by transmuting a `&T` into a `&mut T` , is considered undefined behavior. `UnsafeCell<T>` opts-out of the immutability guarantee for `&T` : a shared reference `&UnsafeCell<T>` may point to data that is being mutated. This is called “interior mutability”."
          ]
        },
        {
          "title": "Rust core::cell UnsafeCell and interior mutability",
          "url": "https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html",
          "excerpts": [
            "The core primitive for interior mutability in Rust. If you have a reference `&T` , then normally in Rust the compiler performs optimizations based on\nthe knowledge that `&T` points to immutable data. Mutating that data, for example through an\nalias or by transmuting a `&T` into a `&mut T` , is considered undefined behavior. `UnsafeCell<T>` opts-out of the immutability guarantee for `&T` : a shared reference `&UnsafeCell<T>` may point to data that is being mutated. This is called “interior mutability”.",
            "UnsafeCell` is a wrapper\ndesigned to have a special interaction with _shared_ accesses ( _i.e._ , through an `&UnsafeCell<_>` reference); there is no magic whatsoever when dealing with _exclusive_ accesses ( _e.g._ , through a `&mut UnsafeCell<_>` ): neither the cell nor the wrapped value\nmay be aliased for the duration of th",
            "All access to the inner value through `&UnsafeCell<T>` requires `unsafe` code.",
            "UnsafeCell<T>` has the same in-memory representation as its inner type `T`",
            "The core primitive for interior mutability in Rust. If you have a reference `&T` , then normally in Rust the compiler performs optimizations based on\nthe knowledge that `&T` points to immutable data."
          ]
        }
      ],
      "reasoning": "The fine-grained field value describes how interacting with hardware via memory-mapped I/O in a no_std setting requires volatile access for correct semantics and how that access is encapsulated by higher-level abstractions such as Peripheral Access Crates (generated by svd2rust) and interior mutability primitives like UnsafeCell. The most directly relevant excerpts state the exact volatile primitives and their guarantees: volatile reads and writes in core::ptr are defined as operations that must not be elided or reordered, and they require unsafe usage due to potential memory-safety hazards. This establishes the foundational MMIO mechanism in no_std contexts. Further, the documentation on read_volatile and write_volatile emphasizes the constraints around these operations, including the safety caveats (they are not atomic and do not prevent data races in concurrent contexts). This mapping shows how a typical no_std MMIO pattern is implemented: use read_volatile and write_volatile for direct hardware access, then wrap these operations in safe abstractions when possible to avoid exposing unsafe internals throughout the codebase. The embedded MMIO pattern is then realized through Peripheral Access Crates generated by svd2rust, which provide type-safe APIs (read, write, modify) for registers and bitfields, reducing the need to perform raw volatile operations directly in application code. The excerpts describing Memory-mapped Registers in The Embedded Rust Book and Cortex/M-class MMIO sections illustrate how registers are modeled as typed blocks, with ReadWrite/ReadOnly/WriteOnly abstractions that map to hardware capabilities, and how the memory layout and linker memory maps (memory.x) relate to the MMIO region placement. The UnsafeCell excerpts explain the interior mutability primitive that underpins safe interior mutation patterns in no_std contexts, enabling safe abstractions to mutate shared hardware state without violating Rust's aliasing rules. The discussion of PACs and svd2rust clarifies how hardware-peripheral access becomes safe and ergonomic in code paths that manipulate hardware registers, with typed proxies and closure-based modify() methods that capture the read-modify-write semantics safely. Finally, the references to typestate programming and state-machine modeling in embedded contexts illustrate how higher-level safety guarantees can prevent invalid sequences of MMIO operations (e.g., a pin or peripheral in an incorrect mode) at compile time, tying together low-level volatile access, safe abstractions, and domain-specific state. Collectively, these excerpts support the field value by demonstrating (a) why volatile access is necessary in MMIO, (b) how to model MMIO safely in no_std, (c) how PACs and svd2rust provide safer abstractions over registers, and (d) how interior mutability and typestate patterns contribute to safe, zero-cost abstractions for hardware interaction.",
      "confidence": "high"
    },
    {
      "field": "learning_curriculum_and_diagram_strategy.structured_curriculum",
      "citations": [
        {
          "title": "What is the rust core crate??",
          "url": "https://www.reddit.com/r/rust/comments/bpmy21/what_is_the_rust_core_crate/",
          "excerpts": [
            "The reason for both is that std is everything the language provides, but core is the subset of that which doesn't require features from the ..."
          ]
        },
        {
          "title": "What's the difference of the module core and std",
          "url": "https://users.rust-lang.org/t/whats-the-difference-of-the-module-core-and-std/2923",
          "excerpts": [
            "Sep 19, 2015 — Core should be self-contained. std depends on core , and a lot of other stuff, to provide a kind of \"facade\" to the end user."
          ]
        },
        {
          "title": "Help enabling `no-std` feature in a crate - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/help-enabling-no-std-feature-in-a-crate/61192",
          "excerpts": [
            "I want enable a feature in my crate for compile in a no-std environment, for this in the Cargo.toml I have: [dependencies] num = { version = \"0.4\", default- ..."
          ]
        },
        {
          "title": "Clarify std vs no-std · Issue #148 · esp-rs/book",
          "url": "https://github.com/esp-rs/book/issues/148",
          "excerpts": [
            "Mar 13, 2024 — The book currently says: When You Might Want to Use the Core Library (no_std) Small memory footprint: If your embedded system has limited ..."
          ]
        },
        {
          "title": "cortex_m - Rust",
          "url": "https://docs.rs/cortex-m",
          "excerpts": [
            "Low level access to Cortex-M processors. This crate provides: Access to core peripherals like NVIC, SCB and SysTick. Access to core registers like CONTROL, ..."
          ]
        },
        {
          "title": "The Rust Alloc crate documentation",
          "url": "https://doc.rust-lang.org/alloc/",
          "excerpts": [
            "). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead."
          ]
        },
        {
          "title": "no global memory allocator found but one is required",
          "url": "https://stackoverflow.com/questions/74012369/no-global-memory-allocator-found-but-one-is-required-link-to-std-or-add-glob",
          "excerpts": [
            "If you link with alloc you need to have a global allocator. That is usually provided by std, but if you omit the std crate then you need to provide it yourself."
          ]
        },
        {
          "title": "Similar items in core and std",
          "url": "https://users.rust-lang.org/t/similar-items-in-core-and-std/60167",
          "excerpts": [
            "May 23, 2021 — As a beginner to Rust, I am a bit confused by same (similar ?) items I find in the core and std libraries. For example there is core::iter::iterator and std:: ..."
          ]
        },
        {
          "title": "cortex-m - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cortex-m",
          "excerpts": [
            "This crate is guaranteed to compile on stable Rust 1.38 and up. It might compile with older versions but that may change in any new patch release."
          ]
        },
        {
          "title": "Flowcharts – Basic Syntax",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/flowchart.html",
          "excerpts": [
            "May 22, 2025 — The Mermaid code defines how nodes and edges are made and accommodates different arrow types, multi-directional arrows, and any linking to and ..."
          ]
        },
        {
          "title": "Examples",
          "url": "https://mermaid.js.org/syntax/examples.html",
          "excerpts": [
            "Examples ​. This page contains a collection of examples of diagrams and charts that can be created through mermaid and its myriad applications."
          ]
        },
        {
          "title": "mermaid-js/mermaid: Generation of diagrams like ...",
          "url": "https://github.com/mermaid-js/mermaid",
          "excerpts": [
            "Mermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams."
          ]
        },
        {
          "title": "Mermaid Documentation and Mermaid OSS",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/sequenceDiagram.html",
          "excerpts": [
            "Diagram Syntax"
          ]
        },
        {
          "title": "Class diagrams | Mermaid",
          "url": "https://mermaid.js.org/syntax/classDiagram.html",
          "excerpts": [
            "A class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system."
          ]
        },
        {
          "title": "Mermaid | Diagramming and charting tool",
          "url": "https://mermaid.js.org/",
          "excerpts": [
            "Missing: classDiagram annotations"
          ]
        }
      ],
      "reasoning": "The finegrained field value describes a comprehensive, structured curriculum focused on idiomatic no_std Rust for systems programming, including many modules, examples, and diagrams. Excerpts that discuss Rust's no_std environment, the relationship between core and std, and guidance on enabling or understanding no_std directly inform the feasibility and structure of such a curriculum. For example, excerpts elucidating what the core crate is and how it relates to std help define the foundational constraints of a no_std curriculum, clarifying prerequisites like using core instead of std and the absence of the standard library. References that explain how the core and std crates relate, and how to enable no_std features, map to the prerequisites, module sequencing, and engineering decisions that such a curriculum would need to cover. Excerpts mentioning Cortex-M, embedded contexts, and allocator considerations illuminate concrete technical topics that would appear as modules or examples within the curriculum, including memory management, panic handling, and allocator configuration in a no_std setting. Discussions about the alloc crate, global allocators, and portability across targets give concrete content scaffolding for modules about memory, infrastructure, and cross-platform constraints. Additional excerpts addressing tooling, compilation, and core infrastructure (e.g., no_std maintenance, core vs std semantics, and the role of cortex-m crates) help frame the tooling and ecosystem context the curriculum would rely on. While several excerpts primarily cover Mermaid diagrams and diagram syntax, those references provide tangential support for the curriculum's requirement to include diagrams; the core substance for the curriculum itself remains grounded in Rust-no_std concepts and their practical implications, which these excerpts collectively illuminate. In summary, the most relevant materials reinforce foundational Rust no_std concepts, the core vs std relationship, and practical patterns (alloc, panic handling, concurrency, and peripheral access) that would anchor the proposed curriculum's modules and examples. The less directly relevant excerpts—though still informative—pertain mainly to Mermaid diagram topics, which would supplement but not define the curriculum's technical core.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_and_allocators",
      "citations": [
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "SECTIONS\n{\n  .vector_table ORIGIN(FLASH) :\n  {\n    /* First entry: initial Stack Pointer value */\n    LONG(ORIGIN(RAM) + LENGTH(RAM));\n\n    /* Second entry: reset vector */\n    KEEP(*(.vector_table.reset_vector));\n  } > FLASH",
            "  {",
            "  {",
            "  {",
            "    KEEP(*(.vector_table.reset_vector));",
            "}",
            "}"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "/* Linker script for the STM32F303VCT6 */\nMEMORY\n{\n/* NOTE 1 K = 1 KiBi = 1024 bytes */\nFLASH : ORIGIN = 0x08000000, LENGTH = 256K\nRAM : ORIGIN = 0x20000000, LENGTH = 40K\n}\nNOTE : If you for some reason changed the\nmemory.x file after you had made\nthe first build of a specific build target, then do\ncargo clean before\ncargo build , because\ncargo build may not track updates of\nmemory.x .",
            "FLASH : ORIGIN = 0x08000000, LENGTH = 256K",
            "RAM : ORIGIN = 0x20000000, LENGTH = 40K",
            "}"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Collections - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/collections/",
          "excerpts": [
            "\n\nTo be able to use any collection you'll first need use the `global_allocator`\nattribute to declare the global allocator your program will use. It's required\nthat the allocator you select implements the [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) trait.",
            "\n\nextern crate alloc;",
            "\n#! [feature(alloc_error_handler)]",
            "\n\n#[alloc_error_handler]"
          ]
        },
        {
          "title": "Std Embedded Rust - Tim Hut",
          "url": "https://blog.timhutt.co.uk/std-embedded-rust/index.html",
          "excerpts": [
            "Apr 19, 2021 — Conveniently there's an example at examples/allocator.rs that we can copy & paste from: #![no_main] #![no_std] #![feature(alloc_error_handler)] ...",
            "Apr 19, 2021 — build-std can be constrained to build only core or core and alloc but by default it builds core , alloc and std which is what we want."
          ]
        },
        {
          "title": "Buddy System Allocator - GitHub (rcore-os/buddy_system_allocator)",
          "url": "https://github.com/rcore-os/buddy_system_allocator",
          "excerpts": [
            "To use buddy\\_system\\_allocator for global allocato"
          ]
        },
        {
          "title": "Memory management - Lib.rs",
          "url": "https://lib.rs/memory-management",
          "excerpts": [
            "Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "slaballoc - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slaballoc",
          "excerpts": [
            "Sep 29, 2024 — This crate provides a lockless no_std compatible slab allocator, for fixed-size allocations. This slab allocator takes a fixed-size block of ..."
          ]
        },
        {
          "title": "slab_allocator_rs - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slab_allocator_rs",
          "excerpts": [
            "Jan 7, 2023 — Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "bbqueue - Rust",
          "url": "https://docs.rs/bbqueue/latest/bbqueue/",
          "excerpts": [
            "BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded systems. While Circular/Ring Buffers allow you to send data ..."
          ]
        }
      ],
      "reasoning": "Directly supporting the memory_management_and_allocators field value: The memory layout excerpts explain how the linker script defines RAM and where the stack pointer is placed (vector_table and ORIGIN(RAM) + LENGTH(RAM) conventions). The vector_table mechanism and _stext/_text mappings illustrate how the startup sequence determines the initial stack pointer location in RAM. Excerpts from the Embedded Rust Book and Cortex-M/embedded docs explain no_std constraints, the need for a linker memory.x to declare RAM/FLASH regions, and how .text/.rodata/.data/.bss sections map to FLASH/RAM. They also discuss enabling heap-based allocation in no_std via a global allocator and an alloc_error_handler, including examples of various allocator crates (linked_list_allocator, buddy_system_allocator, bumpalo, slaballoc, etc.) and the necessity for a global_allocator attribute and a dedicated allocation error handler. Together, these excerpts substantiate the main field value: stack management in no_std environments, the role of linker scripts in memory layout, and the patterns for enabling allocators when a heap is needed. The ordering places the strongest, most specific match to the field (direct memory layout/linker-script references and stack pointer setup) before broader allocator guidance (global_allocator, alloc_error_handler, and allocators), which in turn is followed by practical allocator options and trade-offs.",
      "confidence": "high"
    },
    {
      "field": "learning_curriculum_and_diagram_strategy.diagram_taxonomy",
      "citations": [
        {
          "title": "Flowcharts – Basic Syntax",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/flowchart.html",
          "excerpts": [
            "May 22, 2025 — The Mermaid code defines how nodes and edges are made and accommodates different arrow types, multi-directional arrows, and any linking to and ..."
          ]
        },
        {
          "title": "Mermaid Documentation and Mermaid OSS",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/sequenceDiagram.html",
          "excerpts": [
            "Diagram Syntax"
          ]
        },
        {
          "title": "State diagrams",
          "url": "https://mermaid.js.org/syntax/stateDiagram.html",
          "excerpts": [
            "There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it ..."
          ]
        },
        {
          "title": "Class diagrams | Mermaid",
          "url": "https://mermaid.js.org/syntax/classDiagram.html",
          "excerpts": [
            "A class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system."
          ]
        },
        {
          "title": "mermaid-js/mermaid: Generation of diagrams like ...",
          "url": "https://github.com/mermaid-js/mermaid",
          "excerpts": [
            "Mermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams."
          ]
        },
        {
          "title": "Examples",
          "url": "https://mermaid.js.org/syntax/examples.html",
          "excerpts": [
            "Examples ​. This page contains a collection of examples of diagrams and charts that can be created through mermaid and its myriad applications."
          ]
        },
        {
          "title": "Mermaid Config Schema",
          "url": "http://mermaid.js.org/config/schema-docs/config.html",
          "excerpts": [
            "Create diagrams and visualizations using text and code."
          ]
        },
        {
          "title": "Mermaid | Diagramming and charting tool",
          "url": "https://mermaid.js.org/",
          "excerpts": [
            "Missing: classDiagram annotations"
          ]
        }
      ],
      "reasoning": "The finegrained field value outlines a uniform diagramming strategy using Mermaid.js, including dedicated diagram types (flowcharts, sequence diagrams, state diagrams, and class diagrams) and concrete templates. Excerpts that describe basic Mermaid flowchart syntax demonstrate how sequential processes and decisions are represented, which directly supports the idea of using flowcharts as a base building block in the taxonomy. Excerpts detailing sequence diagram syntax illustrate how interactions over time between components are modeled, aligning with the use of time-ordered diagrams in the taxonomy. Excerpts about state diagrams show how to model state machines, which matches the stateDiagram-v2 category in the taxonomy. Excerpts on class diagrams discuss static structure representations of types, traits, and modules, which corresponds to the classDiagram portion of the taxonomy. Additional excerpts discuss the Mermaid project ecosystem and documentation, which underpins the practical tooling and conventions for implementing the taxonomy in real-world teaching materials. A worked list of examples and templates further corroborates how standardized diagrams can be embedded alongside explanations, fulfilling the \"Template\" and \"Conventions and Best Practices\" aspects of the taxonomy. The combined information from these excerpts directly supports the concept of standardizing diagram usage across multiple diagram types with clear templates and conventions, as described in the finegrained field value.",
      "confidence": "high"
    },
    {
      "field": "executive_summary.key_highlights",
      "citations": [
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "The libcore crate in turn is a platform-agnostic subset of the std crate\nwhich makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions.",
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat",
            "a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "which makes no assumptions about the system the program will run on.",
            "Because of these properties no_std and libcore code can be used for any kind of\nbootstrapping (stage 0) code like bootloaders, firmware or kernels."
          ]
        }
      ],
      "reasoning": "The no_std paradigm centers on using a platform-agnostic core subset in place of the standard library, which is why a key piece of information is that the core (libcore) provides a subset of std APIs and is tailored for no_std environments, including processor-feature access and language primitives. This establishes the architectural constraint that no_std crates rely on a minimal runtime and do not assume the presence of the standard library. Relatedly, the explicit statement that a crate links to the core-crate instead of std-by-default reinforces the no_std boundary and clarifies crate-level configuration under no_std. Additionally, framing no_std as compatible with a crate-level attribute that selects core over std further demonstrates how projects declare and enforce the no_std environment. Finally, noting that no_std/no-std environments can be leveraged for bootstrapping tasks (like bootloaders or firmware) helps situate where these constraints are particularly relevant in practical systems programming, even though it is a broader consequence rather than a direct implementation detail. Taken together, these excerpts collectively support the finegrained field value by confirming the core architectural constraints, configuration mechanisms, and practical bootstrapping implications of no_std in embedded systems programming.\n",
      "confidence": "medium"
    },
    {
      "field": "executive_summary.overview",
      "citations": [
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat",
            "a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "The libcore crate in turn is a platform-agnostic subset of the std crate\nwhich makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions.",
            "Because of these properties no_std and libcore code can be used for any kind of\nbootstrapping (stage 0) code like bootloaders, firmware or kernels.",
            "which makes no assumptions about the system the program will run on."
          ]
        }
      ],
      "reasoning": "The field describes idiomatic no_std Rust as a specialized discipline for environments without the standard library, relying on core, a platform-agnostic subset of std, and emphasizing absence of OS features like threading and heap allocation. The most direct evidence is that no_std crates link to the core crate instead of std, and libcore provides a platform-agnostic subset with primitive language features and processor access APIs. This precisely aligns with the claim that the ecosystem centers on core rather than std and that no_std eliminates typical OS-dependent capabilities. Additional support notes that libcore is platform-agnostic and exposes primitives such as floats, strings, and slices, and also APIs for atomic operations and SIMD, which underpins the constrained environment. Further corroboration comes from statements that no_std and libcore enable bootstrapping code such as bootloaders, firmware, or kernels, illustrating the intended use in bare-metal or constrained contexts. The broader claim that the ecosystem emphasizes zero-cost abstractions, safety, and concurrency within such constraints is consistent with mentions of hardware interaction, memory management considerations, and hardware abstraction layers like embedded-hal, along with PACs and RTIC/Embassy frameworks that exist specifically for constrained environments. The least direct but still relevant support is the notion that these constraints mean the system must operate without OS features and explicitly manage resources, which is implied by phrases about memory allocation decisions, panic handling, and entry point considerations in a no_std setting. Taken together, these excerpts collectively substantiate the field value about idiomatic no_std Rust programming being tailored for constrained environments using core, without std, and with specialized tooling for hardware.\n",
      "confidence": "high"
    },
    {
      "field": "foundational_concepts_and_project_setup",
      "citations": [
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "#[panic_handler] is used to define the behavior of panic! in #![no_std] applications.",
            "#[panic_handler]` is used to define the behavior of `panic!` in `#! [no_std]` applications. The `#[panic_handler]` attribute must be applied to a function with signature `fn(&PanicInfo) -> !` and such function must appear _once_ in the dependency graph of a binary / dylib / cdyli"
          ]
        }
      ],
      "reasoning": "- The most relevant excerpt states that no_std Rust uses core as the foundation, with alloc optionally available when a global allocator is provided, and emphasizes the crate-level attributes #![no_std] and #![no_main] to signal a bare-metal context and a non-standard entry model. It also points to architecture-specific runtimes (e.g., Cortex-M, RISC-V) for startup and entry, which directly supports the idea of a no_std workflow that replaces the standard runtime with a minimal, architecture-tailored startup. This excerpt directly underpins the central premise of writing idiomatic Rust in a no_std context by detailing the essential foundation (core vs std) and the need to avoid the standard library in bare-metal programming. It aligns with the field value's emphasis on no_std as the baseline and the optional inclusion of alloc behind an allocator, which is a core axis of idiomatic no_std Rust in embedded systems.\n- The second excerpt focuses on panic handling in no_std contexts, describing the role of a panic_handler function with the exact required signature and how different panic strategies (panic_semihosting, panic_halt, panic_abort, etc.) can be chosen depending on dev vs. release, and how a single panic handler must exist in the dependency graph. This directly supports the field value's guidance on how to handle panics idiomatically in a no_std environment where std::panic and unwinding are not available, which is a key part of writing robust no_std Rust.\n- The third excerpt explicitly documents the Cortex-M runtime and the requirement to designate an entry point with no_std/no_main patterns (via cortex-m-rt) and shows the typical entry-point pattern in embedded Rust, illustrating how the runtime is substituted in no_std contexts. This reinforces the field value's claim about architecture-specific runtimes and the absence of the usual main entry in bare-metal contexts, providing concrete guidance on how an idiomatic no_std program starts execution on Cortex-M devices. This complements the no_std foundation by illustrating the actual entry-point mechanism and startup flow that replaces the standard Rust runtime.\n- The combination of these excerpts gives a coherent picture: no_std pivots on core as the base, optional alloc with a global allocator, no_main for a custom entry, architecture-specific runtimes for startup, and a defined panic_handler for controlled error handling. Together they map closely to the field value's description of idiomatic no_std Rust in systems programming, including the need to manage memory (alloc), entry points (no_main), startup/runtime (cortex-m-rt or riscv-rt), and panic semantics in a constrained environment.",
      "confidence": "high"
    },
    {
      "field": "memory_management_and_allocators.memory_allocator_comparison",
      "citations": [
        {
          "title": "Collections - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/collections/",
          "excerpts": [
            "\n\nTo be able to use any collection you'll first need use the `global_allocator`\nattribute to declare the global allocator your program will use. It's required\nthat the allocator you select implements the [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) trait.",
            "\n\nextern crate alloc;",
            "\n#! [feature(alloc_error_handler)]",
            "\n\n#[alloc_error_handler]"
          ]
        },
        {
          "title": "Memory management - Lib.rs",
          "url": "https://lib.rs/memory-management",
          "excerpts": [
            "Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "slaballoc - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slaballoc",
          "excerpts": [
            "Sep 29, 2024 — This crate provides a lockless no_std compatible slab allocator, for fixed-size allocations. This slab allocator takes a fixed-size block of ..."
          ]
        },
        {
          "title": "slab_allocator_rs - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slab_allocator_rs",
          "excerpts": [
            "Jan 7, 2023 — Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "bbqueue - Rust",
          "url": "https://docs.rs/bbqueue/latest/bbqueue/",
          "excerpts": [
            "BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded systems. While Circular/Ring Buffers allow you to send data ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value describes how, in a no_std environment, dynamic memory allocation is achieved or constrained, including the use of the alloc crate, a global allocator, and various allocator implementations (e.g., linked_list_allocator, buddy_system_allocator, bump allocators like bumpalo, slab allocators like slaballoc), as well as the use of fixed-capacity collections without a heap. Excerpts that explicitly discuss the alloc crate, the GlobalAlloc trait, the global allocator attribute, and alloc_error_handler provide the core mechanism by which dynamic allocation is enabled or managed in no_std contexts. They also mention how to wire the allocator into a no_std binary and handle OOM, which are essential to understanding memory management in constrained environments. Excerpts describing specific allocators (slab allocators, buddy systems, and bump allocators) illustrate concrete trade-offs and usage in practice, aligning directly with the comparison/selection aspect of the field value. Excerpts mentioning concrete crates (slaballoc, buddy_system_allocator, linked_list_allocator) give practical implementation options that flesh out how no_std memory management can be realized in real projects. While some excerpts discuss memory layout or build metadata, their content supports the surrounding allocator discussion by framing the no_std context in which allocators operate. Taken together, these excerpts directly support the assertion that no_std typically lacks a heap unless an allocator is provided, and that there are multiple strategies and crates to enable and manage dynamic memory, each with distinct trade-offs.",
      "confidence": "high"
    },
    {
      "field": "memory_management_and_allocators.stack_memory_management",
      "citations": [
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "SECTIONS\n{\n  .vector_table ORIGIN(FLASH) :\n  {\n    /* First entry: initial Stack Pointer value */\n    LONG(ORIGIN(RAM) + LENGTH(RAM));\n\n    /* Second entry: reset vector */\n    KEEP(*(.vector_table.reset_vector));\n  } > FLASH",
            "    KEEP(*(.vector_table.reset_vector));",
            "}",
            "}"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "/* Linker script for the STM32F303VCT6 */\nMEMORY\n{\n/* NOTE 1 K = 1 KiBi = 1024 bytes */\nFLASH : ORIGIN = 0x08000000, LENGTH = 256K\nRAM : ORIGIN = 0x20000000, LENGTH = 40K\n}\nNOTE : If you for some reason changed the\nmemory.x file after you had made\nthe first build of a specific build target, then do\ncargo clean before\ncargo build , because\ncargo build may not track updates of\nmemory.x .",
            "FLASH : ORIGIN = 0x08000000, LENGTH = 256K",
            "RAM : ORIGIN = 0x20000000, LENGTH = 40K",
            "}"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Memory management - Lib.rs",
          "url": "https://lib.rs/memory-management",
          "excerpts": [
            "Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "slab_allocator_rs - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slab_allocator_rs",
          "excerpts": [
            "Jan 7, 2023 — Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        }
      ],
      "reasoning": "The field value asserts that in no_std systems, stack memory safety is paramount, the stack typically resides in RAM and grows downwards, with the initial stack pointer set to the end (highest address) of the RAM region. It notes that Cortex-M startup code reads the initial stack pointer from the vector table, and that the linker script memory.x defines the RAM region with the SP placed at ORIGIN(RAM) + LENGTH(RAM). These claims map directly to excerpts describing a vector table setup that indicates the first entry is the initial stack pointer value and the reset vector, and to the memory layout definitions that specify RAM origin and length as well as how the ORIGIN(RAM) + LENGTH(RAM) placement is used. Specifically, the description of a vector_table containing the initial stack pointer value, and the explicit RAM/origin/length declarations in memory layout excerpts substantiate the conventional no_std Cortex-M stack placement and downward growth model. The excerpt mentioning the linker memory layout with RAM origin and length, and notes about not forgetting to cargo clean when memory.x is changed, further supports the importance of a correctly defined RAM region for stack placement, reinforcing the core claim about SP initialization behavior tied to the vector table and memory script. Additional content discusses static analysis for stack safety, and tools for worst-case stack usage, which aligns with the overall emphasis on rigorous stack verification in no_std contexts. Content about stack painting and MPU guard regions extends the theme of runtime and hardware-assisted safety checks, which corroborates the broader safety framework described in the field value. Finally, excerpts discussing slab allocators and no_std memory management provide context for broader memory safety practices beyond the stack, showing ecosystem strategies for memory management in constrained environments, which complements the stack-focused narrative but is not the primary support for the SP and vector-table mechanism. Together, these excerpts support the core assertions about stack memory location, downward growth, SP initialization via vector table, and the role of the linker script in shaping RAM, while also enriching the safety techniques and ecosystem tooling around stack and memory management in no_std systems.",
      "confidence": "high"
    },
    {
      "field": "interrupts_and_exception_handling",
      "citations": [
        {
          "title": "cortex-m-rt crate docs",
          "url": "https://docs.rs/cortex-m-rt",
          "excerpts": [
            "This crate contains all the required parts to build a no_std application (binary crate) that targets a Cortex-M microcontroller. Startup code and minimal runtime for Cortex-M microcontrollers",
            "#! [no_main]\n#! [no_std]\n\n// Some panic handler needs to be included. This one halts the processor on panic. use panic_halt as _;\n\nuse cortex_m_rt::entry;\n\n// Use `main` as the entry point of this application, which may not return. #[entry]\nfn main() -> ! {\n    // initialization\n\n    loop {\n        // application logic\n    }\n}",
            "This crate also implements a related attribute called #[interrupt] , which allows you to define interrupt handlers.",
            "* interrupt\n    * Attribute to declare an interrupt (AKA device-specific exception) handler",
            "To actually build this program you need to place a memory.x linker script somewhere the linker can find it, e.g. in the current directory; and then link the ...",
            "The required steps are shown below: $ cat > memory.x <<EOF MEMORY { FLASH : ORIGIN = 0x08000000, LENGTH = 64K RAM : ORIGIN = 0x20000000, LENGTH ...",
            "To actually build this program you need to place a memory.x linker script somewhere the linker can find it, e.g. in the current directory; and then link the ...See more",
            "This crate contains all the required parts to build a no_std application (binary crate) that targets a Cortex-M microcontroller."
          ]
        },
        {
          "title": "esp-riscv-rt - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/esp-riscv-rt",
          "excerpts": [
            "Minimal runtime / startup for RISC-V devices from Espressif. Much of the code in this package originated in the rust-embedded/riscv repository."
          ]
        },
        {
          "title": "build-std - Rust Project Goals - GitHub Pages",
          "url": "https://rust-lang.github.io/rust-project-goals/2025h1/build-std.html",
          "excerpts": [
            "build-std is a well-known unstable feature in Cargo which enables Cargo to re-build the standard library, this is useful for a variety of reasons."
          ]
        },
        {
          "title": "The rustc book - Rust Documentation",
          "url": "https://doc.rust-lang.org/rustc/?search=triple",
          "excerpts": [
            "Platform Support » Platform SupportTier Policy . Targets are identified by their \"target triple\" which is the string to inform the compiler what kind of output ..."
          ]
        },
        {
          "title": "Cargo doesn't recognize `build-std`",
          "url": "https://users.rust-lang.org/t/cargo-doesnt-recognize-build-std/116560",
          "excerpts": [
            "Aug 25, 2024 — This means that cargo-features = [\"build-std\"] should work but it instead it says error: failed to parse manifest at `C:\\Users\\hrudk\\Documents\\coding\\DOS in ..."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Mar 4, 2023 — Simple allocator usable for no_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures."
          ]
        },
        {
          "title": "linked_list_allocator - Rust",
          "url": "https://docs.rs/linked_list_allocator/",
          "excerpts": [
            "A fixed size heap backed by a linked list of free memory blocks. LockedHeap. Functions§. align_down_size: Align downwards. Returns the greatest x with alignment ..."
          ]
        },
        {
          "title": "Panic Handler in Embedded Rust",
          "url": "https://stackoverflow.com/questions/78497621/panic-handler-in-embedded-rust",
          "excerpts": [
            "I am setting up a new embedded rust project, and I encountered the \"can't find crate for test\" problem at the #![no_std]."
          ]
        },
        {
          "title": "How to#[entry] in an #[exception] in cortex-m-rt - Rust?",
          "url": "https://stackoverflow.com/questions/79731744/how-toentry-in-an-exception-in-cortex-m-rt-rust",
          "excerpts": [
            "I'm trying to write an OS for a STM32H723ZG board and I've run into a problem. I configured the systick timer to interrupt every 50ms ..."
          ]
        },
        {
          "title": "Why are memory mapped registers implemented with ...",
          "url": "https://users.rust-lang.org/t/why-are-memory-mapped-registers-implemented-with-interior-mutability/116119",
          "excerpts": [
            "Aug 17, 2024 — The UnsafeCell allows VolatileCell 's contents to be mutated without the cell itself being mutable thus permitting the existence of (internally) ...",
            "Volatile reads and writes are necessary for MMIO because the compiler is, in general, allowed to optimize out loads and stores that it deems redundant.",
            "Aug 17, 2024 — Volatile reads and writes are necessary for MMIO because the compiler is, in general, allowed to optimize out loads and stores that it deems redundant."
          ]
        },
        {
          "title": "What's the \"correct\" way of doing static mut in 2024 Rust?",
          "url": "https://users.rust-lang.org/t/whats-the-correct-way-of-doing-static-mut-in-2024-rust/120403",
          "excerpts": [
            "Oct 29, 2024 — If you really cannot afford a safe abstraction like Mutex , you can use UnsafeCell to unsafe ly assert your mutable non-aliasing accesses. 6 ...",
            "The recommendation is to instead use interior mutability, such as with a `Arc<Mutex>` around an immutable shared global.",
            "static GLOBAL: UnsafeCell<T>` is functionally the same"
          ]
        },
        {
          "title": "riscv_rt::interrupts - Rust - Docs.rs",
          "url": "https://docs.rs/riscv-rt/latest/riscv_rt/interrupts/index.html",
          "excerpts": [
            "This function is called by the [crate::start\\_trap\\_rust](../fn.start_trap_rust.html \"fn riscv_rt::start_trap_rust\")\nwhenever an interrupt is triggered. This approach relies on the [`__CORE_INTERRUPTS`] array,\nwhich sorts all the interrupt handlers depending on their corresponding interrupt source cod",
            "In vectored mode (i.e., `v-trap` feature enabled), interrupt dispatching is handled by hardware.",
            "To support this mode, we provide inline assembly code that defines the interrupt vector table. Since the alignment constraint of this vector table is implementation-specific, it can be\nchanged by setting the `RISCV_MTVEC_ALIGN` environment variable (the default is 4).",
            "If your target has custom core interrupt sources, the target PAC might provide equivalent code\nto adapt for the target needs (and is responsible for any alignment constraint). In this case,\nyou may need to opt out this module. To do so, activate the `no-interrupts` feature of the\n`riscv-rt` crate."
          ]
        },
        {
          "title": "NVIC and interrupt priority - Rust Embedded MB2 Discovery ...",
          "url": "https://docs.rust-embedded.org/discovery-mb2/15-interrupts/nvic-and-interrupt-priority.html",
          "excerpts": [
            "In embedded Rust, we can program the NVIC using the cortex-m crate, which provides methods to enable and disable (called unmask and mask ) interrupts, set ..."
          ]
        },
        {
          "title": "Priority grouping",
          "url": "https://developer.arm.com/documentation/ihi0048/b/Interrupt-Handling-and-Prioritization/Interrupt-prioritization/Priority-grouping?lang=en",
          "excerpts": [
            "Priority grouping · For a pending interrupt to preempt an active interrupt, its group priority must be higher than the group priority of the active interrupt."
          ]
        },
        {
          "title": "Cortex-M4 Devices Generic User Guide",
          "url": "https://documentation-service.arm.com/static/5f2ac4ab60a93e65927bbdbf?token=",
          "excerpts": [
            "The Cortex-M4 processor is a high performance 32-bit processor designed for the microcontroller market. It offers significant benefits to ..."
          ]
        },
        {
          "title": "Struct cortex_m::peripheral::NVIC",
          "url": "https://docs.rust-embedded.org/panic-semihosting/cortex_m/peripheral/struct.NVIC.html",
          "excerpts": [
            "NOTE See get_priority method for an explanation of how NVIC priorities work. On ARMv6-M, updating an interrupt priority requires a read-modify-write operation."
          ]
        },
        {
          "title": "Embedded Rust: customizing the Cortex-M exception vector ...",
          "url": "https://thomasw.dev/post/rust-cortexm-vectors/",
          "excerpts": [
            "When writing Rust code for ARM Cortex-M microcontrollers it is common to use the cortex-m-rt and the cortex-m crates. The first provides a ...",
            "Feb 12, 2023 — cortex-m-rt also ensures the reset, interrupt and exception vector tables are present and populated based on the interrupt routines defined by ...",
            "Feb 12, 2023 — As required by cortex-m-rt , populate memory.x : MEMORY { FLASH : ORIGIN = 0x00000000, LENGTH = 64K RAM : ORIGIN = 0x20000000, LENGTH = 20K }."
          ]
        },
        {
          "title": "rust-embedded/riscv: Low level access to RISC-V processors - GitHub",
          "url": "https://github.com/rust-embedded/riscv",
          "excerpts": [
            "This repository contains various crates useful for writing Rust programs on RISC-V microcontrollers: ... riscv-rt : Startup code and interrupt handling; riscv- ..."
          ]
        },
        {
          "title": "lib.rs - source - Docs.rs",
          "url": "https://docs.rs/riscv-rt/latest/src/riscv_rt/lib.rs.html",
          "excerpts": [
            "Docs.rs. riscv-rt-0.15.0. riscv-rt 0.15.0; Permalink · Docs.rs crate page · ISC ... Documentation. Files. riscv_rt. asm.rsexceptions.rsinterrupts.rslib.rs ...",
            "1//! Startup code and minimal runtime for RISC-V CPUs 2//! 3//! This crate contains all the required parts to build a `no_std` application 4//! (binary ..."
          ]
        },
        {
          "title": "How do I instruct ARM cortext to do tail chaining of interrupts or stack ...",
          "url": "https://stackoverflow.com/questions/55212203/how-do-i-instruct-arm-cortext-to-do-tail-chaining-of-interrupts-or-stack-pop-pre",
          "excerpts": [
            "Is there any special mode or registers I need to set so that the ARM processor having NVIC uses tail chaining and stack pop pre-emption of ..."
          ]
        },
        {
          "title": "Bringing up RISC-V Interrupts using Rust Programming ...",
          "url": "https://trepo.tuni.fi/bitstream/10024/147785/2/AhmedAisha.pdf",
          "excerpts": [
            "Apr 25, 2023 — One example is having only CLINT to control all inter- rupts. Another design for interrupt system shown in Figure is having CLINT to handle both ..."
          ]
        },
        {
          "title": "Asynchronous Rust on Cortex-M Microcontrollers - Interrupt",
          "url": "https://interrupt.memfault.com/blog/embedded-async-rust",
          "excerpts": [
            "Jul 19, 2023 — In this article, we explore the inner workings of Futures, cooperative scheduling, and Async Rust executors, highlighting their significance in optimizing ..."
          ]
        },
        {
          "title": "Document how to use interrupts on RISC-V · Issue #404",
          "url": "https://github.com/rust-embedded/svd2rust/issues/404",
          "excerpts": [
            "Dec 28, 2019 — The implementation for interrupts generates a macro interrupt!() that takes the name of an interrupt, a closure, and optionally a struct of ..."
          ]
        },
        {
          "title": "Interrupts in Rust Embedded",
          "url": "https://www.reddit.com/r/rust/comments/1ap6ar6/interrupts_in_rust_embedded/",
          "excerpts": [
            "NOTE: This attribute is exposed by cortex-m-rt only when the device feature is enabled. However, that export is not meant to be used directly – ...",
            "I am having issues setting up interrupts using my PAC. I see in the embedded rust book this seems to be not to complicated but I am getting issues with ..."
          ]
        },
        {
          "title": "Case 2: tail-chaining",
          "url": "https://developer.arm.com/documentation/107706/0100/Use-case-examples/irq-priority-basic/Case-2--tail-chaining",
          "excerpts": [
            "Tail-chaining is used to optimize the back-to-back processing of exceptions without the overhead of state saving and restoration between interrupts."
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`](https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html) attribute to declare interrupt handlers. The available interrupts (and\ntheir position in the interrupt handler table) are usually automatically\ngenerated via `svd2rust` from a SVD description.",
            "```rust\n// Interrupt handler for the Timer2 interrupt\n#[interrupt]\nfn TIM2() {\n    // ..\n    // Clear reason for the generated interrupt request\n}\n```\n",
            "The available interrupts (and\ntheir position in the interrupt handler table) are usually automatically\ngenerated via `svd2rust` from a SVD description.",
            "    // ..",
            "ers' execution order\n* Interrupts can nest and preempt, i.e.\nexecution of an interrupt handler might be interrupted by another higher-priority",
            "Interrupt handlers look like plain functions (except for the lack of arguments)\nsimilar to exception handlers. However they can not be called directly by other\nparts of the firmware due to the special calling conventions.",
            "The general initialization steps at runtime are always the same:\n\n* Setup the peripheral(s) to generate interrupts requests at the desired occasions\n* Set the desired priority of the interrupt handler in the interrupt controller\n* Enable the interrupt handler in the interrupt controller",
            "It is however\npossible to generate interrupt requests in software to trigger a diversion to\nthe interrupt handler.",
            "Similar to exception handlers it is also possible to declare `static mut` variables inside the interrupt handlers for _safe_ state keeping.",
            "#[interrupt]",
            "#[interrupt]",
            "fn TIM2() {",
            "fn TIM2() {",
            "    static mut COUNT: u32 = 0;",
            "    // \\`COUNT\\` has type \\`&mut u32\\` and it's safe to use",
            "    *COUNT += 1;",
            "}",
            "}"
          ]
        },
        {
          "title": "How to get the interrupt reexport from cortex-m-rt in stm32f30x to run",
          "url": "https://stackoverflow.com/questions/65691495/how-to-get-the-interrupt-reexport-from-cortex-m-rt-in-stm32f30x-to-run",
          "excerpts": [
            "3\n\nYou need to enable the `rt` feature of the [`stm32f30x` crate]"
          ]
        },
        {
          "title": "Docs.rs cortex-m-rt - Interrupts and basic usage",
          "url": "https://docs.rs/cortex-m-rt/latest/src/cortex_m_rt/lib.rs.html",
          "excerpts": [
            " These handlers must have signature \\`[unsafe] fn() [-> ! ]",
            "where the name of the function must be one of the device interrupts.",
            "... svd2rust`. Those peripheral access crates, or PACs, 173//! will populate the missing part of the vector table when their `\"rt\"` feature is enabled. 174 ...",
            "1//! Startup code and minimal runtime for Cortex-M microcontrollers 2//! 3//! This crate contains all the required parts to build a `no_std` application ..."
          ]
        },
        {
          "title": "Interrupts and NVIC in ARM Cortex-M (Memfault)",
          "url": "https://interrupt.memfault.com/blog/arm-cortex-m-exceptions-and-nvic",
          "excerpts": [
            ". #### Interrupt Priority Registers (NVIC\\_IPR)\n\n* `NVIC_IPR0` \\- `NVIC_IPR123` : `0xE000E400` \\- `0xE000E5EC`\n\nThe final NVIC configuration register is used to configure the priority of the interrupt. 8 bits\nare used to configure the priority of each interrupt. The number of supported priority levels is\nimplementation defined and is in the range of 4-256. When less than 256 priority levels are\nimplemented, the lower bits in the field read-as-zero. So, somewhat confusingly, if only 2 bits are implemented, the valid\nvalues from highest priority to lowest priority would be **0b000.0000** ( **0x0** ), **0b0100.0000** ( **0x40** ), **0b1000.0000** ( **0x80** ) and **0b1100.0000** ( **0xC0** )."
          ]
        },
        {
          "title": "PLIC - OSDev Wiki",
          "url": "https://wiki.osdev.org/PLIC",
          "excerpts": [
            "The PLIC(Platform Level Interrupt Controller) is the RISC-V equivalent of the PIC for x86 platforms. Without it, no external interrupts can be received."
          ]
        },
        {
          "title": "External Interrupts: RISCV OS in Rust - Stephen Marz",
          "url": "https://osblog.stephenmarz.com/ch5.html",
          "excerpts": [
            "The platform-level interrupt controller (PLIC) routes all signals through one pin on the CPU--the EI (external interrupt) pin. This pin can be ...",
            "When we claim an interrupt, we're telling the PLIC that it is going to be handled or is in the process of being handled. During this time the ..."
          ]
        },
        {
          "title": "7 Platform-Level Interrupt Controller (PLIC) - Five EmbedDev",
          "url": "https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/plic.html",
          "excerpts": [
            "A threshold register should always be able to hold the value zero, in which case, no interrupts are masked. If implemented, the threshold register will usually ..."
          ]
        },
        {
          "title": "[PDF] RISC-V Platform-Level Interrupt Controller Specification",
          "url": "https://9p.io/sources/contrib/geoff/riscv/riscv-plic.pdf",
          "excerpts": [
            "The PLIC can perform a claim at any time and the claim operation is not affected by the setting of the priority threshold register. The ..."
          ]
        },
        {
          "title": "Taking control of RISC-V: RISCV OS in Rust - Stephen Marz",
          "url": "https://osblog.stephenmarz.com/ch1.html",
          "excerpts": [
            "Sep 29, 2019 — We use the #![no_std] to tell Rust that we won't be using the standard library. Then we ask Rust to allow the panic info message and inline- ..."
          ]
        },
        {
          "title": "external_interrupt in riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt/latest/riscv_rt/attr.external_interrupt.html",
          "excerpts": [
            "Attribute to declare an external interrupt handler. The function must have the signature `[unsafe] fn() [-> ! ]`.\nThe argument of the macro must be a path to a variant of an enum that implements the `riscv_rt::ExternalInterruptNumber` tra",
            "\")\n\n```\n#[riscv_rt::external_interrupt(e310x::interrupt::Interrupt::GPIO0)]\nfn gpio0() -> ! {\n    loop{};\n}\n```"
          ]
        },
        {
          "title": "A wait-free single-producer single-consumer ring buffer ... - blog",
          "url": "https://blog.paul.cx/post/a-wait-free-spsc-ringbuffer-for-the-web/",
          "excerpts": [
            "Jun 6, 2022 — The Single-Producer Single-Consumer wait-free ring buffer (often called SPSC ring buffer) is often regarded as the bread and butter data ..."
          ]
        },
        {
          "title": "RISC-V QEMU Part 1: Privileged ISA v1.10, HiFive1 and VirtIO - SiFive",
          "url": "https://www.sifive.com/blog/risc-v-qemu-part-1-privileged-isa-hifive1-virtio",
          "excerpts": [
            "The SiFive platform-level interrupt controller (PLIC) prioritizes and distributes global interrupts in a RISC-V system. The QEMU PLIC ..."
          ]
        },
        {
          "title": "How we built our 2025 Embedded World Demos - Ferrous Systems",
          "url": "https://ferrous-systems.com/blog/embedded-world-2025-demos/",
          "excerpts": [
            "We have developed two simple Rust applications for this Cortex-M4 based MCU, using the RTIC framework. Both applications simply wake up ..."
          ]
        },
        {
          "title": "RISC-V PLIC Specification (interconnect and memory-map details)",
          "url": "https://courses.grainger.illinois.edu/ece391/su2025/docs/riscv-plic-1.0.0.pdf",
          "excerpts": [
            "The PLIC can perform an interrupt claim by reading the claim/complete register, which returns the. ID of the highest priority pending interrupt or zero if there ...",
            "For example, a threshold value of zero permits all\ninterrupts with non-zero priority.",
            "The base address of Interrupt Source Priority block within PLIC Memory Map region is fixed at\n0x000000.",
            "PLIC Interrupt Enable Bits Memory Map",
            "the\nPLIC core will atomically determine the ID of the highest-priority pending interrupt for the target\nand then clear down the corresponding source’s IP bit.",
            "The PLIC core will then return the ID to the\ntarget. The PLIC core will return an ID of zero, if there were no pending interrupts for the target\nwhen the claim was serviced.",
            "The PLIC signals it has completed executing an interrupt handler by writing the interrupt ID it\nreceived from the claim to the claim/complete register."
          ]
        },
        {
          "title": "Tail chaining",
          "url": "https://developer.arm.com/documentation/107706/latest/Exceptions-and-interrupts-overview/Exception-handling-optimizations/Tail-chaining",
          "excerpts": [
            "Tail-chaining optimization makes the processor system more energy efficient because the number of memory accesses involved in stacking and unstacking is reduced ..."
          ]
        },
        {
          "title": "Configurable Fault Status Register - Cortex-M3",
          "url": "https://developer.arm.com/documentation/dui0552/latest/cortex-m3-peripherals/system-control-block/configurable-fault-status-register",
          "excerpts": [
            "The CFSR indicates the cause of a MemManage fault, BusFault, or UsageFault. See the register summary in Table 4.12 for its attributes."
          ]
        },
        {
          "title": "ringbuffer_spsc - Rust",
          "url": "https://docs.rs/ringbuffer-spsc",
          "excerpts": [
            "A fast thread-safe no_std single-producer single-consumer ring buffer. For performance reasons, the capacity of the buffer is determined at compile time."
          ]
        },
        {
          "title": "How to interrupt on baremetal (without rtfm!)? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/f5gg5a/how_to_interrupt_on_baremetal_without_rtfm/",
          "excerpts": [
            "Bare metal mutex will disable interruption during the usage of the contained data. So, it's not \"locking\" in the sens of waiting, the lock will ..."
          ]
        },
        {
          "title": "How to share peripheral register structs with interrupt handlers?",
          "url": "https://users.rust-lang.org/t/how-to-share-peripheral-register-structs-with-interrupt-handlers/29418",
          "excerpts": [
            "Jun 19, 2019 — So far, I've come up with two working solutions, but neither seems ideal. Option 1: Use a static mut variable, e.g.: // (no_std, crate includes, ...",
            "Does anyone have advice about the current best practices for sharing Peripheral Access Crate register structs between an application's main thread and its ..."
          ]
        },
        {
          "title": "Debugging a hard fault in ARM Cortex-M4",
          "url": "https://stackoverflow.com/questions/53253652/debugging-a-hard-fault-in-arm-cortex-m4",
          "excerpts": [
            "I am at my wit's end trying to debug a hard fault on an EFR32BG12 processor. I've been following the instructions in the Silicon Labs knowledge base here."
          ]
        },
        {
          "title": "What is Tail Chaining in ARM cortex M4 Processor?",
          "url": "https://www.linkedin.com/pulse/what-tail-chaining-arm-cortex-m4-processor-dinesh-murugan-vlyvc",
          "excerpts": [
            "In essence, tail chaining is a clever hardware optimization that makes interrupt handling in embedded systems more efficient by streamlining ..."
          ]
        },
        {
          "title": "How do I have multiple mutable references on a cortex-m0?",
          "url": "https://stackoverflow.com/questions/63253162/how-do-i-have-multiple-mutable-references-on-a-cortex-m0",
          "excerpts": [
            "If I understand correctly, you're doing bare-metal with Rust on an M0 single-threaded CPU, and wish to handle platform interrupts."
          ]
        },
        {
          "title": "How to create a critical section with Mutex in Rust? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/66574367/how-to-create-a-critical-section-with-mutex-in-rust",
          "excerpts": [
            "Missing: crate no_std"
          ]
        },
        {
          "title": "Rust optimizes away all the interrupt/exception handlers ...",
          "url": "https://stackoverflow.com/questions/79496840/rust-optimizes-away-all-the-interrupt-exception-handlers-from-riscv-rt",
          "excerpts": [
            "Rust optimizes away all the interrupt/exception handlers from riscv-rt ... Does anyone have a working example? #![no_std] #![no_main] use ..."
          ]
        },
        {
          "title": "What is the correct way to share a locking reference to a resource in ...",
          "url": "https://stackoverflow.com/questions/72652081/what-is-the-correct-way-to-share-a-locking-reference-to-a-resource-in-avr-no-st",
          "excerpts": [
            "What is the correct way to share a locking reference to a resource in AVR (no_std) Rust? Ask Question. Asked 3 years, 2 months ago. Modified 3 ..."
          ]
        },
        {
          "title": "Nitin Kumar Upadhyay - chaining in ARM processor?",
          "url": "https://www.linkedin.com/posts/nitin-kumar-uadhyay_what-is-tail-chaining-in-arm-processor-activity-7135229647033692160-SERB",
          "excerpts": [
            "The tail chain will remove the unnecessary unstacking and stacking. That will save some time and reduce the interrupt latency. The tail chaining ..."
          ]
        },
        {
          "title": "Rust no_std Interrupts: Shared State, Mutexes, and Critical Sections (forum discussion)",
          "url": "https://users.rust-lang.org/t/how-can-i-access-my-struct-with-peripherals-in-an-interrupt/94884",
          "excerpts": [
            "I have only used cortex-m microcontrollers, shared states between ISR and main loop is simply critical_section::Mutex<SharedStates> ",
            "the bare metal `Mutex` is not a locking mechanism as the standard `Mutex` , but just a type level wrapper to make type `Sync`",
            "it relies on the implementation of a critical section _token_ , to protect the access",
            "in such cases, nested access is UB, thus the low level `acquire()` and `release()` are `unsafe` , but [`critical_section::with()`](https://docs.rs/critical-section/latest/critical_section/fn.with.html) is always safe",
            "when the protected states are simple (say, one or two words, and is Copy), `Mutex<Cell<T>>` can be used to mutate the states.",
            "for more complicated types or the \"locking\" behavior is desired, use `Mutex<RefCell<T>>` , which adds the runtime overhead (a borrow flag), and achieves the same functionality of `std::sync::Mutex` (well, almost, because technically, `std::sync::Mutex` has more overhead like poisoning, it's `std` not `core` after all).",
            "as a side note, there are actually 2 crates that provide `CriticalSection` types: `bare_metal` and `critical_section` .",
            "Use `once_cell::sync::Lazy` to initialize a value on first access."
          ]
        },
        {
          "title": "Mutex<RefCell<Option<T>>> on STM32 project",
          "url": "https://users.rust-lang.org/t/mutex-refcell-option-t-on-stm32-project/124386",
          "excerpts": [
            "static GLOBAL_DATA: Mutex<RefCell<Option<Data>>> = Mutex::new(RefCell::new(None));",
            "Jan 21, 2025 — Hi, I am still a novice to Rust, and I've been struggling with the combination of Mutex + RefCell + Option in my STM32 project.",
            "I think this might not be a recommended way in Rust, but is there even a way for that?"
          ]
        },
        {
          "title": "Cortex-M-RT Exception Handling (docs.rs cortex-m-rt)",
          "url": "https://docs.rs/cortex-m-rt/latest/cortex_m_rt/attr.exception.html",
          "excerpts": [
            "-\n\n```\n#[exception]\nfn SysTick() {\n    // ..\n}\n\n```\n\nwhere the name of the function must be one of:\n\n* `DefaultHandler`\n* `NonMaskableInt`\n* `HardFault`\n* `MemoryManagement` (a)\n* `BusFault` (a)\n* `UsageFault` (a)\n* `SecureFault` (b)\n*\n`SVCall`\n* `DebugMonitor` (a)\n* `PendSV`\n* `SysTick`\n\n(a) Not available on Cortex-M0 variants (`thumbv6m-none-eabi`)\n\n(b) Only available on ARMv8-M\n\n",
            "#[exception(trampoline = true)] unsafe fn HardFault(..` sets the hard fault handler. If the trampoline parameter is set to true, the handler must have signature `unsafe fn(&ExceptionFrame) -> !`. If set to false, the handler must have signature `unsafe fn() -> !`. This handler is not allowed to return as that can cause undefined behavior. To maintain backwards compatibility the attribute can be used without trampoline parameter (`#[exception]`),\nwhich sets the trampoline to true"
          ]
        },
        {
          "title": "The Cortex-M/RISC-V Interrupt and Exception Handling in cortex-m-rt discussion",
          "url": "https://github.com/rust-embedded/cortex-m-rt/issues/158",
          "excerpts": [
            "The HardFault handler has access to the exception frame, a snapshot of the CPU registers at the moment of the exception."
          ]
        },
        {
          "title": "stm32h7xx-hal/examples/ethernet-stm32h747i-disco.rs at master",
          "url": "https://github.com/stm32-rs/stm32h7xx-hal/blob/master/examples/ethernet-stm32h747i-disco.rs",
          "excerpts": [
            "GitHub Copilot. Write better ... cp.NVIC.set_priority(stm32::Interrupt::ETH, 196); // Mid prio. cortex_m::peripheral::NVIC::unmask(stm32::Interrupt::ETH);."
          ]
        },
        {
          "title": "tail-chaining of Interrupts - Stack Overflow",
          "url": "https://stackoverflow.com/questions/13029201/tail-chaining-of-interrupts",
          "excerpts": [
            "Tail-chaining is back-to-back processing of exceptions without the overhead of state saving and restoration between interrupts."
          ]
        },
        {
          "title": "NVIC in stm32wlxx_hal::pac - Rust",
          "url": "https://stm32-rs.github.io/stm32wlxx-hal/stm32wlxx_hal/pac/struct.NVIC.html",
          "excerpts": [
            "Writing a value to the INTID field is the same as manually pending an interrupt by setting the corresponding interrupt bit in an Interrupt Set Pending Register."
          ]
        },
        {
          "title": "How to change exception priority on cortex-m4 processor ...",
          "url": "https://stackoverflow.com/questions/65705477/how-to-change-exception-priority-on-cortex-m4-processor-in-rust",
          "excerpts": [
            "I want to set interrupt priorities for processor internal exceptions. The cortex_m crate provides easy access to NVIC control registers."
          ]
        },
        {
          "title": "What are the various ways to disable and re-enable interrupts in ...",
          "url": "https://stackoverflow.com/questions/71626597/what-are-the-various-ways-to-disable-and-re-enable-interrupts-in-stm32-microcont",
          "excerpts": [
            "Each interrupt type has a priority assigned to it, with lower numbers being higher priority, and higher-priority interrupts are able to fire ..."
          ]
        },
        {
          "title": "riscv_plic - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/riscv_plic",
          "excerpts": [
            "Dec 17, 2024 — RISC-V platform-level interrupt controller (PLIC) register definitions and basic operations. The official documentation: https://github.com/ ..."
          ]
        },
        {
          "title": "riscv/riscv-plic-spec: PLIC Specification",
          "url": "https://github.com/riscv/riscv-plic-spec",
          "excerpts": [
            "This is the document that describes operation parameters according RISC-V platform-level interrupt controller (PLIC)."
          ]
        },
        {
          "title": "riscv_plic - Rust",
          "url": "https://docs.rs/riscv_plic",
          "excerpts": [
            "RISC-V Platform-Level Interrupt Controller https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc."
          ]
        },
        {
          "title": "Sending large amount of data from ISR using queues in ...",
          "url": "https://stackoverflow.com/questions/70348882/sending-large-amount-of-data-from-isr-using-queues-in-rtos",
          "excerpts": [
            "Have the audio data written directly to a block (by DMA for example), then when full, enqueue a pointer to the block, and switch to the next ..."
          ]
        },
        {
          "title": "heapless::spsc::Queue - Rust - CLUB ROBOT",
          "url": "https://clubrobotinsat.github.io/librobot/heapless/spsc/struct.Queue.html",
          "excerpts": [
            "For small queues usize indices may be overkill. However, spsc::Queue 's index type is generic and can be changed to u8 or u16 to reduce its footprint."
          ]
        },
        {
          "title": "How should I pair read_volatile and write_volatile?",
          "url": "https://users.rust-lang.org/t/how-should-i-pair-read-volatile-and-write-volatile/33287",
          "excerpts": [
            "Oct 5, 2019 — Hi guys, can someone explain me how is correct to pair a read and write with volatile semantics? For example if I have a pointer some_ptr of ..."
          ]
        },
        {
          "title": "write_volatile in no_std_compat2::ptr - Rust",
          "url": "https://docs.rs/no-std-compat2/latest/no_std_compat2/ptr/fn.write_volatile.html",
          "excerpts": [
            "Performs a volatile write of a memory location with the given value without\nreading or dropping the old value. Volatile operations are intended to act on I/O memory, and are guaranteed\nto not be elided or reordered by the compiler across other volatile\noperations.",
            "\n\nBehavior is undefined if any of the following conditions are violated:",
            "* `dst` must be [valid](https://doc.rust-lang.org/nightly/core/ptr/index.html \"mod core::ptr\") for writes. * `dst` must be properly aligned. Note that even if `T` has size `0`, the pointer must be non-null and properly aligned. Just like in C, whether an operation is volatile has no bearing whatsoever\non questions involving concurrent access from multiple threads. Volatile\naccesses behave exactly like non-atomic accesses in that regard. In particular,\na race between a `write_volatile` and any other operation (reading or writing)\non the same location is undefined behavior.",
            "Additionally, it does not drop `src`. Semantically, `src` is moved into the\nlocation pointed to by `dst`."
          ]
        },
        {
          "title": "volatile-register - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/volatile_register",
          "excerpts": [
            "volatile-register. Volatile access to memory mapped hardware registers. Documentation. License. Licensed under either of. Apache License, ..."
          ]
        },
        {
          "title": "volatile_register - Rust - Docs.rs",
          "url": "https://docs.rs/volatile-register",
          "excerpts": [
            "Volatile access to memory mapped hardware registers. Usage: use volatile_register::RW; // Create a struct that represents the memory mapped register block."
          ]
        },
        {
          "title": "Embedded Rust: Creating Peripheral Access Crates (PACs)",
          "url": "https://www.embedded.com/embedded-rust-creating-peripheral-access-crates-pacs/",
          "excerpts": [
            "Dec 26, 2024 — For example, if you wanted to create a pac for the STM32U575, you'd use the following command: cargo new stm32l475_pac –lib. Here, we use ...",
            "Dec 26, 2024 — In today's post, we'll look at how to generate your own Peripheral Access Crate from your microcontroller vendor's SVD file using svd2rust."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the PAC: GPIO Control",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-pac-gpio-control-20h4",
          "excerpts": [
            "Feb 13, 2023 — In this post, I will be starting out with an example of the GPIO peripheral. We'll see how we can configure GPIO, read inputs, and manipulate output at the PAC."
          ]
        },
        {
          "title": "vcell - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/vcell",
          "excerpts": [
            "vcell. Just like Cell but with volatile read / write operations. Change log. License. Licensed under either of."
          ]
        },
        {
          "title": "Volatile atomic operations? - help",
          "url": "https://users.rust-lang.org/t/volatile-atomic-operations/103142",
          "excerpts": [
            "Nov 28, 2023 — The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (eg memory-mapped I/O) atomic objects."
          ]
        },
        {
          "title": "Blog post: Thoughts on trusting types and unsafe code",
          "url": "https://internals.rust-lang.org/t/blog-post-thoughts-on-trusting-types-and-unsafe-code/4059",
          "excerpts": [
            "Sep 12, 2016 — In particular we would want to preserve the invariant that if a pointer is read using only volatile loads, we will never introduce other random ..."
          ]
        },
        {
          "title": "Is read_volatile on uninitialized memory really undefined ...",
          "url": "https://github.com/rust-lang/miri/issues/2807",
          "excerpts": [
            "Mar 8, 2023 — Hi! I must read memory that is considered uninitialized by Rust. For that purpose I am using the core::ptr::read_volatile function."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: Timer Interrupts",
          "url": "https://blog.theembeddedrustacean.com/stm32f4-embedded-rust-at-the-hal-timer-interrupts",
          "excerpts": [
            "The idea here is to integrate interrupts for timer delay events as well, thus having the application run completely based on interrupts. This ...",
            "This blog post is the second of a three-part series of posts where I explore interrupts for the STM32F401RE microcontroller using embedded Rust at the HAL ..."
          ]
        },
        {
          "title": "How to manage devices that cannot access d-cache in ARM",
          "url": "https://stackoverflow.com/questions/75494288/how-to-manage-devices-that-cannot-access-d-cache-in-arm",
          "excerpts": [
            "Clean d-cache for that area to force it to go to actual memory, so DMA can see it. Launch the operation: DMA will read the value from the area ...",
            "The answer is yes: clean will force cache to be written in memory and invalidate will force memory to be cached."
          ]
        },
        {
          "title": "DMA in rp2040_pac - Rust",
          "url": "https://rtic.rs/2/api/rp2040_pac/struct.DMA.html",
          "excerpts": [
            "This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area."
          ]
        },
        {
          "title": "[EiR] Memory safe DMA transfers : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/7wco91/eir_memory_safe_dma_transfers/",
          "excerpts": [
            "DMA in some form is used for virtually all data transfer in and out of RAM on desktop systems. This includes HDD/SSDs, GPUs, network interfaces, USB devices, ...",
            "I believe you could also give ownership of the buffer to the Transfer struct and it would be protected from mem::forget-ing in that case as well ..."
          ]
        },
        {
          "title": "Rust Core: write_volatile (core::ptr)",
          "url": "https://doc.rust-lang.org/core/ptr/fn.write_volatile.html",
          "excerpts": [
            "pub unsafe fn write_volatile<T>(dst: *mut T , src: T)",
            "tion\n\nPerforms a volatile write of a memory location with the given value without\nreading or dropping the old value. Volatile operations are intended to act on I/O memory, and are guaranteed\nto not be elided or reordered by the compiler across other volatile\noperations. `write_volatile` does not drop the contents of `dst` . This is safe, but it\ncould leak allocations or resources, so care should be taken not to overwrite\nan object that should be dropped. Additionally, it does not drop `src` . Semantically, `src` is moved into the\nlocation pointed to by `dst` .",
            "ty\n\nBehavior is undefined if any of the following conditions are violated:\n\n* \n  `dst` must be [valid](index.html \"mod core::ptr\") for writes. * \n  `dst` must be properly aligned. Note that even if `T` has size `0` , the pointer must be properly aligned. Just like in C, whether an operation is volatile has no bearing whatsoever\non questions involving concurrent access from multiple threads. Volatile\naccesses behave exactly like non-atomic accesses in that regard. In particular,\na race between a `write_volatile` and any other operation (reading or writing)\non the same location is undefined behavior.",
            "volatile memory operations on zero-sized types\n(e.g., if a zero-sized type is passed to `write_volatile` ) are noops\nand may be ignored.",
            "The compiler shouldn’t change the relative order or number of volatile\nmemory operations."
          ]
        },
        {
          "title": "Ferrous Systems Embedded Training - Dealing with Registers",
          "url": "https://embedded-trainings.ferrous-systems.com/dealing-with-registers",
          "excerpts": [
            "Apart from the read and write methods there's a modify method that performs a read-modify-write operation on the register; this API is also closure-based.",
            ". These closures in turn grant access to a \"constructor\" value, usually named `r` or `w`, which provides methods to modify the bitfields of a register.",
            ". At the same time the API of these \"constructors\" prevent you from modifying the reserved parts of the register: you cannot write arbitrary values into registers; you can only write valid values into registers.",
            "The `svd2rust`-generated API is documented in detail in the `svd2rust` crate starting at [the Peripheral API section](https://docs.rs/svd2rust/0.17.0/svd2rust/).",
            "In Cortex-M devices interrupt handling needs to be enabled on two sides: on the peripheral side and on the core side.",
            "The core side of the operation involves writing to the registers of the Nested Vector Interrupt Controller (NVIC) peripheral."
          ]
        },
        {
          "title": "Rust Embedded: DMA safety and memory-mapped I/O",
          "url": "https://github.com/rust-embedded/embedded-hal/issues/37",
          "excerpts": [
            "Feb 9, 2018 — The ongoing transfer value must take ownership of the buffer and the DMA channel ... Because the Transfer owns its Tx or Rx pin and the buffer ...",
            "storing `[T; N]` in the `Transfer` struct doesn't work because the address is not stable -- it  \n    changes when the `Transfer` struct is ",
            "`&'static mut` fulfills these two requirements but so do `Box`, `Vec` and other heap allocated  \n    collect",
            "Alignment requirements. Does a transfer on a `[u16]` buffer require the buffer to be 16-bit  \n  aligned? The answer probably depends on the target devi",
            "Ownership and *stable* addresses are a must for memory safety",
            "(remember that `mem::forget` is safe in Rust)"
          ]
        },
        {
          "title": "The Rustonomicon - Rust Documentation",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "compiler_fence in std::sync::atomic",
          "url": "https://doc.rust-lang.org/std/sync/atomic/fn.compiler_fence.html",
          "excerpts": [
            "`compiler_fence` is a \"compiler-only\" atomic fence that establishes synchronization within the same thread, restricting memory reordering, and does not emit ...",
            "A “compiler-only” atomic fence. Like fence, this function establishes synchronization with other atomic operations and fences."
          ]
        },
        {
          "title": "Compiler fence + DMA - embedded",
          "url": "https://users.rust-lang.org/t/compiler-fence-dma/132027",
          "excerpts": [
            "Jul 18, 2025 — compiler_fence(Ordering::Acquire); let header = buffer[0]; let ... \"For (2), one has to put a suitable fence between the DMA accesses and the ...",
            "Assuming the MMIO register is ARM strongly ordered memory, a hardware/memory fence or DMB instruction doesn't seem to be required. I don't see ..."
          ]
        },
        {
          "title": "c# - Deeply understanding Volatile and Memory Barriers",
          "url": "https://stackoverflow.com/questions/78752346/deeply-understanding-volatile-and-memory-barriers",
          "excerpts": [
            "No, you don't need an explicit memory barrier here, as volatile in C# already provides half-barriers which is enough in this case. You are ..."
          ]
        },
        {
          "title": "Is there a concept of \"Happens-Before\" in Rust?",
          "url": "https://www.reddit.com/r/rust/comments/sga1i0/is_there_a_concept_of_happensbefore_in_rust/",
          "excerpts": [
            "But volatile does not cause the compiler to emit memory barriers, so ... volatile operations are not synchronization constructs in Rust ..."
          ]
        },
        {
          "title": "Hint: DMA and cache coherency",
          "url": "https://community.st.com/t5/stm32-mcus-products/hint-dma-and-cache-coherency/td-p/439559",
          "excerpts": [
            "Sep 11, 2023 — DMA transfer does not go through MCU DCACHE. It writes directly to memory. If DCACHE is enabled, the same memory location already hosted in cache."
          ]
        },
        {
          "title": "delay in cortex_m::asm - Rust - Docs.rs",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/asm/fn.delay.html",
          "excerpts": [
            "The `delay` function blocks the program for at least `cycles` CPU cycles, implemented in assembly, and is useful for simple timer-less initialization."
          ]
        },
        {
          "title": "Delay in cortex_m::delay - Rust - Docs.rs",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/delay/struct.Delay.html",
          "excerpts": [
            "The `Delay` struct uses the system timer (SysTick) for delays, configured with `new` or `with_source`, and can delay in µs (`delay_us`) or ms (`delay_ms`)."
          ]
        },
        {
          "title": "Delay and Timeout using Monotonics - Real-Time Interrupt- ...",
          "url": "https://rtic.rs/2/book/en/by-example/delay.html",
          "excerpts": [
            "A convenient way to express miniminal timing requirements is by delaying progression. This can be achieved by instantiating a monotonic timer.",
            "    Mono::start(cx.core.SYST, 12_000_000);",
            "A *software* task can `await` the delay to expire:",
            "    Mono::delay(100.millis()).await;",
            "A complete example",
            "//! examples/async-delay.rs",
            "Real-Time Interrupt-driven Concurrency",
            "======================================",
            "Delay and Timeout using Monotonics",
            "=========================================================================",
            "A convenient way to express miniminal timing requirements is by delaying progression. This can be achieved by instantiating a monotonic timer (for implementations, see [`rtic-monotonics`](https://github.com/rtic-rs/rtic/tree/master/rtic-monotonics)):",
            "A convenient way to express miniminal timing requirements is by delaying progression. This can be achieved by instantiating a monotonic timer (for implementations, see [`rtic-monotonics`](https://github.com/rtic-rs/rtic/tree/master/rtic-monotonics)):",
            "\n\nA complete example",
            "Rust [`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)s (underlying Rust `async`/`await`) are composable. This makes it possible to `select` in between `Futures` that have completed.",
            "In cases where you want exact control over time without drift we can use exact points in time using `Instant`, and spans of time using `Duration`. Operations on the `Instant` and `Duration` types come from the [`fugit`](https://crates.io/crates/fugit) crate.",
            "```\n//! examples/async-timeout.rs\n\n#! [no_main]\n#! [no_std]\n#! [deny(warnings)]\n#! [deny(unsafe_code)]\n#! [deny(missing_docs)]\n\nuse cortex_m_semihosting::{debug, hprintln};\nuse panic_semihosting as _;\nuse rtic_monotonics::systick::prelude::*;\nsystick_monotonic! (Mono, 100);\n\n#[rtic::app(device = lm3s6965, dispatchers = [SSI0, UART0], peripherals = true)]\nmod app {\n    use super::*;\n    use futures::{future::FutureExt, select_biased};\n\n    #[shared]\n    struct Shared {}\n\n    #[local]\n    struct Local {}\n\n    // ANCHOR: init\n    #[init]\n    fn init(cx: init::Context) -> (Shared, Local) {\n        hprintln!\n(\"init\");\n\n        Mono::start(cx.core.SYST, 12_000_000);\n        // ANCHOR_END: init\n\n        foo::spawn().ok();\n\n        (Shared {}, Local {})\n    }\n\n    #[task]\n    async fn foo(_cx: foo::Context) {\n        // ANCHOR: select_biased\n        // Call hal with short relative timeout using `select_biased`",
            "            //",
            "        // ANCHOR_END: select_biased"
          ]
        },
        {
          "title": "rtic-time - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/rtic-time",
          "excerpts": [
            "This crate is to define the Monotonic trait. It serves as a standardized interface for libraries to interact with the system's monotonic timers."
          ]
        },
        {
          "title": "tock-registers - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/tock-registers",
          "excerpts": [
            "The crate provides three types for working with memory mapped registers:\n`ReadWrite`, `ReadOnly`, and `WriteOnly`, providing read-write, read-only, and\nwrite-only functionality, respectively. These types implement the `Readable`,\n`Writeable` and `ReadWriteable` traits.",
            "Nice type checking\n------------------\n\nThis interface helps the compiler catch some common types of bugs via type checking. If you define the bitfields for e.g. a control register, you can give them a\ndescriptive group name like `Control`. This group of bitfields will only work\nwith a register of the type `ReadWrite<_, Control>` (or `ReadOnly/WriteOnly`,\netc).",
            "Naming conventions\n------------------\n\nThere are several related names in the register definitions. Below is a\ndescription of the naming convention for each:\n\n```\nuse tock_registers::registers::ReadWrite;\n\n#[repr(C)]\nstruct Registers {\n    // The register name in the struct should be a lowercase version of the\n    // register abbreviation, as written in the datasheet:\n    cr: ReadWrite<u8, Control::Register>,\n}\n\nregister_bitfields! [\n    u8,\n\n    // The name should be the long descriptive register name,\n    // camelcase, without the word 'register'. Control [\n        // The field name should be the capitalized abbreviated\n        // field name, as given in the datasheet.",
            "This interface helps the compiler catch some common types of bugs via type checking."
          ]
        },
        {
          "title": "register - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/register",
          "excerpts": [
            "register-rs. Unified interface for type-safe MMIO and CPU register access in Rust. Outline. Usage. Defining MMIO registers."
          ]
        },
        {
          "title": "tock_registers - Rust",
          "url": "https://docs.rs/tock-registers",
          "excerpts": [
            "The tock_registers crate provides efficient mechanisms to express and use type-checked memory mapped registers and bitfields."
          ]
        },
        {
          "title": "tock_registers - Rust - kernel",
          "url": "https://docs.tockos.org/tock_registers/",
          "excerpts": [
            "Tock Register Interface Provides efficient mechanisms to express and use type-checked memory mapped registers and bitfields."
          ]
        },
        {
          "title": "Bitfields - The Rust How-to Book - Crunch'n Numbers",
          "url": "https://john-cd.com/rust_howto/categories/data-structures/bitfield.html",
          "excerpts": [
            "A bitfield is a data structure that efficiently stores a sequence of bits. It is a way to represent a set of boolean flags or options in a compact manner, ..."
          ]
        },
        {
          "title": "bitflags - Rust",
          "url": "https://docs.rust-embedded.org/rust-sysfs-gpio/bitflags/index.html",
          "excerpts": [
            "A typesafe bitmask flag generator useful for sets of C-style bitmask flags. It can be used for creating typesafe wrappers around C APIs."
          ]
        },
        {
          "title": "Considerations for 2.0 · Issue #262 · bitflags ...",
          "url": "https://github.com/bitflags/bitflags/issues/262",
          "excerpts": [
            "Oct 25, 2021 — The idea was to make it unsafe to construct flags using bits that don't correspond to flags specified. That way an implementor could consider using things like ..."
          ]
        },
        {
          "title": "Why isn't the Rustonomicon up to-date? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/pvsq9a/why_isnt_the_rustonomicon_up_todate/",
          "excerpts": [
            "The Rustonomicon is one of the greatest sources of knowledge about Rust because it describes many concepts in simple and straightforward terms."
          ]
        },
        {
          "title": "Do i need a (c/c++) volatile variable in rust",
          "url": "https://users.rust-lang.org/t/do-i-need-a-c-c-volatile-variable-in-rust/3236",
          "excerpts": [
            "Volatile only implies a memory barrier in Java. In C it does prevent the compiler from reordering the accesses, but not the CPU, so using it ..."
          ]
        },
        {
          "title": "A Rust library crate with types for safe MMIO device access - GitHub",
          "url": "https://github.com/google/safe-mmio",
          "excerpts": [
            "This crate provides types for safe MMIO device access, especially in systems with an MMU. This is not an officially supported Google product."
          ]
        },
        {
          "title": "bitfields - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/bitfields",
          "excerpts": [
            "Usable in no_std environments. Compile-time checks for fields, types, and bits bounds checking. Supports most primitive and user-defined custom ..."
          ]
        },
        {
          "title": "tartan_bitfield - Rust",
          "url": "https://docs.rs/tartan-bitfield",
          "excerpts": [
            "This crate can be used to define structures with accessors for particular bits or bit ranges. Useful for dealing with registers and protocols."
          ]
        },
        {
          "title": "Rust macro for generating flexible bitfields, useful for low- ...",
          "url": "https://www.reddit.com/r/rust/comments/1hfkohx/rust_macro_for_generating_flexible_bitfields/",
          "excerpts": [
            "Here's my take on implementing a procedure macro to generate bitfield structs. I've been writing emulators and needed a way to quickly define bitfields."
          ]
        },
        {
          "title": "How to declare typed bitflags in Rust?",
          "url": "https://stackoverflow.com/questions/40332112/how-to-declare-typed-bitflags-in-rust",
          "excerpts": [
            "I am aware of the bitflags crate, but would like to know if this can be achieved with Rust's type-system, without having to implement operators ..."
          ]
        },
        {
          "title": "Managing Cache Coherency on Cortex-M7 Based MCUs",
          "url": "https://ww1.microchip.com/downloads/en/DeviceDoc/Managing-Cache-Coherency-on-Cortex-M7-Based-MCUs-DS90003195A.pdf",
          "excerpts": [
            "Apr 25, 2018 — When using the cache clean and cache invalidate by address APIs: ... After a Cache Invalidate Operation, Reads Out of D-Cache by CPU are Coherent.",
            "Once the DMA read operation is complete, the receive buffer in cache is invalidated using the cache invalidate API."
          ]
        },
        {
          "title": "Does the concept of a compiler fence make any sense? #347",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines/issues/347",
          "excerpts": [
            "Jul 5, 2022 — How does one enforce ordering between volatile and non-volatile ops. this is what I've been using compiler_fence for, I need some way to ..."
          ]
        },
        {
          "title": "Bit-Fields - Rhai - Embedded Scripting for Rust",
          "url": "https://rhai.rs/book/language/bit-fields.html",
          "excerpts": [
            "Bit-fields are very commonly used in embedded systems which must squeeze data into limited memory. Built-in support makes handling them efficient."
          ]
        },
        {
          "title": "Register Access problem - embedded - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/register-access-problem/122706",
          "excerpts": [
            "After checking some dependencies, I found that this is because probe-rs does not support #![no_std] . It needs std functionality in the gimli ...",
            "I tried accessing the registers using their addresses, but I couldn't get it to work.It throws unsafe errors. Please provide a solution, as ..."
          ]
        },
        {
          "title": "`enable_icache` is wrong on M7 without `inline-asm` feature",
          "url": "https://github.com/rust-embedded/cortex-m/issues/232",
          "excerpts": [
            "Jul 2, 2020 — If enabling instruction and/or data caches on your M7 is causing weird crashes, turn on the cortex_m inline-asm feature and make sure you're compiling at -- ..."
          ]
        },
        {
          "title": "Does the C++ volatile keyword introduce a memory fence?",
          "url": "https://stackoverflow.com/questions/26307071/does-the-c-volatile-keyword-introduce-a-memory-fence",
          "excerpts": [
            "First of all, the C++ standards do not guarantee the memory barriers needed for properly ordering the read / writes that are non atomic."
          ]
        },
        {
          "title": "Bitfields Forever: Why we need a C-compatible Rust Crate",
          "url": "https://www.reddit.com/r/rust/comments/euxy49/bitfields_forever_why_we_need_a_ccompatible_rust/",
          "excerpts": [
            "It is insane that Rust, pretending to be a system-level programming language, has no direct support for bit-fields. This makes C a better language for things ..."
          ]
        },
        {
          "title": "Is a bit field any more efficient (computationally) than ...",
          "url": "https://stackoverflow.com/questions/1484021/is-a-bit-field-any-more-efficient-computationally-than-masking-bits-and-extrac",
          "excerpts": [
            "The compiler generates the same instructions that you would explicitly write to access the bits. So don't expect it to be faster with bitfields."
          ]
        },
        {
          "title": "Memory-Mapped Registers in Tock",
          "url": "https://www.tockos.org/blog/2018/mmio-registers/",
          "excerpts": [
            "Microcontrollers typically use [memory-mapped\nI/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O) interfaces to\ncontrol hardware peripherals such as external interfaces (e.g. UART or\nADC) as well as internal features (e.g. timers or power states). Each memory\naddress for interacting with a specific peripheral is known as a *register*. Each register has a number of *fields*: a set of one or more\nbits that can be read to indicate or written to activate one logical ability\nin the peripheral.",
            "`svd2regs` parses the SVD\nfile for a microcontroller and generates the Tock register interface code for a\nspecified register. We’re really excited about `svd2regs` because it reduces the effort for Tock to\nsupport a new chip. One of the more tedious parts of adding peripheral drivers\nis the creation of its registers structures, which is now automated, reducing\nthe possibility for human-error in transcription.",
            " Comparison to `svd2rust`\n------------------------\n\nTock’s register interface is not the only effort to add compile-time\nchecking and access control to memory-mapped registers. [`svd2rust`](https://github.com/japaric/svd2rust) also automatically generates\nregister maps in Rust from SVD files. The\n[register system](https://docs.rs/svd2rust/0.12.1/svd2rust/) is very\nsimilar in capability to the Tock register interface, especially for SVDs with\nenumerated values. One notable difference between the two interfaces is that `svd2rust` relies on\nclosures to guarantee compile-time checks, while Tock does not. For example,\nhere is LED blink code written using both interfaces. The example is taken from\nthe [STM32F042 repo](https://github.com/therealprof/stm32f042/blob/master/examples/blinky.rs). Example with the Tock register interface:\n\n```\nfn main() {\n    let rcc_regs: &RccRegisters = &*RCC_BASE;\n    let gpioa_regs: &GpioaRegisters = &*GPIOA_BASE;\n\n    /* Enable clock for SYSCFG, else everything will\n     * behave funky!",
            "Driver code uses these memory-mapped registers and fields to\ninteract with the peripheral while providing a higher-level interface to the\nrest of the system.",
            "Mistakes in memory maps are a real concern in embedded software. Mistakenly\nwriting to an unintended bit could, in the best case, fail to have to the expected\neffect. Worse, it could have an entirely unexpected effect in the\nlow-level hardware.",
            "Tock Registers\n--------------\n\nThe first way that Tock avoids possible mistakes in peripheral memory map\ninteractions is to encapsulate them in a defined type, the\n[Tock Register Interface](https://github.com/tock/tock/tree/master/libraries/tock-register-interface),\nthat is capable of providing compile-time checks. First, the register interface has a particular way to define registers and\nfields within them. Each register is marked as `ReadOnly`, `WriteOnly`,\nor `ReadWrite`, which matches the way the hardware exposes them. Then\ndrivers are only able to use functions (such as `read` or `write`)\ncorresponding to the capabilities of a register when accessing it.",
            "For example, here’s a snippet from the SAM4L USART registers, which defines the\nControl Register (`cr`) and Mode Register (`mr`), both of which are 32-bit\nregisters. ```\nstruct UsartRegisters {\n    // Control register: 32-bits, write-only\n    cr: WriteOnly<u32, Control::Register>,\n    // Mode register: 32-bits, read-write\n    mr: ReadWrite<u32, Mode::Register>,\n    ...\n}\n\n```",
            "Next, each register’s fields are defined with their offsets within the\nregister and their lengths (both in bits). If the values for a field have\nnames, those are also included. For example, here are a subset of the fields for the SAM4L USART mode register. The `OFFSET` specification is the bit location of the start of the field in the\n32-bit register. The `NUMBITS` specification is the length of the field. While\nthe `CLK0` and `FILTER` fields are only a single bit and can either be\nactivated or not, the `MODE` register has several specified states which the\nUART can be in. ```\nregister_bitfields!\n ... \n"
          ]
        },
        {
          "title": "Modular Bitfields for Rust",
          "url": "https://crates.io/crates/modular-bitfield",
          "excerpts": [
            "`no_std`: Supports embedded development without `std` library.",
            "· This crate uses and generates 100% safe Rust code.",
            "— Modular Bitfields for Rust",
            "Easily define bitfield types with modular building blocks."
          ]
        },
        {
          "title": "modular-bitfield Documentation (no_std and safety)",
          "url": "https://docs.rs/modular-bitfield",
          "excerpts": [
            "Provides macros to support bitfield structs allowing for modular use of bit-enums."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust DMA Example (No-std / MMIO style considerations)",
          "url": "https://blog.theembeddedrustacean.com/stm32f4-embedded-rust-at-the-hal-dma-controllers",
          "excerpts": [
            "In the `Shared` struct the only entity that needs to be allocated as a shared resource is 'transfer' which is of type `DMATransfer` . `transfer` will be needed by the DMA interrupt task/ISR to enable access tp the DMA and retrieve the converted ADC data. Additionally, `transfer` will be needed by the timer interrupt task to kick off the next ADC conversion as `transfer` will own the ADC peripheral.",
            "In the 'Local' resources struct I include the USART transmitter, the timer counter, and finally, the buffer that the DMA will utilize. Note that the type of `buffer` is `Option<&'static mut [u16; 2]>` which also will be explained in more detail downstream.",
            "```rust\n#[local]\n    struct Local {\n        tx: Tx<USART2>,\n        buffer: Option <& 'static mut [ u16 ; 2 ]>,\n        timer: CounterHz<TIM2>,\n    }\n```",
            "\n`tx` and `buffer` will be utilized only by the DMA interrupt task, and `timer` will be utilized only by the timer interrupt task.",
            "#[task(binds = DMA2_STREAM0, shared = [transfer] , local = [tx, buffer])]\n`",
            "The `DMA2_STREAM0` name comes from the interrupt enum list for the stm32f4xx-hal. The task attribute also includes the list of resources that will be used in the implementation. This includes `buffer` that contains the second buffer that will be passed to the next rransfer.",
            "```rust\nlet buffer = shared.transfer.lock(|transfer| {\n            let (buffer, _) = transfer\n                .next_transfer(local.buffer.take().unwrap())\n                .unwrap();\n            buffer\n        });\n```",
            "Note what is being passed to `next_transfer` which is `local.buffer.take().unwrap()` . This is why I earlier defined the `buffer` type as an `Option<&'static mut [u16; 2]>` . Here I am passing ownership of `local.buffer` to `transfer` using the `take()` method and leaving `None` in its place, then I use the `unwrap()` method to unwrap the `Option` and pass the buffer.",
            "// Read out values from buffer\n        let mic1 = buffer[ 0 ];\n        let mic2 = buffer[ 1 ];\n\n        // Return buffer to resources pool for next transfer\n        *local.buffer = Some (buffer);\n\n        // Send over data to UART\n        writeln! (local.tx, \"/*{:01},{:02}*/\\r\" , mic1, mic2).unwrap();",
            "Sep 12, 2022 — In this post, I will be setting up the STM32F4 DMA engine to collect ADC samples from two microphones and print the values out to the console using UART.",
            "What was quite interesting was that, compared to other STM32 peripherals at the HAL, DMA was a different animal.",
            " serial configuration remains exactly the same as I've done several times before in prior posts (the original post for configuring serial is [here",
            "The serial configuration remains exactly the same as I've done several times before in prior posts",
            "#### ⏳ Timer Configuratio",
            "I'll need a timer as mentioned earlier to kick off the ADC conversion at regular intervals. to configure the timer it needs to be initialized to obtain a handle, then set up a listener to generate interrupts on update events, and finally, start the timer with a 1000 Hz interrupt rate.",
            " Configuration\n       ",
            "1️⃣ **Split and obtain a handle for DMA:** Each DMA consists of multiple streams, sort of like how GPIO consists of multiple pins per port.",
            "2️⃣ **Configure DMA:** Similar to other peripherals that need configuration like the ADC, there is a default configuration that exists.",
            "Finally, the ADC results are transmitted over UART using the `writeln!` macro:",
            "### 📱📱 Full Application Code",
            "Here is the full code for the implementation described in this post."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: DMA Controllers",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-hal-dma-controllers-daf",
          "excerpts": [
            "Sep 12, 2022 — In this post, I will be setting up the STM32F4 DMA engine to collect ADC samples from two microphones and print the values out to the console using UART."
          ]
        },
        {
          "title": "Volatile and sensitive memory - Page 4 - language design",
          "url": "https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188?page=4",
          "excerpts": [
            "It is UB to access a dangling pointer, volatile or not. But a pointer to MMIO-backed memory is not dangling. In general, a compiler cannot ..."
          ]
        },
        {
          "title": "DMB, DSB, and ISB",
          "url": "https://developer.arm.com/documentation/dui0489/e/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb",
          "excerpts": [
            "Data Memory Barrier acts as a memory barrier. It ensures that all explicit memory accesses that appear in program order before the DMB instruction are ...",
            "DMB, DSB, and ISB. Data Memory Barrier, Data Synchronization Barrier, and Instruction Synchronization Barrier."
          ]
        },
        {
          "title": "DMB, DSB, and ISB",
          "url": "https://developer.arm.com/documentation/dui0489/h/arm-and-thumb-instructions/dmb--dsb--and-isb",
          "excerpts": [
            "Data Memory Barrier acts as a memory barrier. It ensures that all explicit memory accesses that appear in program order before the DMB instruction are ..."
          ]
        },
        {
          "title": "Which ARM memory barrier guarantees that one of two ...",
          "url": "https://stackoverflow.com/questions/58616431/which-arm-memory-barrier-guarantees-that-one-of-two-threads-will-observe-what-th",
          "excerpts": [
            "The DMB is sufficient to ensure that the writes to x1 and x2 are complete before y1 or y2 is updated using normal memory."
          ]
        },
        {
          "title": "tock_registers::registers - Rust",
          "url": "https://docs.rs/tock-registers/latest/tock_registers/registers/index.html",
          "excerpts": [
            "ReadWrite for registers which can be read and written to · ReadOnly for registers which can only be read · WriteOnly for registers which can only be written to ..."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the PAC: svd2rust",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-pac-svd2rust-457d",
          "excerpts": [
            "Feb 6, 2023 — In this post, I go through an example of the steps to generate a PAC from an SVD file for the STM32F401 device.",
            "svd2rust grabs what is called an svd file and converts it into a PAC exposing API allowing access to peripheral registers. An SVD file is an ..."
          ]
        },
        {
          "title": "tock_registers::fields - Rust",
          "url": "https://docs.tockos.org/tock_registers/fields/",
          "excerpts": [
            "The following example demonstrates how two registers can be defined, over a u32 base type: register_bitfields![u32, Uart [ ENABLE OFFSET(0) NUMBITS(4) [ ON ..."
          ]
        },
        {
          "title": "svd2pac - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/svd2pac",
          "excerpts": [
            "May 28, 2025 — It uses the ldmst instruction to read-modify-write a value in a register. This instruction blocks the bus until the end of the transaction."
          ]
        },
        {
          "title": "LDR and STR, immediate offset",
          "url": "https://developer.arm.com/documentation/dui0552/latest/the-cortex-m3-instruction-set/memory-access-instructions/ldr-and-str--immediate-offset",
          "excerpts": [
            "LDR instructions load one or two registers with a value from memory. STR instructions store one or two register values to memory."
          ]
        },
        {
          "title": "Static array ownership and move - help",
          "url": "https://users.rust-lang.org/t/static-array-ownership-and-move/14981",
          "excerpts": [
            "Jan 11, 2018 — The dma code is designed like a future. The idea is that the dma takes control of the buffer and returns it in the interrupt when its done."
          ]
        },
        {
          "title": "Avoid Busy waiting when waiting for a signal - Stack Overflow",
          "url": "https://stackoverflow.com/questions/63335066/avoid-busy-waiting-when-waiting-for-a-signal",
          "excerpts": [
            "On a microcontroller, busy-waiting is normal. The alternative is to set up an interrupt, and set the microcontroller to sleep mode when you're waiting for an ..."
          ]
        },
        {
          "title": "What memory model should Rust use? - Hacker News",
          "url": "https://news.ycombinator.com/item?id=29109156",
          "excerpts": [
            "Rust can generate WASM code that, when using volatile, has many duplicated loads and stores in some order. ... Using volatile in mmio code on ..."
          ]
        },
        {
          "title": "Embedded + RTFM + Timer Queue: Blocking wait? - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/embedded-rtfm-timer-queue-blocking-wait/25369",
          "excerpts": [
            "I am trying to use the cortex-m-rtfm with the timer-queue feature, but at the same time I need to do a blocking wait inside the init function."
          ]
        },
        {
          "title": "The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/dma.html",
          "excerpts": [
            "This section covers the core requirements for building a memory safe API around\nDMA transfers. The DMA peripheral is used to perform memory transfers in parallel to the work\nof the processor (the execution of the main program). A DMA transfer is more or\nless equivalent to spawning a thread (see [`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) ) to do a `memcpy` . We'll use the fork-join model to illustrate the requirements of a memory-safe\nAPI. Consider the following DMA primitives:\n\n```\n```rust\n#!\n ... \n[allow(unused)]\nfn main() {\n/// A singleton that represents serial port #1\npub struct Serial1 {\n    // NOTE: we extend this struct by adding the DMA channel singleton\n    dma: Dma1Channel1,\n    // ..\n}\n\nimpl Serial1 {\n    /// Sends out the given \\`buffer\\`\n    ///\n    /// Returns a value that represents the in-progress DMA transfer\n    pub fn write_all<'a>(mut self, buffer: &'a [u8]) -> Transfer<&'a [u8]> {\n        self.dma.set_destination_address(USART1_TX, false);\n        self.dma.set_source_address(buffer.as_ptr() as usize, true);\n        self.dma.set_transfer_length(buffer.len());\n\n        self.dma.start();\n\n        Transfer { buffer }\n    }\n}\n\n/// A DMA transfer\npub struct Transfer<B> {\n    buffer: B,\n}\n\nimpl<B> Transfer<B> {\n    /// Returns \\`true\\` if the DMA transfer has finished\n    pub fn is_done(&self) -> bool {\n        !Dma1Channel1::in_progress()\n    }\n\n    /// Blocks until the transfer is done and returns the buffer\n    pub fn wait(self) -> B {\n        // Busy wait until the transfer is done\n        while !self.is_done() {}\n\n        self.buffer\n    }\n}\n}\n```\n```\n\n> **NOTE:** `Transfer` could expose a futures- or generator-based API instead of\n> the API shown above. That's an API design question that has little bearing on\n> the memory safety of the overall API so we won't delve into it in this text. We can also implement an asynchronous version of [`Read::read_exact`](https://doc.rust-lang.org/std/io/trait.Read.html.read_exac"
          ]
        },
        {
          "title": "cortex-m-rt/link.x.in at master",
          "url": "https://github.com/rust-embedded/cortex-m-rt/blob/master/link.x.in",
          "excerpts": [
            "Jan 24, 2022 — ERROR(cortex-m-rt): The .text section must be placed inside the FLASH memory. Set _stext to an address smaller than 'ORIGIN(FLASH) + LENGTH ...",
            "Jan 24, 2022 — Minimal startup / runtime for Cortex-M microcontrollers - cortex-m-rt/link.x.in at master · rust-embedded/cortex-m-rt.",
            "Jan 24, 2022 — ERROR(cortex-m-rt): The .text section must be placed inside the FLASH memory. Set _stext to an address smaller than 'ORIGIN(FLASH) + LENGTH ...See more"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "/* Linker script for the STM32F303VCT6 */\nMEMORY\n{\n/* NOTE 1 K = 1 KiBi = 1024 bytes */\nFLASH : ORIGIN = 0x08000000, LENGTH = 256K\nRAM : ORIGIN = 0x20000000, LENGTH = 40K\n}\nNOTE : If you for some reason changed the\nmemory.x file after you had made\nthe first build of a specific build target, then do\ncargo clean before\ncargo build , because\ncargo build may not track updates of\nmemory.x .",
            "The second step is to enter the memory region information into the memory.x file.",
            "/* Linker script for the STM32F303VCT6 */",
            "/* NOTE 1 K = 1 KiBi = 1024 bytes */",
            "FLASH : ORIGIN = 0x08000000, LENGTH = 256K",
            "RAM : ORIGIN = 0x20000000, LENGTH = 40K",
            "We'll use",
            "thumbv7em-none-eabihf as that covers the Cortex-M4F core.",
            "NOTE : As you may remember from the previous chapter, we have to install\nall targets and this is a new one. So don't forget to run the installation\nprocess",
            "rustup target add thumbv7em-none-eabihf for this target.",
            "memory",
            "{",
            "}"
          ]
        },
        {
          "title": "cortex-m-quickstart/memory.x at master",
          "url": "https://github.com/rust-embedded/cortex-m-quickstart/blob/master/memory.x",
          "excerpts": [
            "Use this variable to locate the call stack and static variables in different memory regions. Below is shown the default value."
          ]
        },
        {
          "title": "rust - How to get the linker to produce a map file using Cargo",
          "url": "https://stackoverflow.com/questions/39310905/how-to-get-the-linker-to-produce-a-map-file-using-cargo",
          "excerpts": [
            "I'm writing a Rust program targeted for an STM32F407 processor using zinc. I'd like to be able to produce a linker map file."
          ]
        },
        {
          "title": "The use of linker files (.ld files) in embedded bare-metal ...",
          "url": "https://stackoverflow.com/questions/78846171/the-use-of-linker-files-ld-files-in-embedded-bare-metal-programming",
          "excerpts": [
            "Targets other than arm, risc-v for example can/will generate .sdata, .sbss as well as .data and .bss and other sections specific to what the ..."
          ]
        },
        {
          "title": "Linker Scripts",
          "url": "http://wiki.osdev.org/Linker_Scripts",
          "excerpts": [
            "A Linker script's principal use is specifying the format and layout of the final executable binary. This is of particular relevance to operating-system ..."
          ]
        },
        {
          "title": "no_unique_section_names - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/compiler-flags/no-unique-section-names.html",
          "excerpts": [
            "It prevents the generation of unique ELF section names for each separate code and data item when -Z function-sections is also in use."
          ]
        },
        {
          "title": "Generate memory map file for embedded compilation",
          "url": "https://users.rust-lang.org/t/generate-memory-map-file-for-embedded-compilation/111761",
          "excerpts": [
            "I find it really useful to generate a map file. This file contains specific information on where certain segments and data structures are placed."
          ]
        },
        {
          "title": "What's the deal with LTO? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/ijwya5/whats_the_deal_with_lto/",
          "excerpts": [
            "LTO allows optimisations across crates. Yes, for all functions, not only generic ones. It also allows optimization inside a crate, but across codegen units."
          ]
        },
        {
          "title": "All Aboard, Part 3: Linker Relaxation in the RISC-V Toolchain",
          "url": "https://www.sifive.com/blog/all-aboard-part-3-linker-relaxation-in-riscv-toolchain",
          "excerpts": [
            "Aug 28, 2017 — Linker relaxation is a mechanism for optimizing programs at link-time, as opposed to traditional program optimization which happens at compile-time."
          ]
        },
        {
          "title": "Logging with symbols - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/logging.html",
          "excerpts": [
            "Logging with symbols. This section will show you how to utilize symbols and the ELF format to achieve super cheap logging."
          ]
        },
        {
          "title": "Creating a 64-bit kernel",
          "url": "http://wiki.osdev.org/Creating_a_64-bit_kernel",
          "excerpts": [
            "Feel free to edit this linker script to suit your needs. Set ENTRY(...) to your entry function, and KERNEL_VMA to your base virtual address. You can link the ..."
          ]
        },
        {
          "title": "Bare metal RISC-V CPU - how does the processor know ...",
          "url": "https://stackoverflow.com/questions/69834360/bare-metal-risc-v-cpu-how-does-the-processor-know-which-address-to-start-fetch",
          "excerpts": [
            "I am imagining I will hardcode in the processor that the instructions start at memory address X and data is available at memory address Y and ..."
          ]
        },
        {
          "title": ".sdata2/.sbss2 section generated by toolchain",
          "url": "https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/JV5Jdh4UjVw",
          "excerpts": [
            "As far as I know, the riscv toolchain does not use sdata2 sections. It does use srodata sections which are similar, but are placed next to the small data ..."
          ]
        },
        {
          "title": "Set Up Rust | Writing an OS in Rust (First Edition)",
          "url": "https://os.phil-opp.com/set-up-rust/",
          "excerpts": [
            "This blog series creates a small operating system in the Rust programming language. Each post is a small tutorial and includes all needed ..."
          ]
        },
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "A section is a collection of symbols laid out in contiguous memory. Symbols, in turn, can be data (a static variable), or instructions (a Rust function).",
            "The vector table is an array of pointers; the first two pointers are required to boot the device,\nthe rest of the pointers are related to exceptions.",
            "The reset handler is the function that the\ndevice will execute after a system reset, or after it powers up for the first time.",
            " created in Rust code\nand placed correctly using the linker script. The reset vector is a pointer into the reset handler.",
            "The reset vector is a pointer into the reset handler. The reset handler is the function that the\ndevice will execute after a system reset, or after it powers up for the first time. The reset\nhandler is always the first stack frame in the hardware call stack; returning from it is undefined\nbehavior as there's no other stack frame to return to.",
            "# [The linker script side]()",
            "A minimal linker script that places the vector table in the correct location is shown below. Let's\nwalk through it.",
            "/* Memory layout of the LM3S6965 microcontroller */",
            "memory",
            "MEMORY\n{\n  FLASH : ORIGIN = 0x00000000, LENGTH = 256K\n  RAM : ORIGIN = 0x20000000, LENGTH = 64K\n}",
            "#[no_mangle]\npub static RESET_VECTOR: unsafe extern \"C\" fn() -> ! = Reset;",
            "ENTRY(Reset);",
            "EXTERN(RESET_VECTOR);",
            "sections",
            "{",
            "{",
            "SECTIONS\n{\n  .vector_table ORIGIN(FLASH) :\n  {\n    /* First entry: initial Stack Pointer value */\n    LONG(ORIGIN(RAM) + LENGTH(RAM));\n\n    /* Second entry: reset vector */\n    KEEP(*(.vector_table.reset_vector));\n  } > FLASH",
            "    /* First entry: initial Stack Pointer value */",
            "    LONG(ORIGIN(RAM) + LENGTH(RAM));",
            "    /* Second entry: reset vector */",
            "    KEEP(*(.vector_table.reset_vector));",
            "  .text :",
            "    *(.text .text. *);",
            "  } > FLASH",
            "  } > FLASH",
            "  /DISCARD/ :",
            "  {",
            "  {",
            "  {",
            "    *(.ARM.exidx .ARM.exidx. *);",
            "  }",
            "}",
            "}",
            "#[link_section = \".vector_table.reset_vector\"]"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "memory",
            "{",
            "}",
            "}",
            "}",
            "#!\n[no_std",
            "```",
            "```",
            "use std::env;"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "{",
            "}",
            "#!\n[no_std",
            "#!\n[no_std",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "}",
            "```"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "```"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Why I like programming for #![no_std] in Rust (even without ...",
          "url": "https://www.reddit.com/r/rust/comments/emq98r/why_i_like_programming_for_no_std_in_rust_even/",
          "excerpts": [
            "The main limitation is that you can't ever have a Vec or a HashMap or a HashSet or a Box, basically anything that goes on the heap."
          ]
        },
        {
          "title": "Status of LTO option - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/status-of-lto-option/49032",
          "excerpts": [
            "I discovered the lto = true in the [profile] section. This link time optimization leads to 17% performance increase on my release build."
          ]
        },
        {
          "title": "Cortex-M Runtime Documentation",
          "url": "https://docs.rust-embedded.org/cortex-m-quickstart/cortex_m_rt/index.html",
          "excerpts": [
            "This crate expects the user, or some other crate, to provide the memory layout of the target\ndevice via a linker script named `memory.x`.",
            "The linker script must specify the memory available in the device as, at least, two `MEMORY`\nregions: one named `FLASH` and one named `RAM`. The `.text` and `.rodata` sections of the\nprogram will be placed in the `FLASH` region, whereas the `.bss` and `.data` sections, as well\nas the heap,will be placed in the `RAM` region.",
            "This optional symbol can be used to indicate where the call stack of the program should be\nplaced. If this symbol is not used then the stack will be placed at the *end* of the `RAM`\nregion -- the stack grows downwards towards smaller addres",
            "This optional symbol can be used to control where the `.text` section is placed. If omitted the\n`.text` section will be placed right after the vector table, which is placed at the beginning of\n`FLASH`.",
            "The memory layout of the program. In particular, it populates the vector table so the device\n  can boot correctly, and properly dispatch exceptions and interrupt",
            "To actually build this program you need to place a `memory.x` linker script somewhere the linker\ncan find it, e.g. in the current directory; and then link the program using `cortex-m-rt`'s\nlinker script: `link.x`.",
            "This crate contains all the required parts to build a no_std application (binary crate) that targets a Cortex-M microcontroller."
          ]
        },
        {
          "title": "Bare Metal Rust on RISC-V With Dynamic Memory",
          "url": "https://popovicu.com/posts/bare-metal-rust-risc-v-with-dynamic-memory/",
          "excerpts": [
            "revious article, we have to provide a linker script in order to lay the program bytes properly into the memory. Our linker script now will look very similar to the old one, just with some added details. Let’s take a look:",
            "``\nMEMORY {\n  program (rwx) : ORIGIN = 0x80000000, LENGTH = 2 * 1024 * 1024\n}\n\nSECTIONS {\n  .text.boot : {\n    *(.text.boot)\n  } > program\n\n  .text : {\n    *(.text)\n  } > program\n\n  .data : {\n    *(.data)\n  } > program\n\n  .rodata : {\n    *(.rodata)\n  } > program\n\n  .bss : {\n    *(.bss)\n  } > program\n\n  . = ALIGN(8);\n  . = . + 4096;\n  _STACK_PTR = .\n;\n}\n```\n\nWe want to create a special section we’ll call `.text.boot` and make sure it’s laid out at `0x80000000`. This section will contain our warmup for entry to the Rust code. Following that will be any code that the Rust compiler generates, followed by the section for data, etc. After all that, we want to lay our **stack**. In this example, we allocated 4 KB for the stack. The last few lines should be fairly self explanatory:\n\n1. We align the stack to the 8 byte boundary. 2. We allocate 4 KB for the stack. 3. Now we capture the starting point of the stack. You may be curious why do we capture it higher in the address space — this is because the stack “grows downwards” per the convention, i.e. when something is added to the stack, the stack pointer is **subtracted from**. The way we *capture* the position of the stack is we export the symbol `_STACK_PTR` to be visible to our code and we use that symbol to get the value of the address. It should be clearer once we get to our assembly warmup code. Now we need to make sure that Cargo uses our link script. This is done by tweaking the Cargo",
            "Assembly warmup",
            "\n\nInside the `src` directory, we add a file called `entry.s` with the following contents:",
            "```\n\t.global _start\n\t.extern _STACK_PTR\n\n\t.section .text.boot\n\n_start:\tla sp, _STACK_PTR\n\tjal main\n\tj . ```",
            "The `_start` symbol is global. It’s the typical way to mark the starting point of a program.",
            "uild.rs`.\nAssembly warmup\n---------------\n\nInside the `src` directory, we add a file called `entry.s` with the following contents:\n\n```\n\t.global _start\n\t.extern _STACK_PTR\n\n\t.section .text.boot\n\n_start:\tla sp, _STACK_PTR\n\tjal main\n\tj . ```\n\nThe `_start` symbol is global. It’s the typical way to mark the starting point of a program. It doesn’t matter too much for us here, as we’ll lay the instructions at the right physical address anyway, but let’s keep it for consistency. We instruct the assembler that the `_STACK_PTR` symbol is external. There’s essentially a hole wherever `_STACK_PTR` is used and that hole will be filled up by the linker. The linker will figure out to calculate the value of the symbol per instructions from the linker script, and that value will be placed into the hole that is supposed to hold the `_STACK_PTR` value. Next we declare the start of the `.text.boot` section which we ensured in the linker script starts from `0x80000000` and so these will be the first instructions run by the machine. We basically just wanted to set up the stack pointer before we jump into the `main` function from our Rust code. The final `j` instruction ensures we keep looping in case where for whatever reason we ever exit the Rust `main` function, but that should really never happen, so the last instruction should be effectively dead code. Now that the stack pointer is set up and we are ready to jump into the `main`, let’s write the Rust code.\n",
            "Rust logic",
            "static mut ARENA: [u8; 50000] = [0; 50000];",
            "\n\n#[global_allocator]\nstatic ALLOCATOR: Talck<spin::Mutex<()>, ClaimOnOom> = Talc::new(unsafe {ClaimOnOom::new(Span::from_array(&mut ARENA))}).lock();",
            "The memory allocation happens on a static blob of 50k bytes, marked as `ARENA`. Rust has an abstraction layer for memory allocation that can also work under the bare metal environment.",
            ". This library is the reason why we needed `#! [feature(const_mut_refs)]` above; without it, we cannot modify the statically allocated `ARENA`.",
            "GitHub repo",
            "Over there, you can checkout the `README` file which will tell you how to build and run this on QEMU.",
            "Finally, I’d like to note that I’ve run into some issues with the dynamic strings, and that *may* be due to the `Talc` librar",
            "Copyright © 2025",
            "All rights reserved.",
            "Rust code.\nRust logic\n----------\n\nAgain inside the `src` directory, we should have a file called `main.rs`. The logic of the file will be simple, we just want to write to the UART device. This is done by writing bytes to the address `0x10000000`, as simple as that. We’ll write some messages, and actually, some of them will be dynamic strings, constructed in a way similar to `sprintf` in C. What we’ll do is we’ll count the periods (and we’ll do that by busy waiting some number of iterations to emulate the sleep behavior) and we’ll write to the UART something like `Tick N`, where N is the current number of the tick. However, to use Rust’s string formatting functionality, we’ll have to use dynamic memory allocation. This is typical of the regular apps running on top of an operating system, not so much of the bare metal applications. Let’s look at the code and comment it bit by bit. ```\n#! [no_std]\n#! [no_main]\n#! [feature(const_mut_refs)]\n\nuse core::arch::global_asm;\nuse core::ptr;\nuse core::panic::PanicInfo;\nuse talc::{Talck, Talc, ClaimOnOom, Span};\n\n#[macro_use]\nextern crate alloc;\n\nglobal_asm!(include_str!\n(\"entry.s\"));\n\nstatic mut ARENA: [u8; 50000] = [0; 50000];\n\n#[global_allocator]\nstatic ALLOCATOR: Talck<spin::Mutex<()>, ClaimOnOom> = Talc::new(unsafe {ClaimOnOom::new(Span::from_array(&mut ARENA))}).lock();\n\nfn uart_print(message: &str) {\n   const UART: *mut u8 = 0x10000000 as *mut u8;\n\n   for c in message.chars() {\n       unsafe {\n       \t      ptr::write_volatile(UART, c as u8);\n       }\n   }\n}\n\n#[no_mangle]\npub extern \"C\" fn main() -> ! {\n   uart_print(\"Hello, world!\\n\");\n\n   let mut ctr = 1;\n\n   loop {\n\tlet message = format! (\"Ticks: {}\\n\", ctr);\n\tlet temp_str = message.as_str();\n\n\tuart_print(temp_str);\n\tfor _ in 0..5000000 {}\n\n\tctr += 1;\n   }\n}\n\n#[panic_handler]\nfn panic(_info: &PanicInfo) -> ! {\n   uart_print(\"Something went wrong. \");\n   loop {}\n}\n```\n\n1. We specify that we’re not in the `std` environment. The code executes on a bare metal platform, so we cannot use the standard library, for obvious reasons. 2. There is really no `main` in the traditional sense. Basically, we’re instructing the compiler to not generate any entrance/warmup code for the main and jump into it, because there is no traditional entry. This may be confusing for some. The catch here is that even though when you normally write your program, the logic begins at the `main` function, that doesn’t mean that whatever is enclosed by `main` is the only logic that the CPU executes between the start and the end of the process."
          ]
        },
        {
          "title": "Rust OS Blog - Hello RISCV (Henry Greßmann)",
          "url": "https://blog.henrygressmann.de/rust-os/1-hello-riscv/",
          "excerpts": [
            "One thing you might also have noticed is the -Tmemory.x and -Tlink.x , our linker scripts.",
            "The executable format we'll use is ELF, as you can see from the `riscv64gc-unknown-none-elf` target we specified above. ELF is the format used by Linux and most other UNIX-like operating systems for storing executables.",
            "MEMORY\n{\n  RAM : ORIGIN = 0x80200000, LENGTH = 16M\n}\n",
            "REGION_ALIAS(\"REGION_TEXT\", RAM);\nREGION_ALIAS(\"REGION_RODATA\", RAM);\nREGION_ALIAS(\"REGION_DATA\", RAM);\nREGION_ALIAS(\"REGION_BSS\", RAM);\nREGION_ALIAS(\"REGION_HEAP\", RAM);\nREGION_ALIAS(\"REGION_STACK\", RAM);",
            "REGION_ALIAS(\"REGION_TEXT\", RAM);",
            "\n\nWe can now write our first program to ensure everything works as expected.",
            "build.rs",
            "```\n\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\nfn main() {\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n\n    fs::write(out_dir.join(\"memory.x\"), include_bytes! (\"memory.x\")).unwrap();\n    println! (\"cargo:rustc-link-search={}\", out_dir.display());\n    println! (\"cargo:rerun-if-changed=memory.x\");\n    println! (\"cargo:rerun-if-changed=build.rs\");\n}\n\n```",
            "I'll use QEMU to run our kernel. QEMU is a virtual machine that can emulate various CPUs and devices, including RISC-V. At the end of this ..."
          ]
        },
        {
          "title": "Under the Hook - The Cortex Runtime",
          "url": "https://dev.to/jenswritescode/under-the-hook-the-cortex-runtime-252m",
          "excerpts": [
            "Memory Layout. To understand more about the memory layout on ARM Cortex-M devices, let's look at the link.x.in and memory.x file. 1.1 Linker ..."
          ]
        },
        {
          "title": "riscv_minimal_rt - Rust",
          "url": "https://docs.rs/riscv-minimal-rt",
          "excerpts": [
            "A linker script that encodes the memory layout of a generic RISC-V microcontroller. This linker script is missing some information that must be supplied through ..."
          ]
        },
        {
          "title": "RISC-V from scratch 2: Hardware layouts, linker scripts, and C ...",
          "url": "https://twilco.github.io/riscv-from-scratch/2019/04/27/riscv-from-scratch-2.html",
          "excerpts": [
            "Apr 27, 2019 — The main purpose of the linker script is to describe how the sections in the input files should be mapped into the output file, and to control ..."
          ]
        },
        {
          "title": "A practical guide to linker section ordering | Red Hat Developer",
          "url": "https://developers.redhat.com/articles/2024/06/13/practical-guide-linker-section-ordering",
          "excerpts": [
            "Using a linker's section ordering feature allows experimentation with the layout of code and data in memory without the need to write full linker scripts."
          ]
        },
        {
          "title": "When reproducible builds? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/jct0y4/when_reproducible_builds/",
          "excerpts": [
            "In some domains, it is very important to be able to reproducibly rebuild a binary from the sources. This is cargo/rustc pretty bad at."
          ]
        },
        {
          "title": "Optimizing Rust Compilation: Smaller, Faster, or Both?",
          "url": "https://leapcell.medium.com/optimizing-rust-compilation-smaller-faster-or-both-1cdac7bfd93c",
          "excerpts": [
            "panic = \"abort\" # Use 'abort' instead of 'unwind' for panic handling strip = \"debuginfo\" # Remove debug information. Generate a Faster ...",
            "\n[profile.release]  \nopt-level = \"z\"       # Optimize for the smallest code size  \nlto = true            # Enable Link Time Optimization (LTO)  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but reducing binary size  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip = \"debuginfo\"   # Remove debug information\n",
            "\"thin\" : Enable Thin LTO. \"fat\" : Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. You only need to add the following configuration to your `Cargo.toml` file and run:\n\n```\ncargo b --release\n```",
            "Generate a Faster Executable\n============================\n\n```\n[profile.release]  \nopt-level = 3         # Optimize for maximum execution speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling\n```",
            "Balance Between Size and Speed\n==============================\n\n```\n[profile.release]  \nopt-level = \"s\"       # Optimize for size while considering speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip =\n\"symbols\"     # Remove symbol information while retaining necessary debugging info\n```",
            "Description: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable.",
            "codegen-units\n=============\n\nDescription: Controls the number of code generation units. Default value: Usually `16`. Setting it to `1` enables the highest level of optimization. Reasoning: Reducing the number of code generation units gives the compiler more information for global optimizations, resulting in a smaller and faster executable. Setting it to `1` maximizes optimization but increases compilation time.",
            "panic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip =\n\"symbols\"     # Remove symbol information while retaining necessary debugging info",
            "Explanation of Configurations\n=============================\n\nopt-level\n=========\n\nDescription: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "strip = \"debuginfo\"   # Remove debug information",
            "lto = \"fat\"           # Enable the most aggressive Link Time Optimization",
            "panic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling",
            "strip =",
            "\"symbols\"     # Remove symbol information while retaining necessary debugging info"
          ]
        },
        {
          "title": "Linker Script implementation notes and policy",
          "url": "https://lld.llvm.org/ELF/linker_script.html",
          "excerpts": [
            "When an output section has no input section, GNU ld will eliminate it if it only contains symbol assignments (e.g. .foo { symbol = 42; } ). LLD will retain such ..."
          ]
        },
        {
          "title": "[LLVMdev] [lld] Linker cannot handle sections with non-unique names",
          "url": "https://lists.llvm.org/pipermail/llvm-dev/2015-April/084607.html",
          "excerpts": [
            "[LLVMdev] [lld] Linker cannot handle sections with non-unique names. Shankar Easwaran shankarke at gmail.com. Sun Apr 19 15:44:43 PDT 2015."
          ]
        },
        {
          "title": "Failure to build crates with `split-debuginfo = \"packed\"` ...",
          "url": "https://github.com/rust-lang/rust/issues/104042",
          "excerpts": [
            "Nov 5, 2022 — I tried to build my codebase with the following, profile: [profile.release] codegen-units = 1 opt-level = 3 lto = \"fat\" panic = \"abort\" ..."
          ]
        },
        {
          "title": "RFC: syntax for a section ordering file - Sourceware",
          "url": "https://sourceware.org/pipermail/binutils/2024-April/133872.html",
          "excerpts": [
            "... lld's MachO port ld64.lld has ported the option. The feature is like ld.lld -- ... unique-section-names. * ld.lld --symbol-ordering-file ..."
          ]
        },
        {
          "title": "Reproducible Builds in June 2022",
          "url": "https://reproducible-builds.org/reports/2022-06/",
          "excerpts": [
            "David Wheeler filed an issue against the Rust programming language to report that builds are “not reproducible because full path to the source code is in the ..."
          ]
        },
        {
          "title": "RISC-V No-Std Rust Guide (dmytrish.net)",
          "url": "https://dmytrish.net/lib/riscv/linux/hello-rust-bare.html",
          "excerpts": [
            "The output of `cargo rustc -- -Z unstable-options --print target-spec-json` suggests that\n`riscv64-unknown-none-elf` uses [`rust.lld`](https://lld.llvm.org/) as its default linker. I did not dig into details, but I guessed that its default linker script uses a `_start` symbol\nas its entrypoint."
          ]
        },
        {
          "title": "cortex-m/cortex-m-rt/link.x.in at master",
          "url": "https://github.com/rust-embedded/cortex-m/blob/master/cortex-m-rt/link.x.in",
          "excerpts": [
            "Low level access to Cortex-M processors. Contribute to rust-embedded/cortex-m development by creating an account on GitHub."
          ]
        },
        {
          "title": "embedded-hal - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embedded-hal",
          "excerpts": [
            "Jan 9, 2024 — A Hardware Abstraction Layer (HAL) for embedded systems. This project is developed and maintained by the HAL team.",
            "Jan 9, 2024 — The embedded-hal-bus crate provides utilities for sharing SPI and I2C buses. Additionally, more domain-specific traits are available in separate ...",
            "Jan 9, 2024 — embedded-hal-nb : polling-based, using the nb crate. The embedded-hal-bus crate provides utilities for sharing SPI and I2C buses."
          ]
        },
        {
          "title": "embedded-hal - Comprehensive Rust - Google",
          "url": "https://google.github.io/comprehensive-rust/bare-metal/microcontrollers/embedded-hal.html",
          "excerpts": [
            "The embedded-hal crate provides a number of traits covering common microcontroller peripherals. Similar traits for byte streams (eg UARTs), CAN buses and RNGs.",
            "The embedded-hal crate provides a number of traits covering common microcontroller peripherals: GPIO; PWM; Delay timers; I2C and SPI buses and devices. Similar ...",
            "embedded-hal) crate provides a number of traits covering common\nmicrocontroller peripherals:\n\n* GPIO\n* PWM\n* Delay timers\n* I2C and SPI buses and devices\n\nSimilar traits for byte streams (e.g. UARTs), CAN buses and RNGs are broken out\ninto [`embedded-io`](https://crates.io/crates/embedded-io), [`embedded-can`](https://crates.io/crates/embedded-can) and [`rand_core`](https://crates.io/crates/rand_core) respectively. Other crates then implement [drivers](https://github.com/rust-embedded/awesome-embedded-rust) in terms of these trai"
          ]
        },
        {
          "title": "embedded-hal v1.0 now released!",
          "url": "https://blog.rust-embedded.org/embedded-hal-v1/",
          "excerpts": [
            "The Rust Embedded Working Group is proud to announce the release of `embedded-hal` version 1.0 together with the\ncompanion crates `embedded-hal-bus`, `embedded-hal-async` and `embedded-hal-nb`. Check out the [repository](https://github.com/rust-embedded/embedded-hal), the [API documentation](https://github.com/rust-embedded/embedded-hal) and the [migration guide](https://github.com/rust-embedded/embedded-hal/blob/master/docs/migrating-from-0.2-to-1.0.md). The `embedded-hal` crates provide traits (interfaces) for using peripherals commonly available in microcontrollers\nsuch as GPIO, UART, SPI or I2C. They allow writing drivers (for sensors, displays, actuators, network adapters, etc.) in\na generic way, so they work on any microcontroller with an `embedded-hal` implementation without\nmodifying them. It's a central piece of the Embedded Rust ecosystem, ensuring interoperability throughout. The 1.0 release has been in the works since 2020. Now that it's out, we consider all\ntraits in it to be *stable*.",
            "embedded-io\n-----------",
            "The `embedded-hal` project also hosts the `embedded-io` crates. They provide traits for byte-oriented I/O streams. Since serial\nports (UART) are essentially byte streams, the serial-specific traits in `embedded-hal` have been removed in favor of `embedded-io`. `embedded-io` has not reached 1.0 yet, but we expect that to happen in 2024.",
            "The [`SpiDevice`](https://docs.rs/embedded-hal/1.0.0/embedded_hal/spi/index.html) trait now allows sharing a SPI bus between multiple devices, each selected with its own CS pin. The design allows for unrelated drivers to talk to different devices in the same bus without conflicts and without being aware of each other. The trait is agnostic about the kind of mutex/locking mechanism. The [`embedded-hal-bus`](https://docs.rs/embedded-hal-bus/0.1.0/embedded_hal_bus/spi/index.html) crate provides implementations for commonly used mutexes, but it is possible to write your own for e.g. the mutex of your favourite RTOS.",
            "Error handling",
            "Error handling\n--------------",
            "Generic drivers can now inspect errors, thanks to them being required to implement an `Error` trait\nthat allows querying the error \"kind\" out of a pre-selected set. HAL implementations can still use custom error types,\nand map errors that don't fit in these categories to the `Other` kind.\nAll error types are also required to implement `Debug`, so `.unwrap()` and similar are now always available in generic drivers.",
            "Jan 9, 2024 — The embedded-hal crates provide traits (interfaces) for using peripherals commonly available in microcontrollers such as GPIO, UART, SPI or I2C.",
            "2024-01-09",
            "SPI bus sharing",
            "SPI bus sharing\n--------------",
            "embedded-io"
          ]
        },
        {
          "title": "esp-rs/esp-idf-hal: embedded-hal implementation for Rust ...",
          "url": "https://github.com/esp-rs/esp-idf-hal",
          "excerpts": [
            "Implements the traits of embedded-hal V0.2 as well as those of V1.0 - both blocking and async · Supports almost all ESP IDF drivers: GPIO, SPI, I2C, TIMER, PWM, ...",
            "Implements the traits of [embedded-hal](https://github.com/rust-embedded/embedded-hal) `V0.2` as well as those of `V1.0` - both blocking and async"
          ]
        },
        {
          "title": "rp2040_hal::dma - Rust - Docs.rs",
          "url": "https://docs.rs/rp2040-hal/latest/rp2040_hal/dma/index.html",
          "excerpts": [
            "The DMA unit of the RP2040 seems very simplistic at first when compared to other MCUs. For example, the individual DMA channels do not support chaining multiple ...",
            "An example for this transfer type can be found in the datasheet. Repeated transfers from/to a set of buffers: By allocating one channel per buffer and chaining ..."
          ]
        },
        {
          "title": "stm32h7xx_hal::spi - Rust",
          "url": "https://docs.rs/stm32h7xx-hal/latest/stm32h7xx_hal/spi/index.html",
          "excerpts": [
            "This module implements the embedded-hal traits for master mode SPI. Usage In the simplest case, SPI can be initialised from the device peripheral and the GPIO ..."
          ]
        },
        {
          "title": "STM32 SPI Tutorial - HAL Code Examples - Interrupt / DMA",
          "url": "https://deepbluembedded.com/stm32-spi-tutorial/",
          "excerpts": [
            "In this tutorial, we'll be discussing the SPI hardware in STM32 microcontrollers. Starting with an introduction to the Serial Peripheral Interface (SPI) ..."
          ]
        },
        {
          "title": "embedded_hal::digital::v2::InputPin - Rust",
          "url": "https://rahix.github.io/embedded-hal/embedded_hal/digital/v2/trait.InputPin.html",
          "excerpts": [
            "Single digital input pin. This trait is available if embedded-hal is built with the \"unproven\" feature."
          ]
        },
        {
          "title": "Converting an Embedded HAL impl from digital::v1 to digital",
          "url": "https://therealprof.github.io/blog/digital-v1-to-digital-v2/",
          "excerpts": [
            "Oct 3, 2019 — In order to use digital::v2 rather than digital::v1 you either need to spell out the version explicitely all the time or you may want to change ..."
          ]
        },
        {
          "title": "What the HAL? The Quest for Finding a Suitable Embedded Rust HAL",
          "url": "https://blog.theembeddedrustacean.com/what-the-hal-the-quest-for-finding-a-suitable-embedded-rust-hal",
          "excerpts": [
            "A more comprehensive list can be found on the awesome embedded Rust repository. Embassy HALs: Current HALs provide support only for the ..."
          ]
        },
        {
          "title": "rp2040_hal - Rust - Docs.rs",
          "url": "https://docs.rs/rp2040-hal",
          "excerpts": [
            "HAL for the RP2040 microcontroller. This is an implementation of the embedded-hal traits for the RP2040 microcontroller. NOTE This HAL is still under active ..."
          ]
        },
        {
          "title": "esp-display-interface-spi-dma v0.2.0",
          "url": "https://crates.io/crates/esp-display-interface-spi-dma/dependencies",
          "excerpts": [
            "embedded-dma. Traits to aid in the creation of sound DMA abstractions ... 0 embedded-hal. A Hardware Abstraction Layer (HAL) for embedded systems. ^0.22 ..."
          ]
        },
        {
          "title": "How to write SPI DMA code inside a Rust struct ...",
          "url": "https://stackoverflow.com/questions/66163769/how-to-write-spi-dma-code-inside-a-rust-struct-implementation",
          "excerpts": [
            "SPI DMA code is quite easy if you look at the stm32f1xx-hal example, but the traits are very complex. I cannot figure out how to get the ..."
          ]
        },
        {
          "title": "embedded-hal 1.0.0",
          "url": "https://docs.rs/crate/embedded-hal/latest",
          "excerpts": [
            "embedded-hal is a Hardware Abstraction Layer (HAL) for embedded systems, designed to be minimal, generic, and a foundation for platform-agnostic drivers."
          ]
        },
        {
          "title": "embedded-hal-async - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embedded-hal-async",
          "excerpts": [
            "Jan 9, 2024 — An asynchronous Hardware Abstraction Layer (HAL) for embedded systems. This crate contains asynchronous versions of the embedded-hal traits and shares its ..."
          ]
        },
        {
          "title": "STM32H7 HAL SPI DMA Not receiving data",
          "url": "https://community.st.com/t5/stm32cubeide-mcus/stm32h7-hal-spi-dma-not-receiving-data/td-p/620286",
          "excerpts": [
            "The H7 has a data cache. Cache must be disabled or handled appropriately. The H7 DMA cannot access all memory. Ensure your stack is in a DMA ..."
          ]
        },
        {
          "title": "stm32h7xx-hal/examples/spi-dma.rs at master",
          "url": "https://github.com/stm32-rs/stm32h7xx-hal/blob/master/examples/spi-dma.rs",
          "excerpts": [
            "Example that transmits SPI data using the DMA //! //! The first part of the example transmits 10 bytes over SPI. //! //! The maximum transfer length for ..."
          ]
        },
        {
          "title": "SPI DMA example",
          "url": "https://community.st.com/t5/stm32-mcus-products/spi-dma-example/td-p/627157",
          "excerpts": [
            "hi, i m using STM32H7 and have running SPI using interrupt transmittng and receiving from external ADC, now i m contemplating using DMA for SPI ...",
            "Jan 10, 2024 — Hi anyone can advise sample code on SPI DMA using stm32cubeMX not register. Use the Example Selector in STM32CubeMX to find SPI DMA examples. They are there."
          ]
        },
        {
          "title": "How To Receive SPI Data With STM32 DMA / Interrupt ...",
          "url": "https://deepbluembedded.com/how-to-receive-spi-with-stm32-dma-interrupt/",
          "excerpts": [
            "In this tutorial, we'll discuss how to and receive SPI data with STM32 microcontrollers in DMA, Interrupt, and Polling modes."
          ]
        },
        {
          "title": "rp2040_hal::spi - Rust",
          "url": "https://docs.rs/rp2040-hal/latest/rp2040_hal/spi/index.html",
          "excerpts": [
            "Serial Peripheral Interface (SPI). Spi is the main struct exported by this module, representing a configured Spi bus. See its docs for more information on ..."
          ]
        },
        {
          "title": "rp2040_hal::uart - Rust - Docs.rs",
          "url": "https://docs.rs/rp2040-hal/latest/rp2040_hal/uart/index.html",
          "excerpts": [
            "The `rp2040_hal::uart` module is a Universal Asynchronous Receiver Transmitter (UART) module. It uses `UartPeripheral` and `UartConfig` structs."
          ]
        },
        {
          "title": "Docs.rs - embedded-hal i2c",
          "url": "https://docs.rs/embedded-hal/latest/embedded_hal/i2c/index.html",
          "excerpts": [
            "The [`embedded-hal-bus`](https://docs.rs/embedded-hal-bus) crate provides several\nimplementations for sharing I2C buses.",
            "\nSince 7-bit addressing is the mode of the majority of I2C devices,\n[`SevenBitAddress`](type.SevenBitAddress.html \"type embedded_hal::i2c::SevenBitAddress\") has been set as default mode and thus can be omitted if desired.",
            "AddressMode\") exist:\n[`SevenBitAddress`](type.SevenBitAddress.html \"type embedded_hal::i2c::SevenBitAddress\") and [`TenBitAddress`](type.TenBitAddress.html \"type embedded_hal::i2c::TenBitAddress\"). Through this marker types it is possible to implement each address mode for\nthe traits independently in `embedded-hal` implementations and device drivers\ncan depend only on the mode that they support.",
            "t. Additionally, the I2C 10-bit address mode has been developed to be fully\nbackwards compatible with the 7-bit address mode. This allows for a\nsoftware-emulated 10-bit addressing implementation if the address mode\nis not supported by the hardware.",
            "\n\nI2C allows sharing a single bus between many I2C devices. The SDA and SCL lines are\nwired in parallel to all devices. When starting a transfer an ",
            "SDA",
            "SCL",
            "I2C DEVICE 1",
            "This bus sharing is common when having multiple I2C devices in the same board, since it uses fewer MCU\npins",
            "Blocking I2C API. This API supports 7-bit and 10-bit addresses. Traits feature an [`AddressMode`](trait.AddressMode.html \"trait embedded_hal::i2c::AddressMode\")\nmarker type parameter.",
            "I2C DEVICE 2"
          ]
        },
        {
          "title": "Main SPI HAL functions",
          "url": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_SPI",
          "excerpts": [
            "Main SPI HAL functions. Based on the STM32Cube HAL functions, SPI data transfer can be performed in three modes: blocking mode, interrupt mode, or DMA mode.",
            "* **Blocking mode:**  \n\n    The communication is performed in polling mode. The status of all data processing is returned by the same function after finishing the transfer. HAL\\_SPI\\_Transmit()        HAL\\_SPI\\_Receive()        HAL\\_SPI\\_TransmitRec",
            "* **Non-blocking modes**\n\n    The communication is performed using interrupts or DMA. These functions return the status of the transfer startup. The end of the data processing is indicated through the dedicated SPI IRQ when using interrupt mode, or the DMA IRQ when using DMA mode. * **Interrupt mode:**                    HAL\\_SPI\\_Transmit\\_IT()        HAL\\_SPI\\_Receive\\_IT()        HAL\\_SPI\\_TransmitReceive\\_IT()                * **DMA mode:**                    HAL\\_SPI\\_Transmit\\_DMA()        HAL\\_SPI\\_Receive\\_DMA()        HAL\\_SPI\\_Tran"
          ]
        },
        {
          "title": "UM1725 Description of STM32F4 HAL and low-layer drivers",
          "url": "https://www.st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
          "excerpts": [
            "The HAL drivers include a complete set of ready-to-use APIs that simplify the user application implementation. For example, the communication peripherals ..."
          ]
        },
        {
          "title": "stm32-rs/stm32f4xx-hal: A Rust embedded- ...",
          "url": "https://github.com/stm32-rs/stm32f4xx-hal",
          "excerpts": [
            "stm32f4xx-hal contains a multi device hardware abstraction on top of the peripheral access API for the STMicro STM32F4 series microcontrollers."
          ]
        },
        {
          "title": "rp-rs/rp-hal: A Rust Embedded-HAL for the rp series microcontrollers",
          "url": "https://github.com/rp-rs/rp-hal",
          "excerpts": [
            "The crate provides high-level drivers for the RP2040's internal peripherals, such as the SPI Controller and the I²C Controller."
          ]
        },
        {
          "title": "Need help understanding DMA for use with SPI : r/embedded",
          "url": "https://www.reddit.com/r/embedded/comments/107ogyx/need_help_understanding_dma_for_use_with_spi/",
          "excerpts": [
            "There is a DMA example for STM32 and UART. Will save you a ton of time I bet. The examples aren't production ready, but good for starting out."
          ]
        },
        {
          "title": "embedded_time - Rust",
          "url": "https://docs.rs/embedded_time/",
          "excerpts": [
            "embedded-time provides a comprehensive library of Duration and Rate types as well as a Clock abstraction for hardware timers/clocks and the associated Instant ..."
          ]
        },
        {
          "title": "fugit - Rust",
          "url": "https://docs.rs/fugit/",
          "excerpts": [
            "fugit provides a comprehensive library of Duration and Instant for the handling of time in embedded systems. The library is specifically designed to ..."
          ]
        },
        {
          "title": "fugit - Rust Package Registry",
          "url": "https://crates.io/crates/fugit",
          "excerpts": [
            "Jun 6, 2023 — fugit provides a comprehensive library of Duration and Instant for the handling of time in embedded systems, doing all it can at compile time."
          ]
        },
        {
          "title": "embedded-time 0.12.1",
          "url": "https://docs.rs/crate/embedded-time/latest/source/src/timer.rs",
          "excerpts": [
            "Software timers coupled to a [crate::Clock] implementation use crate::fraction::Fraction; use crate::{ duration::{self, *}, fixed_point::FixedPoint, ..."
          ]
        },
        {
          "title": "Concurrency Patterns in Embedded Rust : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/hmy0st/concurrency_patterns_in_embedded_rust/",
          "excerpts": [
            "When an event (serial data or DMA, etc.) arrives it triggers an interrupt handler. This causes main (e.g. crypto ) to be suspended / preempted."
          ]
        },
        {
          "title": "Solution for dealing with clocks and time in embedded ...",
          "url": "https://github.com/rust-embedded/embedded-hal/issues/211",
          "excerpts": [
            "I would suggest that you do a real world example using fugit , my crate, maybe embedded-time etc. and do some comparision in terms of ease-of-use and ..."
          ]
        },
        {
          "title": "Embedded Concurrency Patterns - Ferrous Systems",
          "url": "https://ferrous-systems.com/blog/embedded-concurrency-patterns/",
          "excerpts": [
            "The newest concurrency model available in `no_std` code is async/await.",
            "The async/await feature enables the construction of *cooperative* tasks: tasks that yield control back to the scheduler at determined points; it is only at these points where context switching between tasks occurs.",
            "Currently, most of the existing Hardware Abstraction Layers (HAL) in the embedded crate ecosystem have only blocking APIs.",
            "How should you do concurrency in an embedded no_std application? There's no built-in support for time-sliced threads in core ...",
            "There's no built-in support for time-sliced threads in [`core`](https://doc.rust-lang.org/core/index.html); that abstraction is only available in `std` (see [`std::thread`](https://doc.rust-lang.org/std/thread/index.html)).",
            "The latest stable release brought the async/await feature to `no_std` thanks to [our compiler work](https://ferrous-systems.com/blog/stable-async-on-embedded/).",
            "RTIC maps its tasks to interrupt handlers allowing prioritization of tasks with efficient stack usage.",
            "In embedded applications threads are commonly used for multitasking with one task mapped to one thread."
          ]
        },
        {
          "title": "System timer, SysTick",
          "url": "https://developer.arm.com/documentation/dui0552/latest/cortex-m3-peripherals/system-timer--systick",
          "excerpts": [
            "The processor has a 24-bit system timer, SysTick, that counts down from the reload value to zero, reloads, that is wraps to, the value in the SYST_RVR register."
          ]
        },
        {
          "title": "System timer, SysTick - Arm Developer",
          "url": "https://developer.arm.com/documentation/dui1095/latest/Cortex-M23-Peripherals/System-timer--SysTick",
          "excerpts": [
            "SysTick timers count down from a reload value to zero, then reload. When the counter reaches zero, a flag is set. Writing zero to SYST_RVR disables the counter."
          ]
        },
        {
          "title": "SysTick Control and Status Register",
          "url": "https://developer.arm.com/documentation/dui0552/latest/cortex-m3-peripherals/system-timer--systick/systick-control-and-status-register",
          "excerpts": [
            "This book is a generic user guide for devices that implement the ARM Cortex-M3 processor. Implementers of Cortex-M3 designs make a number of implementation ..."
          ]
        },
        {
          "title": "Dynamic power management - Arm Developer",
          "url": "https://developer.arm.com/documentation/ddi0488/latest/functional-description/power-management/dynamic-power-management",
          "excerpts": [
            "When a core is in WFI low-power state or WFE low-power state, the clocks to the core are stopped. During these low-power states, the core might start the clocks ..."
          ]
        },
        {
          "title": "osEventFlagsSet() after osKernelSuspend() in RTOS2 tick ... - GitHub",
          "url": "https://github.com/ARM-software/CMSIS_5/issues/1467",
          "excerpts": [
            "The WFI has the drawback that it will only wake-up on interrupts received after the instruction. This is why most examples recommend using WFE ..."
          ]
        },
        {
          "title": "embassy_time - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-time/",
          "excerpts": [
            "Timekeeping, delays and timeouts. Timekeeping is done with elapsed time since system boot. Time is represented in ticks."
          ]
        },
        {
          "title": "rtic_monotonic - Rust",
          "url": "https://docs.rs/rtic-monotonic",
          "excerpts": [
            "Core abstractions of the Real-Time Interrupt-driven Concurrency (RTIC) Monotonic timers, used internally for scheduling and users can use them for time."
          ]
        },
        {
          "title": "embassy_time_driver - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-time-driver",
          "excerpts": [
            "The `embassy_time_driver` crate provides a driver trait for adding embassy-time support to new hardware platforms, backed by a global time driver."
          ]
        },
        {
          "title": "Ticker in embassy_time - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-time/git/default/struct.Ticker.html",
          "excerpts": [
            "Asynchronous stream that yields every Duration, indefinitely. This stream will tick at uniform intervals, even if blocking work is performed between ticks."
          ]
        },
        {
          "title": "Kernel Timing",
          "url": "https://docs.zephyrproject.org/latest/kernel/services/timing/clocks.html",
          "excerpts": [
            "Note that a natural implementation of this API results in a “tickless” kernel, which receives and processes timer interrupts only for registered events, relying ..."
          ]
        },
        {
          "title": "Working with FreeRTOS in low power tickless mode for long stop ...",
          "url": "https://forums.freertos.org/t/working-with-freertos-in-low-power-tickless-mode-for-long-stop-periods/15332",
          "excerpts": [
            "FreeRTOS Tickless mode where the system needs to wake up periodically on a relatively fast rate (this is based on the system clock mainly) to keep its internal ..."
          ]
        },
        {
          "title": "CONFIG_TICKLESS_KERNEL - Technical Documentation",
          "url": "https://docs.nordicsemi.com/bundle/ncs-1.9.2/page/kconfig/CONFIG_TICKLESS_KERNEL.html",
          "excerpts": [
            "Jul 14, 2022 — This option enables a fully event driven kernel. Periodic system clock interrupt generation would be stopped at all times."
          ]
        },
        {
          "title": "True tickless mode - Kernel",
          "url": "https://forums.freertos.org/t/true-tickless-mode/18965",
          "excerpts": [
            "The difference is that tickless idle is an optional mode, that disappers when not supported. Changing the definition of how the tick works, is ..."
          ]
        },
        {
          "title": "Tick Rate vs Performance of RTOS",
          "url": "https://www.freertos.org/FreeRTOS_Support_Forum_Archive/May_2012/freertos_Tick_Rate_vs_Performance_of_RTOS_5283865.html",
          "excerpts": [
            "A faster processor makes executes more instructions per unit time than the slower one, so a tick will us up a lower percentage of the time."
          ]
        },
        {
          "title": "ARMv7-M Architecture Reference Manual",
          "url": "https://web.eecs.umich.edu/~prabal/teaching/eecs373-f10/readings/ARMv7-M_ARM.pdf",
          "excerpts": [
            "This ARM Architecture Reference Manual may include technical inaccuracies or typographical errors. To the extent not prohibited by law, in no event will ARM be ..."
          ]
        },
        {
          "title": "SysTick documention",
          "url": "https://community.st.com/t5/stm32-mcus-products/systick-documention/td-p/339585",
          "excerpts": [
            "Architecture Reference Manual in probably the most covering document about the internals of ARM cores. In this case: ARMv7-M Architecture Reference Manual."
          ]
        },
        {
          "title": "ARM Cortex-M - Wikipedia",
          "url": "https://en.wikipedia.org/wiki/ARM_Cortex-M",
          "excerpts": [
            "SysTick timer: A 24-bit system timer that extends the functionality of both the processor and the Nested Vectored Interrupt Controller (NVIC). · Bit-Band: Maps a ..."
          ]
        },
        {
          "title": "1.4 Cortex-M3 Processor SysTick Timer - Microchip Online docs",
          "url": "https://onlinedocs.microchip.com/oxy/GUID-199548F4-607C-436B-80C7-E4F280C1CAD2-en-US-1/GUID-12BCC613-1C9C-44A4-9DE5-C96E0ECE1871.html",
          "excerpts": [
            "The SysTick timer is used to generate a periodic interrupt to the Cortex-M3 processor. The SysTick can be polled by the software or it can be configured to ..."
          ]
        },
        {
          "title": "How to implement low-power support with tickless mode in FreeRTOS",
          "url": "https://community.st.com/t5/stm32-mcus-products/how-to-implement-low-power-support-with-tickless-mode-in/td-p/719444",
          "excerpts": [
            "The solution is simple just add sleep function maybe HAL_PWR_EnterSTOPMode() in configPRE_SLEEP_PROCESSING() and the code looks like this."
          ]
        },
        {
          "title": "Exercise 2 - Kernel options - Nordic Developer Academy",
          "url": "https://academy.nordicsemi.com/courses/nrf-connect-sdk-intermediate/lessons/lesson-1-zephyr-rtos-advanced/topic/exercise-2-kernel-options/",
          "excerpts": [
            "The kernel options are sourced when Zephyr RTOS is built, which is triggered as one of the early stages of building an nRF Connect SDK application. The default ..."
          ]
        },
        {
          "title": "embassy_time_queue_driver - Rust",
          "url": "https://docs.rs/embassy-time-queue-driver",
          "excerpts": [
            "This crate contains the driver trait used by the embassy-time timer queue. You should rarely need to use this crate directly. Only use it when implementing your ..."
          ]
        },
        {
          "title": "System timer, SysTick - Arm Cortex-M85 Processor Devices Generic User Guide",
          "url": "https://developer.arm.com/documentation/101928/latest/Cortex-M85-Processor-level-components-and-system-registers---Reference-Material/System-timer--SysTick",
          "excerpts": [
            "There are two 24-bit system timers, a Non-secure SysTick timer and a Secure SysTick timer.",
            "When enabled, the timer counts down from the reload value to zero, reloads (wraps to) the value in the SYST\\_RVR on the next clock cycle",
            "Writing a value of zero to the SYST\\_RVR disables the counter on the next wrap",
            "When the counter transitions to zero, the COUNTFLAG status bit is set to 1.",
            "Reading SYST\\_CSR clears the COUNTFLAG bit to 0",
            "Writing to the SYST\\_CVR clears the register and the COUNTFLAG status bit to 0",
            "The write does not trigger the SysTick exception logic.",
            "Note\n>\n> When the processor is halted for debugging, the counter does not decreme"
          ]
        },
        {
          "title": "ARM Cortex-M System control registers (SysTick related entries)",
          "url": "https://documentation-service.arm.com/static/5f19da2a20b7cf4bc524d99a",
          "excerpts": [
            "SysTick Control and Status Register",
            "SysTick Reload Value Register",
            "SysTick Current Value Register",
            "SysTick Calibration Value Register"
          ]
        },
        {
          "title": "SysTick Control and Status Register, SYST_CSR",
          "url": "https://developer.arm.com/documentation/ddi0403/d/System-Level-Architecture/System-Address-Map/The-system-timer--SysTick/SysTick-Control-and-Status-Register--SYST-CSR",
          "excerpts": [
            "SysTick Control and Status Register, SYST\\_CSR",
            "|\n| [2] | R/W | CLKSOURCE | Indicates the SysTick clock source:  0 = SysTick uses the implementation defined external reference clock. 1 = SysTick uses the processor clock. If no external clock is provided, this bit reads as 1 and ignores writes.",
            "|\n| [1] | R/W | TICKINT | Indicates whether counting to 0 causes the status of the SysTick exception to change to pending:  0 = Count to 0 does not affect the SysTick exception status. 1 = Count to 0 changes the SysTick exception status to pending.",
            "|\n| [0] | R/W | ENABLE | Indicates the enabled status of the SysTick counter:  0 = Counter is disabled  1 = Counter is operating.",
            "The SYST\\_CSR characteristics are:",
            "Purpose",
            "Usage constraints",
            "There are no usage constraints. Configurations",
            "Always implemented. Attributes",
            "Table 10.31. SYST\\_CSR bit assignments",
            "| [16] | RO | COUNTFLAG | Indicates whether the counter has counted to 0 since the last read of this register:  0 = Timer has not counted to 0  1 = Timer has counted to 0. COUNTFLAG is set to 1 by a count transition from 1 to 0. COUNTFLAG is cleared to 0 by a read of this register, and by any write to the Current Value register."
          ]
        },
        {
          "title": "A New RTOS Approach to Achieve Sub-Millisecond Timing Resolution",
          "url": "https://www.beningo.com/a-new-rtos-approach-to-achieve-sub-millisecond-timing-resolution/",
          "excerpts": [
            "Tick-based systems cannot offer timing granularity beyond configured tick intervals (e.g., 1 millisecond).",
            " tick-based RTOSes are energy inefficient! The periodic system tick interrupts keep the CPU active even when no tasks are scheduled, leading to wasted energy",
            "Cycle-based scheduling eliminates this constraint by replacing the periodic tick interrupt with a single-shot hardware timer.",
            "This approach enhances precision and reduces the CPU’s activity, conserving energy.",
            "Cycle-based scheduling represents a technological advancement that addresses the core challenges developers and managers face in today’s embedded systems—achieving microsecond precision while maximizing energy efficiency.",
            "embOS-Ultra uses two hardware timers. One timer is used for long-term stability and runs continuously without generating interrupts. The second timer, the single-shot timer we discussed in the previous section, is used for task scheduling.",
            "_TASK\\_Delay\\_Cycles specifies the minimum time interval in cycles during which the task is suspended."
          ]
        },
        {
          "title": "RTIC Monotonic implementations for no_std timers",
          "url": "https://rtic.rs/1/book/en/by-example/tips_monotonic_impl.html",
          "excerpts": [
            "The framework is flexible because it can use any timer which has compare-match and optionally\nsupporting overflow interrupts for scheduling.",
            " The single requirement to make a timer usable with RTIC is implementing the\n[`rtic_monotonic::Monotonic`](htt",
            "Implementing time counting that supports large time spans is generally **difficult**, in RTIC 0.5\nimplementing time handling was a common problem.",
            "Moreover, the relation between time and timers used for scheduling was difficult to understand.",
            "For RTIC 1.0 we instead assume the user has a time library, e.g. [`fugit`](https://docs.rs/fugit/) or [`embedded_time`](https://docs.rs/embedded_time/),\nas the basis for all time-based operations when implementing `Monotonic`.",
            "These libraries make it much easier to correctly implement the `Monotonic` trait, allowing the use of\nalmost any timer in the system for scheduling.",
            "* [`STM32F411 series`](https://github.com/kalkyl/f411-rtic/blob/a696fce7d6d19fda2356c37642c4d53547982cca/src/mono.rs), implemented for the 32-bit timers",
            "* [`Nordic nRF52 series Timer`](https://github.com/kalkyl/nrf-play/blob/47f4410d4e39374c18ff58dc17c25159085fb526/src/mono.rs), implemented for the 32-bit timers",
            "* [`Nordic nRF52 series RTC`](https://gist.github.com/korken89/fe94a475726414dd1bce031c76adc3dd), implemented for the RTCs",
            "* [`Systick based`](https://github.com/rtic-rs/systick-monotonic), runs at a fixed interrupt (tick) rate - with some overhead but simple and with support for large time spans",
            "* [`DWT and Systick based`](https://github.com/rtic-rs/dwt-systick-monotonic), a more efficient (tickless) implementation - requires both `SysTick` and `DWT`, supports both high resolution and large time spans",
            "The single requirement to make a timer usable with RTIC is implementing the\n[`rtic_monotonic::Monotonic`](https://docs.rs/rtic-monotonic/) trait.",
            "nic/) trait. Implementing time counting that supports large time spans is generally **difficult**, in RTIC 0.5\nimplementing time handling was a common problem."
          ]
        },
        {
          "title": "rtic-monotonics - RustDocs",
          "url": "https://docs.rs/rtic-monotonics",
          "excerpts": [
            "In-tree implementations of the [`rtic_time::Monotonic`](trait.Monotonic.html \"trait rtic_monotonics::Monotonic\") (reexported) trait for\ntimers & clocks found on commonly used microcontrollers.",
            "The `systick` monotonic works on all Arm Cortex-M parts, and requires that the feature `cortex-m-systick` is enabled.",
            "The priority of timer interrupts are based on `RTIC_ASYNC_MAX_LOGICAL_PRIO` generated by RTIC."
          ]
        },
        {
          "title": "rtic-monotonic: Core abstractions of the RTIC Monotonic timers",
          "url": "https://github.com/rtic-rs/rtic-monotonic",
          "excerpts": [
            "Core abstractions of the Real-Time Interrupt-driven Concurrency (RTIC) Monotonic timers",
            "rtic-monotonic` for RTIC v",
            "This crate contains the trait and will need an actual implementation to be useful. For RTIC v2 see [rtic-time](https://github.com/rtic-rs/rtic/tree/master/rtic-time) instead"
          ]
        },
        {
          "title": "STM32 Timer Interrupt HAL Example - Timer Mode LAB – DeepBlue",
          "url": "https://deepbluembedded.com/stm32-timer-interrupt-hal-example-timer-mode-lab/",
          "excerpts": [
            "In this tutorial, we'll discuss how to configure the STM32 timer module to generate timer interrupts with a couple of example projects (Timer Mode)."
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: Timer Interrupts",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-hal-timer-interrupts-154e",
          "excerpts": [
            "This blog post is the second of a three-part series of posts where I explore interrupts for the STM32F401RE microcontroller using embedded Rust at the HAL ..."
          ]
        },
        {
          "title": "How to generate a one second interrupt using an STM32 Timer",
          "url": "https://community.st.com/t5/stm32-mcus/how-to-generate-a-one-second-interrupt-using-an-stm32-timer/ta-p/49858",
          "excerpts": [
            "In this article we will use a general STM32 timer in order to generate an interrupt every second. We could have used the Systick or the RTC (Real Time Clock), ..."
          ]
        },
        {
          "title": "Getting Started with STM32 - Timers and Timer Interrupts - DigiKey",
          "url": "https://www.digikey.com/en/maker/projects/getting-started-with-stm32-timers-and-timer-interrupts/d08e6493cefa486fb1e79c43c0b08cc6",
          "excerpts": [
            "In this guide, I'll show you how to configure a timer using STM32CubeIDE, use it to measure execution time, and set up non-blocking code."
          ]
        },
        {
          "title": "STM32L4 low power modes with different wake-up sources",
          "url": "https://medium.com/@yashodhalakshana/stm32l4-low-power-modes-with-different-wake-up-sources-260b56c48933",
          "excerpts": [
            "LPTIM (low-power timer) can be configured as a Stop2 mode wakeup source. In this tutorial, we will use LPTIM1 to periodically (every 10 seconds) ...",
            "In this tutorial, we'll show how to configure the following wakeup sources to exit from the Stop2 low-power mode.See more"
          ]
        },
        {
          "title": "Using LPTIM in Stop Mode to Wake Up STM32L072 (Mur...",
          "url": "https://community.st.com/t5/stm32-mcus-products/using-lptim-in-stop-mode-to-wake-up-stm32l072-murata-cmwx1zzabz/td-p/714476",
          "excerpts": [
            "Aug 30, 2024 — I want to configure the Low-Power Timer (LPTIM) to generate a wake-up event when the MCU is in Stop mode."
          ]
        },
        {
          "title": "nrf-hal - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/nrf-hal",
          "excerpts": [
            "Sep 7, 2023 — The IR temperature transmitter example is a complete example of simple production firmware. It uses the TWIM, Timer, RTC, and Radio peripherals, ..."
          ]
        },
        {
          "title": "System ON (sleep mode) wake on RTC",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/75024/system-on-sleep-mode-wake-on-rtc",
          "excerpts": [
            "May 11, 2021 — I'd appreciate some help on the following problem: I'm trying to put a custom hardware into a low power sleep mode from which I want to wake up ..."
          ]
        },
        {
          "title": "Rust PCF8563 Real-Time Clock Driver",
          "url": "https://crates.io/crates/pcf8563",
          "excerpts": [
            "Oct 17, 2021 — A platform agnostic Rust driver for the NXP PCF8563 real-time clock, based on the embedded-hal traits. Based on this RTC driver. This driver ..."
          ]
        },
        {
          "title": "Creating a Delay",
          "url": "https://www.avrfreaks.net/s/topic/a5C3l000000UM1eEAG/t098460",
          "excerpts": [
            "Jan 12, 2023 — \"avr-libc manual \"​​ In this mode _delay_ms() will work with a resolution of 1/10 ms, providing delays up to 6.5535 seconds (independent from CPU frequency). The ..."
          ]
        },
        {
          "title": "Sleep Modes - ESP32 - — ESP-IDF Programming Guide v5.5 ...",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/sleep_modes.html",
          "excerpts": [
            "Missing: group shot alarm vendor"
          ]
        },
        {
          "title": "nRF52805 - Nordic Semiconductor Infocenter",
          "url": "https://manuals.plus/m/dd48179c7732998c5362d800b43dedaa2a0162d9f4893729e8f830c8267ad9df",
          "excerpts": [
            "... LFCLK. 5.4.2.4 32.768 kHz crystal oscillator (LFXO) For higher LFCLK accuracy the low frequency crystal oscillator (LFXO) must be used. The following ..."
          ]
        },
        {
          "title": "CLOCK — Clock control",
          "url": "https://docs.nordicsemi.com/bundle/ps_nrf52840/page/clock.html",
          "excerpts": [
            "Oct 1, 2024 — For higher LFCLK accuracy (when better than +/- 500 ppm accuracy is required), the low frequency crystal oscillator (LFXO) must be used. The ..."
          ]
        },
        {
          "title": "XAIO 1.28\" Display RTC Wakeup xaio nrf52x sense",
          "url": "https://forum.seeedstudio.com/t/xaio-1-28-display-rtc-wakeup-xaio-nrf52x-sense/275905",
          "excerpts": [
            "Mar 26, 2024 — The RTC is a low-power timer that resets every time the system is reset. It's not intended to keep time. This is why I say the RTC on the ..."
          ]
        },
        {
          "title": "avr-libc Reference Manual",
          "url": "https://download-mirror.savannah.gnu.org/releases/avr-libc/old-releases/avr-libc-user-manual-1.4.4.pdf",
          "excerpts": [
            "Apr 20, 2006 — Example that would select a watchdog timer expiry of approximately 500 ms: ... Perform a delay of __ms milliseconds, using _delay_loop_2()."
          ]
        },
        {
          "title": "ESP Timer (High Resolution Timer) - ESP32 - Espressif Systems",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/esp_timer.html",
          "excerpts": [
            "Missing: group vendor",
            "Automatic sleep provided by Power Management APIs: If no tasks are being executed, the chip can automatically enter light sleep and automatically wake up at the ..."
          ]
        },
        {
          "title": "CLINT and sleep? - HiFive1 Rev B - SiFive Forums",
          "url": "https://forums.sifive.com/t/clint-and-sleep/2355",
          "excerpts": [
            "On https://www.sifive.com/documentation the document “SiFive E31 Core Complex Manual” might help you. Section 6.3 Timer Registers says: “mtime ..."
          ]
        },
        {
          "title": "nrf52840DK and MAX98357A and rust",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/73102/nrf52840dk-and-max98357a-and-rust",
          "excerpts": [
            "Mar 22, 2021 — Hi all, I wanted to start developing with nrf52840DK and rust and set myself to do a simple build that would play a sound when I press a ..."
          ]
        },
        {
          "title": "The NEORV32 RISC-V Processor - Datasheet",
          "url": "https://stnolting.github.io/neorv32/",
          "excerpts": [
            "The processor supports the standard RISC-V machine-level interrupts for \"machine timer interrupt\", \"machine software interrupt\" and \"machine external interrupt\" ..."
          ]
        },
        {
          "title": "ESP32 using one periodic timer to reset multiple one shot timers",
          "url": "https://forum.arduino.cc/t/esp32-using-one-periodic-timer-to-reset-multiple-one-shot-timers/1310913",
          "excerpts": [
            "I am trying to achieve this with 2 timers in one shot mode (alarm at 150μs and 1850μs) and a third timer with an alarm at 2000 μs and auto-reload."
          ]
        },
        {
          "title": "Newbie's Guide to AVR Timers",
          "url": "https://qiriro.com/bme6163/static_files/notes/L3/Newbie's%20Guide%20to%20AVR%20Timers.pdf",
          "excerpts": [
            "by D Camera · 2021 · Cited by 3 — AVR timers measure time, run independently of the main program, and can be 8 or 16 bits wide, counting until overflow."
          ]
        },
        {
          "title": "MSP430 Timer Function to Delay an LED - Stack Overflow",
          "url": "https://stackoverflow.com/questions/77603988/msp430-timer-function-to-delay-an-led",
          "excerpts": [
            "A function to turn on my LED; A function to turn off my LED; And a function to start the timer. (takes a parameter of the delay in milliseconds)."
          ]
        },
        {
          "title": "Moddable NRF52 Low Power Documentation",
          "url": "https://www.moddable.com/documentation/devices/nRF52-low-power",
          "excerpts": [
            "Tickless idle disables the periodic tick interrupt, allowing the CPU to enter low power mode until a task needs to run or interrupt occurs, at which point the RTOS tick value is adjusted.",
            "The core of the tickless idle implementation/hook is provided by our `vApplicationSleep()` function."
          ]
        },
        {
          "title": "NRF5340 RTC - Nordic Semiconductor",
          "url": "https://docs.nordicsemi.com/bundle/ps_nrf5340/page/rtc.html",
          "excerpts": [
            "The real-time counter (RTC) module provides a generic, low-power timer on the low frequency clock source (LFCLK).",
            "The RTC will run off the LFCLK.",
            "The RTC module features a 24-bit COUNTER, a 12-bit (1/X)\nprescaler, capture/compare registers, and a tick event generator.",
            "The [TICK](.EVENTS_TICK) event enables low-power tickless RTOS\nimplementation, as it optionally provides a regular interrupt source for an RTOS with no need for\nuse of the ARM® SysTick feature",
            "Using the [TICK](.EVENTS_TICK) event, rather than the SysTick, allows the\nCPU to be powered down while keeping RTOS scheduling active."
          ]
        },
        {
          "title": "CYCCNT cycle counter and related timers - Arm Developer",
          "url": "https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/CYCCNT-cycle-counter-and-related-timers?lang=en",
          "excerpts": [
            "The DWT_CTRL. CYCCNTENA bit enables the CYCCNT counter. Software can access the DWT_CYCCNT register to read the current value of CYCCNT, or to set the CYCCNT ...",
            "Missing: Rust DCB"
          ]
        },
        {
          "title": "STM32 - How to enable DWT Cycle counter - Stack Overflow",
          "url": "https://stackoverflow.com/questions/36378280/stm32-how-to-enable-dwt-cycle-counter",
          "excerpts": [
            "From what I've seen online this should suffice for enabling it: CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; DWT->CYCCNT = 0; DWT->CTRL |= 1;",
            "DWT->CYCCNT = 0;",
            "DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;",
            "Note that, as stated in ARMv7-M Architecture\nReference Manual, lock mechanism only applies to software access.",
            "DAP access is always allowed (that's why you could enable cycle counter using the debugger). Please note that both [STM32F7 documentation](http://www.st.com/content/ccc/resource/technical/document/reference_manual/group0/96/8b/0d/ec/16/22/43/71/DM00224583/files/DM00224583.pdf/jcr:content/translations/en.DM00224583.pdf) and [ARM documentation](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0489c/BABJFFGJ.html) have a typo and give 0xE0000FB0 as address of Lock Access register (see [here](https://stackoverflow.com/questions/38355831/measuring-clock-cycle-count-on-cortex-m7) ).",
            "Using provided CMSIS core registres definitions (core\\_cm7.h) would have avoided you this problem since they are correct, and of course would have been more efficient as Olaf stated ;"
          ]
        },
        {
          "title": "[PDF] General-purpose timer cookbook for STM32 microcontrollers",
          "url": "https://www.st.com/resource/en/application_note/an4776-generalpurpose-timer-cookbook-for-stm32-microcontrollers-stmicroelectronics.pdf",
          "excerpts": [
            "This document describes the basic features and operating modes of STM32 general-purpose timer peripherals, which are used for motor-control and ..."
          ]
        },
        {
          "title": "Getting started with TIM - stm32mcu - ST wiki",
          "url": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_TIM",
          "excerpts": [
            "In this example, the internal clock source is used. This information can be found in the product reference manual or datasheet. The internal clock frequency is ..."
          ]
        },
        {
          "title": "Using the nRF51822's Application Timer - bitknitting",
          "url": "https://bitknitting.wordpress.com/2015/08/24/using-the-nrf51822s-application-timer/",
          "excerpts": [
            "Aug 24, 2015 — this Nordic DevZone post notes: you can use RTC in system on low power mode. In this mode it'll consume around 3uA = ION + IRTC + IX32k. Another ..."
          ]
        },
        {
          "title": "How to configure the RTC to wake up the STM32 peri...",
          "url": "https://community.st.com/t5/stm32-mcus/how-to-configure-the-rtc-to-wake-up-the-stm32-periodically-from/ta-p/49836",
          "excerpts": [
            "Nov 16, 2021 — In this article we will see how to configure the RTC peripheral of the STM32 to wake up the STM32 periodically from a low power mode like STOP2 mode."
          ]
        },
        {
          "title": "SAM D21 Real-Time Counter (RTC) Overview - Developer Help",
          "url": "https://developerhelp.microchip.com/xwiki/bin/view/products/mcu-mpu/32bit-mcu/sam/samd21-mcu-overview/peripherals/rtc-overview/",
          "excerpts": [
            "The SAM D21 Real-Time Counter (RTC) is a 32-bit counter with a 10-bit programmable prescaler that typically runs continuously (including low-power sleep modes) ..."
          ]
        },
        {
          "title": "TIMER — Timer/counter",
          "url": "https://docs.nordicsemi.com/bundle/ps_nrf52820/page/timer.html",
          "excerpts": [
            "Mar 19, 2024 — TIMER implements one COMPARE event for every available capture/compare register. A COMPARE event is generated when the Counter is incremented ..."
          ]
        },
        {
          "title": "nrf51-TIMER-examples/timer_example_timer_mode/main.c ...",
          "url": "https://github.com/NordicPlayground/nrf51-TIMER-examples/blob/master/timer_example_timer_mode/main.c",
          "excerpts": [
            "The TIMER interrupt handler will toggle a LED whenever * the TIMER counter is equal to a value of compare register CC[0] or compare register CC[[1]. The timer ..."
          ]
        },
        {
          "title": "nRF52 TIMER peripheral and nrfx_timer driver",
          "url": "https://embeddedexplorer.com/nrf52-timer-tutorial-part-1/",
          "excerpts": [
            "Apr 23, 2025 — For example, if you pass in NRF_TIMER_SHORT_COMPARE0_STOP_MASK , when COMPARE[0] event is generated, the timer is also stopped. enable_int : to ..."
          ]
        },
        {
          "title": "Getting lower power consumption on Seeed XIAO nRF52840",
          "url": "https://forum.seeedstudio.com/t/getting-lower-power-consumption-on-seeed-xiao-nrf52840/270129",
          "excerpts": [
            "May 5, 2023 — __WFI will work as expected if you turn off RTC1. FreeRTOS will automatically put the system in system_on sleep mode and manage RTC1 if all the ..."
          ]
        },
        {
          "title": "STM32G0 getting most out of the STOP mode",
          "url": "https://www.eevblog.com/forum/microcontrollers/stm32g0-getting-most-out-of-the-stop-mode/",
          "excerpts": [
            "Feb 10, 2024 — \"Some peripherals with wakeup capability can enable the HSI16 RC during Stop mode, so as to get clock for processing the wakeup event.See more"
          ]
        },
        {
          "title": "ISSDK: drivers/systick/systick_utils.c File Reference",
          "url": "https://mcuxpresso.nxp.com/api_doc/comp/101/systick__utils_8c.html",
          "excerpts": [
            "ARM-core specific function that enables the ARM systick timer on Kinetis uCs. ... References SYST_CSR, and SYST_RVR. Referenced by main(). Here is the caller ..."
          ]
        },
        {
          "title": "Operating in power save modes - Technical Documentation",
          "url": "https://docs.nordicsemi.com/bundle/ncs-2.6.3/page/nrf/protocols/wifi/station_mode/powersave.html",
          "excerpts": [
            "Feb 12, 2025 — TWT is a feature in Wi-Fi 6 that allows the device to be configured to the Deep sleep Power Save mode. It allows devices to wake up at the ..."
          ]
        },
        {
          "title": "SAMD21 RTC millisecond timing - MKR Zero - Arduino Forum",
          "url": "https://forum.arduino.cc/t/samd21-rtc-millisecond-timing/655161",
          "excerpts": [
            "Here's a basic TC timer example that chains TC4 and TC5 to act as a 32-bit timer counter. The TC4 timer is clocked by the 48MHz Digital ..."
          ]
        },
        {
          "title": "periodically wake up in light sleep mode - ESP32 Forum",
          "url": "https://esp32.com/viewtopic.php?t=22595",
          "excerpts": [
            "Missing: esp_timer shot"
          ]
        },
        {
          "title": "SAMD21 Mini/Dev Breakout Hookup Guide - SparkFun Learn",
          "url": "https://learn.sparkfun.com/tutorials/samd21-minidev-breakout-hookup-guide/example-real-time-clock",
          "excerpts": [
            "Example: Real-Time Clock Both of the SAMD21 boards have a 32.768kHz crystal connected to their external clock source, and the chips themselves have built-in ..."
          ]
        },
        {
          "title": "High Resolution Timer (ESP Timer) - ESP32-S3 - Espressif Systems",
          "url": "https://docs.espressif.com/projects/esp-idf/en/v5.1/esp32s3/api-reference/system/esp_timer.html",
          "excerpts": [
            "During light sleep, the esp_timer counter stops and no callback functions are called. Instead, the time is counted by the RTC counter. Upon waking up, the ..."
          ]
        },
        {
          "title": "Timers: PWM Introduction Lab — MSP430 Academy",
          "url": "https://dev.ti.com/tirex/explore/node?node=A__ANpfw9x.RYigcDJbEboXAg__MSP430-ACADEMY__8HaEUeq__LATEST",
          "excerpts": [
            "This lab demonstrates generating PWM(pulse-width-modulated) signals using the MSP-EXP430FR2433 and its integrated Timer_A module in different modes."
          ]
        },
        {
          "title": "ATtiny85 Timer/Counter1 Compare Match Interrupts (Timer1/Timer0)",
          "url": "https://forum.arduino.cc/t/attiny85-timer-counter1-compare-match-interrupts-timer1-timer0/159603",
          "excerpts": [
            "By default, for the ATtiny85 family, timer 1 is used for millis. There is a compile-time switch available to move millis to timer 0."
          ]
        },
        {
          "title": "Setting System On Sleep Mode and Wake Up on RTC Event",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/84445/setting-system-on-sleep-mode-and-wake-up-on-rtc-event",
          "excerpts": [
            "mple, I intend to use the RTC to wake the device up (a NRF52840) periodically every minute. I setup the RTC with LFCLK (32KHz) to trigger a compare event as the wakeup source, and attempted to shutdown other peripherals so as to reach minimum supply. According to the data sheet should be :  System ON sleep mode, full 256 kB RAM retention, wake on RTC (running from LFRC clock) => current supply I(ON\\_RAMON\\_RTC) = 3 uA",
            "uA\n\nNevertheless, I failed to put the CPU in System ON sleep(idle-mode) , I tried the following :\n\n        pm\\_device\\_state\\_set(cons, PM\\_DEVICE\\_STATE\\_SUSPENDED);  to set USB off (which I am using as console)",
            "n. I read Case ID: 222562 but it is not clear to me… which is the proper sequence ?"
          ]
        },
        {
          "title": "Nordic Nordic Semiconductor Community / Devzone discussion on low power deep sleep and clocking",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/81569/questions-about-low-power-deep-sleep",
          "excerpts": [
            "the only peripheral that uses HFCLK will be CPU calling WFE/WFI will make the CPU go to low power and release the HFCLK and if no other peripherals use the HFCLK at that time, then the HFCLK is stopped automatically.",
            "RTC or external pin interrupt will wake up from deep sleep.",
            "I need to call nrfx\\_clock\\_hfclk\\_start() to start HFXO and wait for HFXO debounce time for HFXO to stabili",
            "In your use case, having only RTC enabled and calling \\_\\_WFI/\\_\\_WFE with other peripheral that use HFCLK disabled will disable the HFCLK in idle sleep (WFE/",
            " the standby current can be anywhere between 80-900uA depending on the vendor of the XO you are using.",
            "our chip is smart enough to keep the HFXO on for quick wakeup",
            "Libertas said:",
            "4. I need to call nrfx\\_clock\\_hfclk\\_start() to start HFXO and wait for HFXO debounce time for HFXO to stabili"
          ]
        },
        {
          "title": "Nordic Nordic DevZone: nRF52 LFCLK ~40 uA consumption with SRC=Xtal",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/38348/nrf52-lfclk-40-ua-consumption-with-src-xtal",
          "excerpts": [
            "RTC0 is only configured to generate OVRFLW and COMPARE0 interrupts, and COMPARE0 is used to wake up the CPU every 1 second, and then the CPU goes back to sleep with WFI."
          ]
        },
        {
          "title": "How to test code when #![no_std] is set",
          "url": "https://users.rust-lang.org/t/how-to-test-code-when-no-std-is-set/93180",
          "excerpts": [
            "Apr 27, 2023 — This post explores unit and integration testing in no_std executables. We will use Rust's support for custom test frameworks to execute test functions."
          ]
        },
        {
          "title": "Unit Testing - Writing an OS in Rust",
          "url": "https://os.phil-opp.com/unit-testing/",
          "excerpts": [
            "This post explores unit testing in no_std executables using Rust's built-in test framework. We will adjust our code so that cargo test works."
          ]
        },
        {
          "title": "Features - The Cargo Book - Rust Documentation",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo sets features in the package using the rustc --cfg flag, and code can test for their presence with the cfg attribute or the cfg macro. Features can list ...",
            "For example, if you want to optionally support no_std environments, do not use a no_std feature. Instead, use a std feature that enables std . For example: #!["
          ]
        },
        {
          "title": "PSA for `std` Feature in `no_std` Libraries : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1hs6spy/psa_for_std_feature_in_no_std_libraries/",
          "excerpts": [
            "If you declare your crate as unconditionally no_std, with a feature flag to include the std crate, you'll always have the core::prelude, making your code much ...",
            "Instead, if you declare your crate as unconditionally `no_std`, with a feature flag to include the `std` crate, you'll *always* have the `core::prelude`, making your code much more consistent between the two features.",
            "Tl;dr: don't use `#! [cfg_attr(not(feature = \"std\"), no_std)]` to have an `std` feature, always use:",
            "One line at the top of the crate, and (while wordy) it makes sense. *If I don't have the* `std` *feature, then I'm* `no_std`. However, this has a side-effect that can make working with the `alloc` crate a massive pain: enabling or disabling the `std` feature changes the [implicit prelude](https://doc.rust-lang.org/reference/names/preludes.html) between `std::prelude` and `core::prelude`.",
            " PSA for `std` Feature in `no\\_std` Libraries : r/rust",
            "#!\n[no_std",
            "#!\n[no_std",
            "#[cfg(feature = \"std\")]",
            "#[cfg(feature = \"std\")]",
            "extern crate std;",
            "extern crate std;",
            "Read more",
            "```",
            "```"
          ]
        },
        {
          "title": "RTIC and no_std guidance with lock-free patterns",
          "url": "https://rtic.rs/1/book/en/by-example/tips_static_lifetimes.html",
          "excerpts": [
            "#!\n[no_std"
          ]
        },
        {
          "title": "Is there a way to use USART with DMA and Interrupt - embedded - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/is-there-a-way-to-use-usart-with-dma-and-interrupt/61215",
          "excerpts": [
            "#!\n[no_std"
          ]
        },
        {
          "title": "Cfg item for detecting no_std builds - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/cfg-item-for-detecting-no-std-builds/14783",
          "excerpts": [
            "A std feature goes a long way to communicating that a crate supports conditional no_std. This could be just replaced with the advertising of implicit no_std ..."
          ]
        },
        {
          "title": "Is there any point in avoiding std when testing a no_std library?",
          "url": "https://users.rust-lang.org/t/is-there-any-point-in-avoiding-std-when-testing-a-no-std-library/122731",
          "excerpts": [
            "If your library is no_std because it's pure functionality with no OS interaction, then it should run the same whether std is there or not, and therefore ..."
          ]
        },
        {
          "title": "Documentation/Platforms/ARM",
          "url": "https://wiki.qemu.org/Documentation/Platforms/ARM",
          "excerpts": [
            "Mar 22, 2021 — QEMU has generally good support for ARM guests. It has support for nearly fifty different machines. The reason we support so many is that ARM hardware is much ..."
          ]
        },
        {
          "title": "japaric-archived/lm3s6965evb: An example of running a ` ...",
          "url": "https://github.com/japaric-archived/lm3s6965evb",
          "excerpts": [
            "This Cargo project demonstrates how to debug a Rust program running on qemu-system-arm . Try it yourself. Build the example program. $ # from ..."
          ]
        },
        {
          "title": "FreeRTOS MPS2 QEMU Demo (Arm Cortex-M3) For both ...",
          "url": "https://key.freertos.org/freertos-on-qemu-mps2-an385-model.html",
          "excerpts": [
            "[RTOS Ports]. This page documents a FreeRTOS kernel demo that targets the Arm Cortex-M3 mps2-an385 QEMU external_link model. Preconfigured build projects ..."
          ]
        },
        {
          "title": "Stellaris boards (lm3s6965evb, lm3s811evb)",
          "url": "https://www.qemu.org/docs/master/system/arm/stellaris.html",
          "excerpts": [
            "The Luminary Micro Stellaris LM3S6965EVB emulation includes the following devices: Cortex-M3 CPU core. 256k Flash and 64k SRAM. Timers, UARTs, ADC, I2 ..."
          ]
        },
        {
          "title": "How to cleanly exit QEMU after executing bare metal ...",
          "url": "https://stackoverflow.com/questions/31990487/how-to-cleanly-exit-qemu-after-executing-bare-metal-program-without-user-interve",
          "excerpts": [
            "Don't forget to run QEMU with -semihosting argument, like this: qemu-system-arm -nographic -semihosting -kernel your_binary. Here is the code ..."
          ]
        },
        {
          "title": "How do I write a bare-metal RISC-V program to go from ...",
          "url": "https://stackoverflow.com/questions/74901787/how-do-i-write-a-bare-metal-risc-v-program-to-go-from-boot-to-writing-to-the-uar",
          "excerpts": [
            "I would like to write a program which writes \"Hello World\" to the UART0 device, and then halts (either with a busy loop, or somehow by powering off the board)."
          ]
        },
        {
          "title": "Failed to run Ubuntu/Debian on QEMU RISC-V #29",
          "url": "https://github.com/riscvarchive/risc-v-getting-started-guide/issues/29",
          "excerpts": [
            "I followed the instructions in RISC-V getting started guide with #26 and #28 to run Ubuntu/Debian on QEMU RISC-V. But failed to do that."
          ]
        },
        {
          "title": "How to Emulate Playdate (Arm) with QEMU",
          "url": "https://devforum.play.date/t/how-to-emulate-playdate-arm-with-qemu/11538",
          "excerpts": [
            "May 26, 2023 — QEMU has support for the Cortex-M3 (specifically the board mps2-an385 ); while the Playdate uses the Cortex-M7, these are similar enough -- they ..."
          ]
        },
        {
          "title": "Bare metal RISC-V assembly hello world",
          "url": "https://github.com/noteed/riscv-hello-asm",
          "excerpts": [
            "This is a bare metal 64-bit RISC-V assembly program outputing Hello. It is compiled with the riscv-gnu-toolchain and can be run with the QEMU sifive_u and ..."
          ]
        },
        {
          "title": "How to load my RISC-V executable code to a particular ...",
          "url": "https://www.reddit.com/r/RISCV/comments/1dgd4mq/how_to_load_my_riscv_executable_code_to_a/",
          "excerpts": [
            "I realized that the boot process of qemu is different than x86 systems, and Qemu directly starts executing the code from location 0x80000000.See more"
          ]
        },
        {
          "title": "Road to testing applications on RISC-V with QEMU and ...",
          "url": "https://www.youtube.com/watch?v=6qsLVq3XyGk",
          "excerpts": [
            "At the moment it might be challenging to get real RISC-V hardware, however there is an alternative by using emulators such as QEMU. This ..."
          ]
        },
        {
          "title": "Hello, RISC-V and QEMU",
          "url": "https://mth.st/blog/riscv-qemu/",
          "excerpts": [
            "Oct 28, 2020 — I've been trying to run and debug RISC-V binaries using QEMU. This post covers things I'm unsure of and a topic I don't know much about.See more"
          ]
        },
        {
          "title": "The RISC-V QEMU port is upstream",
          "url": "https://www.sifive.com/blog/risc-v-qemu-part-2-the-risc-v-qemu-port-is-upstream",
          "excerpts": [
            "QEMU 2.12.0 was released on April 24th 2018 and this version is the first official QEMU version to contain the RISC-V port.",
            "Apr 25, 2018 — The virt machine models a Generic RISC-V Virtual machine with support for the VirtIO standard networking and block storage devices. ... example ..."
          ]
        },
        {
          "title": "Is it possible to enable a rust feature only in test? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/68618789/is-it-possible-to-enable-a-rust-feature-only-in-test",
          "excerpts": [
            "This is a [requested feature](https://github.com/rust-lang/cargo/issues/2911) of Cargo and is only possible using the [version 2 resolver](https://doc.rust-lang.org/nightly/cargo/reference/features.html). If crate A has the function you mentioned, then crate B's `Cargo.toml` may contain",
            "[package]",
            "name = \"B\"",
            "resolver = \"2\"",
            "[features]",
            "test-utils = []",
            "[dependencies]",
            "A = \"*\"",
            "[dev-dependencies]",
            "A = { version = \"*\", features = [\"test-utils\"] }",
            "B = { path = \". \", features = [\"test-utils\"] }",
            "This would ensure that both crates are built with the `test-utils` feature *only* when testing them.",
            "```"
          ]
        },
        {
          "title": "Rustno-std testing discussion on The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/can-a-no-std-crate-have-std-dependencies-in-test-cases-only/72982",
          "excerpts": [
            "Integration tests (i.e. tests in the `tests/` directory) are compiled separately from your library and depend on `std` by default. No changes in Cargo.toml are needed.",
            "I am working on a UTF8 / UTF32 conversion crate with no\\_std support. Is it possible for the library itself be no\\_std, but the test cases be std? How would it look like in Cargo.toml file? 1 Li",
            "In practice gating `no_std` causes unpleasant issues related to prelude, especially if your crate has an `std` or `alloc` feature. Previously I was proponent of gating `no_std` , but after hitting several such issues I see the merit of using `extern crate std` . It's easier to think about crate code when `std` and `alloc` are explicit dependencies.",
            "]`\n\nYou should not use this approach. The `extern crate std;` approach is a preferred one.",
            "The `extern crate std;` approach is a preferred one",
            "Nevermind, use\n\n```rust\n#[cfg(test)]\nextern crate std;\n```\n\n1 Like"
          ]
        },
        {
          "title": "How to write a crate so that std and no_std can coexist in different modules?",
          "url": "https://stackoverflow.com/questions/69378710/how-to-write-a-crate-so-that-std-and-no-std-can-coexist-in-different-modules",
          "excerpts": [
            "nstead, use a std feature that enables std* ([Reference](https://doc.rust-lang.org/cargo/reference/features.html)).",
            "[features]\ndefault = [\"std\"]\nstd = []",
            "std = []"
          ]
        },
        {
          "title": "The Embedded Rust Book - QEMU and no_std guidance",
          "url": "https://docs.rust-embedded.org/book/start/qemu.html",
          "excerpts": [
            "sole\nqemu-system-arm \\\n  -cpu cortex-m3 \\\n  -machine lm3s6965evb \\\n  -nographic \\\n  -semihosting-config enable=on,target=native \\\n  -kernel target/thumbv7m-none-eabi/debug/examples/hello",
            "This is the QEMU emulator. There are a few variants of these QEMU binaries; this one does full system emulation of ARM machines hence the name. -cpu cortex ...",
            "```"
          ]
        },
        {
          "title": "meyerzinn.tech post on running Rust code on RISC-V in QEMU",
          "url": "https://meyerzinn.tech/posts/2023/03/05/running-rust-code-on-risc-v-in-qemu/",
          "excerpts": [
            "#![no_std] is a crate-level attribute which changes the way the crate is compiled. In general, you will see # used to denote ... Let’s go ahead and create that file:\n\n```\n# .cargo/config.toml\n\n[build]\ntarget = \"riscv32imac-unknown-none-elf\"\n\n```\n\nWe’re telling the Rust compiler to target rv32imac, as advertised. The value of `target` is commonly referred to as the ******[triple](https://doc.rust-lang.org/nightly/rustc/platform-support.html)******, though the astute reader may notice that the triple does not always contain three values. Our triple mentions ELF: that will be important later. So now we should be good to go! Right? ```\n$ cargo r",
            "We’re telling the Rust compiler to target rv32imac, as advertised.",
            "We’ll also have to remove `println!` (for now) because it is defined by the standard library.",
            "We need a panic handler! This is the function that gets called when the program invokes the `panic!` macro. The standard library typically provides one, but since we’ve opted out of the standard library, we will need to provide our own. ```",
            "Add a `runner` to your `.cargo/config.toml` file:",
            "```\n# .cargo/config.toml\n\n# ... from before\n\n[target.riscv32imac-unknown-none-elf]\nrunner = \"\"\" qemu-system-riscv32\n  -cpu rv32\n  -machine virt\n  -m 150M\n  -s\n  -nographic\n  -bios \"\"\"\n\n```\n\nWe’ll add more flags as our kernel becomes more complete, but we’ll start with the basics:"
          ]
        },
        {
          "title": "probe-rs and cargo-embed - Comprehensive Rust - Google",
          "url": "https://google.github.io/comprehensive-rust/bare-metal/microcontrollers/probe-rs.html",
          "excerpts": [
            "cargo-embed is a cargo subcommand to build and flash binaries, log RTT (Real Time Transfers) output and connect GDB. It's configured by an Embed.toml file in ..."
          ]
        },
        {
          "title": "Cannot Debug or Attach to STM32F4 Using Probe-RS",
          "url": "https://users.rust-lang.org/t/cannot-debug-or-attach-to-stm32f4-using-probe-rs/129729",
          "excerpts": [
            "May 19, 2025 — I am able to flash and erase and program the chip using cargo embed, but attempting to step through the instructions using probe-rs does not work."
          ]
        },
        {
          "title": "Rust Tools and Resources for Embedded - EEVblog",
          "url": "https://www.eevblog.com/forum/microcontrollers/rust-tools-and-resources-for-embedded/",
          "excerpts": [
            "cargo-flash: downloads the code to the MCU, starts it, and returns cargo-embed: downloads the code to the MCU, starts it, open RTT terminal ..."
          ]
        },
        {
          "title": "default.toml - probe-rs/cargo-embed - GitHub",
          "url": "https://github.com/probe-rs/cargo-embed/blob/master/src/config/default.toml",
          "excerpts": [
            "Jan 14, 2023 — The target handles RTT outputs that won't fit in the buffer. This can be overridden per-channel. If left unset, the firmware will determine the default for ..."
          ]
        },
        {
          "title": "defmt-decoder - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/defmt-decoder",
          "excerpts": [
            "This library is for decoding defmt frames into formatted strings. It is used by defmt-print and other tools. MSRV. The minimum supported Rust ..."
          ]
        },
        {
          "title": "Running hardware-in-the-loop tests on GitHub Actions",
          "url": "https://ferrous-systems.com/blog/gha-hil-tests/",
          "excerpts": [
            "This is the third post in our \"embedded Rust testing\" series. This post covers how to run a hardware testsuite based on defmt-test on real ..."
          ]
        },
        {
          "title": "Using GDB and defmt to debug embedded programs",
          "url": "https://ferrous-systems.com/blog/gdb-and-defmt/",
          "excerpts": [
            "May 4, 2021 — This post covers the process of setting up debugging for our app-template using an external GDB server program without losing the defmt logs."
          ]
        },
        {
          "title": "Debugger",
          "url": "https://probe.rs/docs/tools/debugger/",
          "excerpts": [
            "The probe-rs VS Code extension uses the Microsoft Debug Adapter Protocol to implement an interactive debugging experience between VS Code and a probe-rs target."
          ]
        },
        {
          "title": "Testing a no_std crate with QEMU and defmt-test? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/14bb0db/testing_a_no_std_crate_with_qemu_and_defmttest/",
          "excerpts": [
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ...",
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ..."
          ]
        },
        {
          "title": "Problems with debugging VA416xx · Issue #2606 · probe-rs ... - GitHub",
          "url": "https://github.com/probe-rs/probe-rs/issues/2606",
          "excerpts": [
            "Missing: simulate no_std QEMU"
          ]
        },
        {
          "title": "Releases · probe-rs/probe-rs",
          "url": "https://github.com/probe-rs/probe-rs/releases",
          "excerpts": [
            "Fixed nRF91xx memory map: set correct RAM size, added UICR memory region. Fixed an issue where RTT channel modes weren't configured properly (#3364) by @ ..."
          ]
        },
        {
          "title": "Set up hardware-in-loop testing #809 - esp-rs/esp-hal - GitHub",
          "url": "https://github.com/esp-rs/esp-hal/issues/809",
          "excerpts": [
            "I have managed to flash and run tests on-device using teleprobe / probe-rs and defmt , so we're unblocked and back on track here.",
            "Sep 21, 2023 — I have managed to flash and run tests on-device using teleprobe / probe-rs and defmt , so we're unblocked and back on track here."
          ]
        },
        {
          "title": "Debugging with `probe-rs` and VS code: and nRF52840",
          "url": "https://users.rust-lang.org/t/debugging-with-probe-rs-and-vs-code-and-nrf52840-cant-set-breakpoints/108566",
          "excerpts": [
            "Mar 19, 2024 — I'm trying to debug a program on a NordicSemi nRF52840 controller. So far I followed the instructions at hackmd.io and from the probe-rs debugging docu."
          ]
        },
        {
          "title": "Cutting Through the Confusion with ARM Cortex-M Interrupt Priorities",
          "url": "https://www.embeddedrelated.com/showarticle/923.php",
          "excerpts": [
            "For example, calling NVIC_SetPriority(7, 6) will set the priority configuration register corresponding to IRQ#7 to 1100,0000 binary on ARM ..."
          ]
        },
        {
          "title": "probe-rs",
          "url": "https://probe.rs/",
          "excerpts": [
            "Run a program on your microchip with the ease of a native application. Easily print to STDOUT via RTT and defmt encoding when using probe-rs run.",
            "Easy debugging in VSCode"
          ]
        },
        {
          "title": "embedded_hal_mock Serial Transactions",
          "url": "https://docs.rs/embedded-hal-mock/latest/i686-unknown-linux-gnu/embedded_hal_mock/eh0/serial/struct.Transaction.html",
          "excerpts": [
            "```\nuse embedded_hal_mock::eh0::serial::{Mock, Transaction};\n\n// We expect, in order,\n// 1. A read that returns 0x23,\n// 2. A write of [0x55, 0xAA]\n// 3.\nA flush\nlet transactions = [\n    Transaction::read(0x23),\n    Transaction::write_many([0x55, 0xAA]),\n    Transaction::flush(),\n];\n\nlet mut serial = Mock::new(&transactions);\n```"
          ]
        },
        {
          "title": "barretts.club Embedded Tests",
          "url": "https://barretts.club/posts/embedded-tests/",
          "excerpts": [
            "In Rust, using `embedded-hal`, we've connected to this machine and written a generic driver for it. Here's how it might look:",
            "\n\n`embedded-hal-mock` does precisely that!",
            "The goal of the crate is to be able to test drivers in CI without having access to hardware."
          ]
        },
        {
          "title": "run - probe-rs",
          "url": "https://probe.rs/docs/tools/probe-rs/",
          "excerpts": [
            "The probe-rs CLI utility features many subcommands which are explained in the sections in this document. The most commonly used one is the probe-rs run ..."
          ]
        },
        {
          "title": "cargo-embed",
          "url": "https://probe.rs/docs/tools/cargo-embed/",
          "excerpts": [
            "cargo-embed is a tool that can flash a target, open an RTT terminal, and a GDB server. It builds binaries, detects probes, and uploads content.",
            "cargo-embed is the big brother of cargo-flash. It can also flash a target just like cargo-flash, but it can also open an RTT terminal as well as a GDB server."
          ]
        },
        {
          "title": "probe_rs - Rust",
          "url": "https://docs.rs/probe-rs",
          "excerpts": [
            "Debugging toolset for embedded devices. Prerequisites, Examples, Halting the attached chip. use probe_rs::probe::{list::Lister, Probe};"
          ]
        },
        {
          "title": "probe-rs - The Rust on ESP Book",
          "url": "https://docs.esp-rs.org/book/tooling/debugging/probe-rs.html",
          "excerpts": [
            "The probe-rs project is a set of tools to interact with embedded MCU's using various debug probes. It is similar to OpenOCD, pyOCD, Segger tools, etc."
          ]
        },
        {
          "title": "probe-rs-cli - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/probe-rs-cli",
          "excerpts": [
            "Install. cargo install probe-rs-cli. Running the above command will globally install the probe-rs-cli binary. Documentation. docs.rs/probe-rs ..."
          ]
        },
        {
          "title": "RTOS Demo for RISC-V QEMU sifive e Model",
          "url": "https://freertos.org/RTOS-RISC-V-FreedomStudio-QMEU.html",
          "excerpts": [
            "This page documents a pre-configured SiFive Freedom Studio project that builds and runs a FreeRTOS RISC-V demo in the sifive_e QEMU model using GCC and GDB."
          ]
        },
        {
          "title": "Emulation — QEMU documentation",
          "url": "https://www.qemu.org/docs/master/about/emulation.html",
          "excerpts": [
            "QEMU's implementation allows for semihosting calls to be passed to the host system or via the gdbstub . Generally semihosting makes it easier to bring up low ..."
          ]
        },
        {
          "title": "Qemu baremetal emulation - how to view UART output?",
          "url": "https://stackoverflow.com/questions/60552355/qemu-baremetal-emulation-how-to-view-uart-output",
          "excerpts": [
            "I want to be able to capture the output of messages sent to UART. If this is done by redirecting to stdout, that's fine. If it goes through a TCP socket, that' ..."
          ]
        },
        {
          "title": "QEMU Semihosting not working when building QEMU from Source",
          "url": "https://stackoverflow.com/questions/75326323/qemu-semihosting-not-working-when-building-qemu-from-source",
          "excerpts": [
            "I'm emulating a Cortex-M33 using QEMU on a linux host. I've installed QEMU using sudo apt-get qemu-system-arm and semihosting is working fine (printf and file ..."
          ]
        },
        {
          "title": "How to start qemu directly in the console (*not* in curses or ...",
          "url": "https://serverfault.com/questions/471719/how-to-start-qemu-directly-in-the-console-not-in-curses-or-sdl",
          "excerpts": [
            "Jan 23, 2013 — Short anwser : qemu -nographic -serial mon:stdio -append 'console=ttyS0' binary.img ttyS0 valid on most PC. it would be something different on ARM system."
          ]
        },
        {
          "title": "QEMU User Documentation",
          "url": "https://www.qemu.org/docs/master/system/qemu-manpage.html",
          "excerpts": [
            "See the -semihosting-config option documentation for further information about the facilities this enables. -semihosting-config [enable=on ..."
          ]
        },
        {
          "title": "Qemu Machine and CPU list - SushiHangover",
          "url": "http://sushihangover.github.io/qemu-machine-and-cpu-list/",
          "excerpts": [
            "Apr 5, 2014 — Use -machine help to list supported machines! So now, you will need to include any machine (–machine help) in order to see the cpu listing."
          ]
        },
        {
          "title": "mockall - Rust",
          "url": "https://docs.rs/mockall",
          "excerpts": [
            "A powerful mock object library for Rust. Mockall provides tools to create mock versions of almost any trait or struct. They can be used in unit tests as a ..."
          ]
        },
        {
          "title": "project structure / dev. dependency · Issue #60",
          "url": "https://github.com/asomers/mockall/issues/60",
          "excerpts": [
            "Just use Mockall in unit tests. BTW, #[no_std] support would be awesome. You aren't the first person to ask for it, either. I don't think it ..."
          ]
        },
        {
          "title": "How to test this async logic?",
          "url": "https://users.rust-lang.org/t/how-to-test-this-async-logic/103272",
          "excerpts": [
            "Nov 30, 2023 — I wrote a small library for async detection of button events in a no_std environment: async-button. It's build around embedded-hal traits and embassy-time."
          ]
        },
        {
          "title": "Mocking Crates Experience : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1022gi9/mocking_crates_experience/",
          "excerpts": [
            "Missing: no_std double"
          ]
        },
        {
          "title": "Rust, Embassy, and embedded-hal-async Are Such a ...",
          "url": "https://www.reddit.com/r/embedded/comments/1h9hvq4/rust_embassy_and_embeddedhalasync_are_such_a/",
          "excerpts": [
            "I think such quick and dirty tests occur quite often in embedded dev process with new untested board, for example, and I feel for such cases a ..."
          ]
        },
        {
          "title": "Is it possible to mock this crate for unit testing? - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/is-it-possible-to-mock-this-crate-for-unit-testing/107341",
          "excerpts": [
            "Unfortunately there's no inbuilt way to do this; you need to at least specify the shape that you care about to whatever macros you're using."
          ]
        },
        {
          "title": "Testing — list of Rust libraries/crates // Lib.rs",
          "url": "https://lib.rs/development-tools/testing",
          "excerpts": [
            "Rust fixture based test framework. It use procedural macro to implement fixtures and table based tests."
          ]
        },
        {
          "title": "probe-rs Basics and Ecosystem Documentation",
          "url": "https://probe.rs/docs/library/basics/",
          "excerpts": [
            "The Probe struct represents the physical probe in code form. To list available probes, use the Lister struct."
          ]
        },
        {
          "title": "embedded-hal-mock (GitHub) - dbrgn",
          "url": "https://github.com/dbrgn/embedded-hal-mock",
          "excerpts": [
            "Mocks for testing embedded-hal based drivers without hardware access.",
            "Minimum Supported Rust Version (MSRV)",
            "This crate is guaranteed to compile on the latest stable Rust release."
          ]
        },
        {
          "title": "embedded-hal-mock - eh0 module - API docs",
          "url": "https://docs.rs/embedded-hal-mock/latest/i686-unknown-linux-gnu/embedded_hal_mock/eh0/index.html",
          "excerpts": [
            "This is a collection of types that implement the embedded-hal version 0.x\ntraits."
          ]
        },
        {
          "title": "Foreign Function Interface - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/std_misc/ffi.html",
          "excerpts": [
            "Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign functions must be declared inside an extern block annotated with a #[link] attribute."
          ]
        },
        {
          "title": "question on `repr(C)` guarantees : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1ap47sj/question_on_reprc_guarantees/",
          "excerpts": [
            "repr(C) uses the same layout as the platform's standard C ABI. So structs can be soundly passed to and from C (and other languages that ..."
          ]
        },
        {
          "title": "Complex data types and the Rust FFI | Kyle M. Douglass",
          "url": "http://kmdouglass.github.io/posts/complex-data-types-and-the-rust-ffi/",
          "excerpts": [
            "Apr 4, 2019 — Any type you expect to pass through an FFI boundary should have repr(C), as C is the lingua-franca of the programming world. Next, we define a ..."
          ]
        },
        {
          "title": "FFI - The Rust Programming Language",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/ffi.html",
          "excerpts": [
            "This guide will use the snappy compression/decompression library as an introduction to writing bindings for foreign code."
          ]
        },
        {
          "title": "Interfacing C code with bindgen: #define and types",
          "url": "https://users.rust-lang.org/t/interfacing-c-code-with-bindgen-define-and-types/67595",
          "excerpts": [
            "Nov 19, 2021 — Hello everyone, I started using bindgen and the cc along with a Cargo build script to interface a C library. I'm facing two issues."
          ]
        },
        {
          "title": "Command Line Usage - The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/command-line-usage.html",
          "excerpts": [
            "bindgen takes the path to an input C or C++ header file, and optionally an output file path for the generated bindings."
          ]
        },
        {
          "title": "Generating C bindings with bindgen : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/4o3y4c/generating_c_bindings_with_bindgen/",
          "excerpts": [
            "--use-core Use core as a base crate for Option and such. This is useful for no_std crates, which do not use the full std library. What does :: ...",
            "See also `--ctypes-prefix`. --ctypes-prefix=<prefix> Use this prefix for all the types in the generated code. [default: std::os::raw]. What ..."
          ]
        },
        {
          "title": "Builder in bindgen - Rust - Docs.rs",
          "url": "https://docs.rs/bindgen/latest/bindgen/struct.Builder.html",
          "excerpts": [
            "pub fn use_core(self) -> Builder. Use core instead of std in the generated bindings. std is used by default. Source. pub fn ctypes_prefix<T: Into<String> ..."
          ]
        },
        {
          "title": "Create a build.rs File - The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a build.rs file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is ..."
          ]
        },
        {
          "title": "rust - How do I make rustc-link-search relative to the project ...",
          "url": "https://stackoverflow.com/questions/41917096/how-do-i-make-rustc-link-search-relative-to-the-project-location",
          "excerpts": [
            "I am creating a Rust wrapper around a C library. I've put the C libraries in the lib directory and I am using build.rs to tell the compiler ..."
          ]
        },
        {
          "title": "cc-rs/src/lib.rs at main · rust-lang/cc-rs - GitHub",
          "url": "https://github.com/rust-lang/cc-rs/blob/main/src/lib.rs",
          "excerpts": [
            "Rust library for build scripts to compile C/C++ code into a Rust library - cc-rs/src/lib.rs at main · rust-lang/cc-rs."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "The rustc-link-lib instruction tells Cargo to link the given library using the compiler's -l flag. This is typically used to link a native library using FFI.",
            "The rustc-link-search instruction tells Cargo to pass the -L flag to the compiler to add a directory to the library search path. The optional KIND may be one of ..."
          ]
        },
        {
          "title": "For a no_std crate, libstd is still included in compilation ...",
          "url": "https://www.reddit.com/r/rust/comments/a91qv0/for_a_no_std_crate_libstd_is_still_included_in/",
          "excerpts": [
            "For a no_std crate, libstd is still included in compilation even when crates that have a use_std feature are set to default-features = false."
          ]
        },
        {
          "title": "Is #[repr(C)] necessary for Rust-to-Rust FFI - help",
          "url": "https://users.rust-lang.org/t/is-repr-c-necessary-for-rust-to-rust-ffi/50596",
          "excerpts": [
            "Oct 24, 2020 — The trouble is that in Rust when a struct is repr(Rust) (the default) it is then free to use whatever layout it thinks is most efficient for your program."
          ]
        },
        {
          "title": "Rust's FFI with C : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/18vnsf2/rusts_ffi_with_c/",
          "excerpts": [
            "You can translate C enums into Rust enums by wrapping the number and make 'static constants. The biggest problem I have is to figure out what ..."
          ]
        },
        {
          "title": "#[repr(C)] Structs and FFI : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/6m48tx/reprc_structs_and_ffi/",
          "excerpts": [
            "I'm trying to create a Rust library for C++, using the C FFI, as a project to understand Rust better (not a good starting point, but...)."
          ]
        },
        {
          "title": "Tracking issue for asm (inline assembly) #29722",
          "url": "https://github.com/rust-lang/rust/issues/29722",
          "excerpts": [
            "Nov 9, 2015 — This issue tracks stabilization of inline assembly. The current feature has not gone through the RFC process, and will probably need to do ...",
            "Nov 9, 2015 — This issue tracks stabilization of inline assembly. The current feature has not gone through the RFC process, and will probably need to do so ..."
          ]
        },
        {
          "title": "What's the difference between #[repr(Rust)], #[repr(C)] and ...",
          "url": "https://stackoverflow.com/questions/79631106/whats-the-difference-between-reprrust-reprc-and-reprpacked",
          "excerpts": [
            "#[repr(Rust)] gives the compiler full flexibility to do whatever it likes with the type's layout (as long as each field is individually valid, ...",
            "#[repr(Rust)] is a default behavior while initializing, for an instance, struct or enum and allows the compiler to freely reorder fields for ..."
          ]
        },
        {
          "title": "Is it possible port bindgen into #![no_std] environment?",
          "url": "https://users.rust-lang.org/t/is-it-possible-port-bindgen-into-no-std-environment/112184",
          "excerpts": [
            "If you use #[panic_handler] inside libR-sys, you will not be able to use this crate together with anything that needs libstd at all.",
            "I'm writting a toy Rust lib for R plugins (mostly since the exist one, extendr_api, is slower than expected) and currently stuck at dealing ..."
          ]
        },
        {
          "title": "cc - Rust",
          "url": "https://docs.rs/cc",
          "excerpts": [
            "Missing: embedded kernel"
          ]
        },
        {
          "title": "FFI - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "The following is a minimal example of calling a foreign function which will\ncompile if snappy is installed:\n\n```\nuse libc::size_t;\n\n#[link(name = \"snappy\")]\nunsafe extern \"C\" {\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n}\n\nfn main() {\n    let x = unsafe { snappy_max_compressed_length(100) };\n    println! (\"max compressed length of a 100 byte buffer: {}\", x);\n}\n```\n\nThe `extern` block is a list of function signatures in a foreign library, in\nthis case with the platform's C ABI. The `#[link(...)]` attribute is used to\ninstruct the linker to link against the snappy library so the symbols are\nresolved. Foreign functions are assumed to be unsafe so calls to them need to be wrapped\nwith `unsafe {}` as a promise to the compiler that everything contained within\ntruly is safe. C libraries often expose interfaces that aren't thread-safe, and\nalmost any function that takes a pointer argument isn't valid for all possible\ninputs since the pointer could be dangling, and raw pointers fall outside of\nRust's safe memory model. When declaring the argument types to a foreign function, the Rust compiler\ncannot check if the declaration is correct, so specifying it correctly is part\nof keeping the binding correct at runtime",
            "First, we assume you have a lib crate named as `rust_from_c`. `lib.rs` should have Rust code as following:\n\n```\n\n\n```\n#[unsafe(no_mangle)]\npub extern \"C\" fn hello_from_rust() {\n    println! (\"Hello from Rust! \");\n}\nfn main() {}\n```\n\n\n```\n\nThe `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \"[Foreign Calling Conventions](ffi.html)\". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.\nThen, to compile Rust code as a shared library that can be called from C, add the following to your `Cargo.toml`:\n\n```\n[lib]\ncrate-type = [\"cdylib\"]\n\n```\n\n(NOTE: We could also use the `staticlib` crate type but it needs to tweak some linking flags.) Run `cargo build` and you're ready to go on the Rust side. ### [C side]()\n\nWe'll create a C file to call the `hello_from_rust` function and compile it by `gcc`. C file should look like:\n\n```\nextern void hello_from_rust();\n\nint main(void) {\n    hello_from_rust();\n    return 0;\n}\n\n```\n\nWe name the file as `call_rust.c` and place it on the crate root. Run the following to compile:\n\n```\ngcc call_rust.c -o call_rust -lrust_from_c -L./target/debug\n\n```\n\n`-l` and `-L` tell gcc to find our Rust library. Finally, we can call Rust code from C with `LD_LIBRARY_PATH` specified:\n\n```\n$ LD_LIBRARY_PATH=./target/debug ./call_rust\nHello from Rust! ```",
            "The `link` attribute on `extern` blocks provides the basic building block for\ninstructing rustc how it will link to native libraries.\n ... \nRegardless of the flavor of output for the crate, the native static library\n  will be included in the output, meaning that distribution of the native static\n  library is not necessary. * A normal dynamic dependency. Common system libraries (like `readline`) are\n  available on a large number of systems, and often a static copy of these\n  libraries cannot be found. When this dependency is included in a Rust crate,\n  partial targets (like rlibs) will not link to the library, but when the rlib\n  is included in a final target (like a binary), the native library will be\n  linked in. On macOS, frameworks behave with the same semantics as a dynamic library. [Unsafe blocks]()\n-------------------------------\n\nSome operations, like dereferencing raw pointers or calling functions that have been marked\nunsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to\nthe compiler that the unsafety does not leak out of the block. Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\nthis:\n\n```\n\n\n```\n#! [allow(unused)]\nfn main() {\nunsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n}\n```\n\n\n```\n\nThis function can only be called from an `unsafe` block or another `unsafe` function.",
            "n.catch_unwind.html):\n\n```\n\n\n```\nuse std::panic::catch_unwind;\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn oh_no() -> i32 {\n    let result = catch_unwind(|| {\n        panic!(\"Oops! \");\n    });\n    match result {\n        Ok(_) => 0,\n        Err(_) => 1,\n    }\n}\n\nfn main() {}\n```\n\n",
            "This guide will use the snappy compression/decompression library as an introduction to writing bindings for foreign code. The Dark Arts of Advanced and Unsafe Rust Programming\nFFI - The Rustonomicon"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++.",
            "The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type."
          ]
        },
        {
          "title": "Rust Bindgen no_std FFI and Bindgen Issues discussion",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1583",
          "excerpts": [
            "let bindings = bindgen::Builder::default()\n    .use_core()\n    .ctypes_prefix(\"cty\");",
            "Rust-1.64.0.html) this is now possible:\n\n```\nlet bindings = bindgen::Builder::default()\n    .use_core()\n    .ctypes_prefix(\"::core::ffi\");\n```",
            "The expected way to use `--use-core` is also using --ctypes-prefix. So `./target/debug/bindgen /usr/include/stdint.h --use-core --ctypes-prefix=libc`, for example.",
            "    .ctypes_prefix(\"cty\");",
            "```"
          ]
        },
        {
          "title": "Heapless and Rust Embedded: Portability and Multi-Target/Portability Aspects",
          "url": "http://github.com/rust-embedded/heapless",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "DMA Networking — Matt Keeter Blog",
          "url": "https://www.mattkeeter.com/blog/2023-10-31-dma/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "Rust Nomicon: Working with Unsafe",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/index.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Rust no_std FFI and bindgen with no_std constraints (Discussion on no_std, bindgen usage, and build.rs)",
          "url": "https://users.rust-lang.org/t/how-to-build-c-static-library-into-a-rust-crate-for-no-std-environmrnt/45899",
          "excerpts": [
            "Since I need this to be no\\_std, I used \"--ctypes-prefix=cty\" and \"--use-core\" flag for bindgen. `bindgen --ctypes-prefix=cty --use-core wrapper.h > src/lib.rs",
            "3.\nFinally I created a build.rs under to build this crate by following bindgen user guide.",
            "extern crate bindgen;",
            "println! (\"cargo:rustc-link-search=native=./mbedtls\")",
            "println! (\"cargo:rustc-link-lib=static=mbedtls\")",
            "println! (\"cargo:rustc-link-lib=static=mbedx509\")",
            "println! (\"cargo:rustc-link-lib=static=mbedcrypto\")",
            ".header(\"wrapper.h\")",
            "Since I need this to be no\\_std, I used \"--ctypes-prefix=cty\" and \"--use-core\" flag for bindgen",
            "The bindgen::Builder is the main entry point",
            "to bindgen, and lets you build up options for",
            "the resulting bindings."
          ]
        },
        {
          "title": "Rust Embedded Interoperability - C with Rust (no_std)",
          "url": "https://docs.rust-embedded.org/book/interoperability/c-with-rust.html",
          "excerpts": [
            "use_core() / --use-core to make the generated code #![no_std] compatible. bindgen will produce the generated Rust code to the output of the terminal window.",
            "bindgen` will produce the generated Rust code to the output of the terminal window. This output may be piped to a file in your project, such as `bindings.rs`",
            "Tip: don't forget to use the [`cty`](https://crates.io/crates/cty) crate if your types in the generated bindings are prefixed with `cty`.",
            "A `build.rs` script is a file written in Rust syntax, that is executed on your compilation machine, AFTER dependencies of your project have been built, but BEFORE your project is built.",
            "For embedded projects, this most commonly means compiling the C/C++ code to a static archive (such as `cool-library.a` ), which can then be combined with your Rust code at the final linking step.",
            "Tip: use `Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and `Builder.use_core()` / `--use-core` to make the generated code `#! [no_std]` compatible.",
            "```rust\nfn main() {\n    cc::Build::new()\n        .file(\"src/foo.c\")\n        .compile(\"foo\");\n}\n```\n"
          ]
        },
        {
          "title": "Build Script Examples - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "This example demonstrates how to link a system library and how the build script is used to support this use case.",
            "The [`cc` crate](https://crates.io/crates/cc) abstracts a range of build script requirements for C code:\n\n* It invokes the appropriate compiler (MSVC for windows, `gcc` for MinGW, `cc` for Unix platforms, etc.). * It takes the `TARGET` variable into account by passing appropriate flags to\n  the compiler being used.\n* Other environment variables, such as `OPT_LEVEL` , `DEBUG` , etc., are all\n  handled automatically. * The stdout output and `OUT_DIR` locations are also handled by the `cc` library.",
            " :\n\n* [`bindgen`](https://crates.io/crates/bindgen) — Automatically generate Rust\n  FFI bindings to C libraries.",
            "\nSome Cargo packages need to have code generated just before they are compiled\nfor various reasons. Here we’ll walk through a simple example which generates a\nlibrary call as part of the build script.",
            "```rust\n// build.rs\n\nfn main() {\n    cc::Build::new()\n        .file(\"src/hello.c\")\n        .compile(\"hello\");\n    println! (\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n\nThe [`cc` crate](https://crates.io/crates/cc) abstracts a range of build script requirements for C code:",
            "This build script starts out by compiling our C file into an object file (by\ninvoking `gcc` ) and then converting this object file into a static library (by\ninvoking `ar` ). The final step is feedback to Cargo itself to say that our\noutput was in `out_dir` and the compiler should link the crate to `libhello.a` statically via the `-l static=hello` flag.",
            "Pretty similar to before!",
            "the manifest:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"hello-world-from-c\"\nversion = \"0.1.0\"\nedition = \"2024\"\n```\n\nFor now we’re not going to use any build dependencies, so let’s take a look at\nthe build script now:\n\n```\n```rust\n// build.rs\n\nuse std::process::Command;\nuse std::env;\nuse std::path::Path;\n\nfn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n\n    // Note that there are a number of downsides to this approach, the comments\n    // below detail how to improve the portability of these commands. Command::new(\"gcc\").args(&[\"src/hello.c\", \"-c\", \"-fPIC\", \"-o\"])\n                       .arg(&format! (\"{}/hello.o\", out_dir))\n                       .status().unwrap();\n    Command::new(\"ar\").args(&[\"crus\", \"libhello.a\", \"hello.o\"])\n                      .current_dir(&Path::new(&out_dir))\n                      .status().unwrap();\n\n    println! (\"cargo::rustc-link-search=native={}\", out_dir);\n    println! (\"cargo::rustc-link-lib=static=hello\");\n    println! (\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n```\n\nThis build script starts out by compiling our C file into an object file (by\ninvoking `gcc` ) and then converting this object file into a static library (by\ninvoking `ar` )."
          ]
        },
        {
          "title": "Rust FFI and bindgen: Integrating Embedded C Code in Rust",
          "url": "https://dev.to/theembeddedrustacean/rust-ffi-and-bindgen-integrating-embedded-c-code-in-rust-26j6",
          "excerpts": [
            "Bindgen is a Rust library that generates Rust FFI bindings to C and C++ libraries. It takes as input the C or C++ header files of a library and ..."
          ]
        },
        {
          "title": "rust-lang/rust-bindgen: Automatically generates Rust FFI ... - GitHub",
          "url": "https://github.com/rust-lang/rust-bindgen",
          "excerpts": [
            "bindgen automatically generates Rust FFI bindings to C (and some C++) libraries. For example, given the C header doggo.h."
          ]
        },
        {
          "title": "rust-lang/cc-rs: Rust library for build scripts to compile C/ ...",
          "url": "https://github.com/rust-lang/cc-rs",
          "excerpts": [
            "A library for Cargo build scripts to compile a set of C/C++/assembly/CUDA files into a static archive for Cargo to link into the crate being built."
          ]
        },
        {
          "title": "Inline assembly - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/inline-assembly.html",
          "excerpts": [
            "With the global_asm! macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly ...",
            "Support for inline assembly is provided via the [`asm!`](../core/arch/macro.asm.html) , [`naked_asm!`](../core/arch/macro.naked_asm.html) , and [`global_asm!`](../core/arch/macro.global_asm.html) macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler. [[asm .stable-targets]](#r-asm.stable-targets \"asm.stable-targets\")",
            "The compiler will emit an error if an assembly macro is used on an unsupported target. [[asm.example]](.example \"asm.example\")",
            "* x86 and x86-64",
            "Support for inline assembly is stable on the following architectures:\n\n* x86 and x86-64\n* ARM\n* AArch64 and Arm64EC\n* RISC-V\n* LoongArch\n* s390x",
            "The assembler template uses the same syntax as [format strings](../alloc/fmt/index.html) (i.e. placeholders are specified by curly braces).",
            "With the `asm!` macro, the assembly code is emitted in a function scope and integrated into the compiler-generated assembly code of a function.",
            "With the `naked_asm!` macro, the assembly code is emitted in a function scope and constitutes the full assembly code of a function.",
            "With the `global_asm!` macro, the assembly code is emitted in a global scope, outside a function.",
            "ing grammar specifies the arguments that can be passed to the `asm!` , `global_asm!` and `naked_asm!` macros.",
            "* ARM",
            "* RISC-V",
            "* LoongArch",
            "* s390x",
            "pure nomem readonly preserves\\_flags noreturn nostack att\\_syntax r"
          ]
        },
        {
          "title": "Bindgen passes the rust target to clang. It should pass the host target",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1728",
          "excerpts": [
            "I call bindgen from build.rs, together with the cc invocation to compile the C library. I get a large amount of errors from clang about types ..."
          ]
        },
        {
          "title": "The Embedded Rustacean — FFI and Bindgen: Integrating Embedded C Code in Rust",
          "url": "https://blog.theembeddedrustacean.com/rust-ffi-and-bindgen-integrating-embedded-c-code-in-rust",
          "excerpts": [
            "FFI is explained and a step by step tutorial is provided going over an example creating Rust interfaces for the C-based STM32 HAL libraries.",
            "Now that we have the bindings created we need to include the needed statements in `main.rs` allowing us to use them. That is done with the following code:\n\nCopy\n\nCopy\n\n```\n#! [allow(non_upper_case_globals)]\n#! [allow(non_camel_case_types)]\n#! [allow(non_snake_case)]\n\ninclude!(concat!(env! (\"OUT_DIR\"), \"/bindings.rs\"));",
            "   .use_core()\n        .ctypes_prefix(\"cty\")",
            "It also provides options to customize the generated Rust code, such as renaming types and functions, marking certain types as opaque, and ignoring certain functions or types."
          ]
        }
      ],
      "reasoning": "The finegrained field describes architecture-specific interrupt/exception handling in no_std contexts, and the excerpts provide concrete guidance across Cortex-M and RISC-V runtimes, how vector tables and entry points are defined, how the interrupt/exception handlers are declared and registered, and how to protect shared state within ISRs. The most directly relevant material is the Cortex-M-RT documentation and sample code showing how to declare entry points, the #[interrupt] attribute for device interrupts, the #[exception] handlers (e.g., HardFault, SysTick), and the need for a single panic handler in no_std, plus linker memory layout to place the vector table. This is followed by practical discussion of how to safely share state between an ISR and the main thread using critical sections and Mutex/RefCell patterns, which are central to no_std interrupt safety. The riscv-rt material is also relevant, showing the corresponding external_interrupt attribute and how the vector/interrupt mechanism is wired for RISC-V, including the PLIC management concepts. The vector-table and startup/linker details (memory.x) provide the grounding for how interrupts are wired up at boot, which is essential for understanding the field's context. Overall, the set of excerpts supports the claim that in no_std environments, interrupt/exception handling relies on architecture-specific runtime crates (cortex-m-rt, riscv-rt) and on conservative patterns (critical sections, Mutex<RefCell<T>> or atomic primitives) to keep ISRs brief and delegate work to the main context, with appropriate vector table wiring via linker scripts and proper panic handling. The claim is strongly supported by multiple, concrete excerpts showing the exact mechanisms and patterns across the two architectures.",
      "confidence": "high"
    },
    {
      "field": "toolchain_linking_and_memory_layout",
      "citations": [
        {
          "title": "cortex-m-rt/link.x.in at master",
          "url": "https://github.com/rust-embedded/cortex-m-rt/blob/master/link.x.in",
          "excerpts": [
            "Jan 24, 2022 — Minimal startup / runtime for Cortex-M microcontrollers - cortex-m-rt/link.x.in at master · rust-embedded/cortex-m-rt."
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "/* Linker script for the STM32F303VCT6 */\nMEMORY\n{\n/* NOTE 1 K = 1 KiBi = 1024 bytes */\nFLASH : ORIGIN = 0x08000000, LENGTH = 256K\nRAM : ORIGIN = 0x20000000, LENGTH = 40K\n}\nNOTE : If you for some reason changed the\nmemory.x file after you had made\nthe first build of a specific build target, then do\ncargo clean before\ncargo build , because\ncargo build may not track updates of\nmemory.x .",
            "The second step is to enter the memory region information into the memory.x file.",
            "/* Linker script for the STM32F303VCT6 */",
            "memory",
            "{",
            "/* NOTE 1 K = 1 KiBi = 1024 bytes */",
            "FLASH : ORIGIN = 0x08000000, LENGTH = 256K",
            "RAM : ORIGIN = 0x20000000, LENGTH = 40K",
            "}"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "memory",
            "{",
            "}",
            "}",
            "}",
            "    // Put the linker script somewhere the linker can find it. fs::write(out_dir.join(\"memory.x\"), include_bytes! (\"memory.x\")).unwrap();"
          ]
        },
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "memory",
            "{",
            "{",
            "SECTIONS\n{\n  .vector_table ORIGIN(FLASH) :\n  {\n    /* First entry: initial Stack Pointer value */\n    LONG(ORIGIN(RAM) + LENGTH(RAM));\n\n    /* Second entry: reset vector */\n    KEEP(*(.vector_table.reset_vector));\n  } > FLASH",
            "    /* First entry: initial Stack Pointer value */",
            "    LONG(ORIGIN(RAM) + LENGTH(RAM));",
            "    /* Second entry: reset vector */",
            "    KEEP(*(.vector_table.reset_vector));",
            "  .text :",
            "    *(.text .text. *);",
            "  } > FLASH",
            "  } > FLASH",
            "  /DISCARD/ :",
            "  {",
            "  {",
            "  {",
            "    *(.ARM.exidx .ARM.exidx. *);",
            "  }",
            "}",
            "}",
            "#[link_section = \".vector_table.reset_vector\"]"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "{",
            "}"
          ]
        },
        {
          "title": "cortex-m-quickstart/memory.x at master",
          "url": "https://github.com/rust-embedded/cortex-m-quickstart/blob/master/memory.x",
          "excerpts": [
            "Use this variable to locate the call stack and static variables in different memory regions. Below is shown the default value."
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Why I like programming for #![no_std] in Rust (even without ...",
          "url": "https://www.reddit.com/r/rust/comments/emq98r/why_i_like_programming_for_no_std_in_rust_even/",
          "excerpts": [
            "The main limitation is that you can't ever have a Vec or a HashMap or a HashSet or a Box, basically anything that goes on the heap."
          ]
        },
        {
          "title": "Status of LTO option - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/status-of-lto-option/49032",
          "excerpts": [
            "I discovered the lto = true in the [profile] section. This link time optimization leads to 17% performance increase on my release build."
          ]
        },
        {
          "title": "Rust OS Blog - Hello RISCV (Henry Greßmann)",
          "url": "https://blog.henrygressmann.de/rust-os/1-hello-riscv/",
          "excerpts": [
            "```\n\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\nfn main() {\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n\n    fs::write(out_dir.join(\"memory.x\"), include_bytes! (\"memory.x\")).unwrap();\n    println! (\"cargo:rustc-link-search={}\", out_dir.display());\n    println! (\"cargo:rerun-if-changed=memory.x\");\n    println! (\"cargo:rerun-if-changed=build.rs\");\n}\n\n```"
          ]
        },
        {
          "title": "cortex-m-rt crate docs",
          "url": "https://docs.rs/cortex-m-rt",
          "excerpts": [
            "The required steps are shown below: $ cat > memory.x <<EOF MEMORY { FLASH : ORIGIN = 0x08000000, LENGTH = 64K RAM : ORIGIN = 0x20000000, LENGTH ...",
            "To actually build this program you need to place a memory.x linker script somewhere the linker can find it, e.g. in the current directory; and then link the ...See more",
            "This crate contains all the required parts to build a no_std application (binary crate) that targets a Cortex-M microcontroller."
          ]
        },
        {
          "title": "Cortex-M Runtime Documentation",
          "url": "https://docs.rust-embedded.org/cortex-m-quickstart/cortex_m_rt/index.html",
          "excerpts": [
            "This crate expects the user, or some other crate, to provide the memory layout of the target\ndevice via a linker script named `memory.x`.",
            "The linker script must specify the memory available in the device as, at least, two `MEMORY`\nregions: one named `FLASH` and one named `RAM`. The `.text` and `.rodata` sections of the\nprogram will be placed in the `FLASH` region, whereas the `.bss` and `.data` sections, as well\nas the heap,will be placed in the `RAM` region.",
            "This optional symbol can be used to indicate where the call stack of the program should be\nplaced. If this symbol is not used then the stack will be placed at the *end* of the `RAM`\nregion -- the stack grows downwards towards smaller addres",
            "This optional symbol can be used to control where the `.text` section is placed. If omitted the\n`.text` section will be placed right after the vector table, which is placed at the beginning of\n`FLASH`.",
            "The memory layout of the program. In particular, it populates the vector table so the device\n  can boot correctly, and properly dispatch exceptions and interrupt",
            "To actually build this program you need to place a `memory.x` linker script somewhere the linker\ncan find it, e.g. in the current directory; and then link the program using `cortex-m-rt`'s\nlinker script: `link.x`.",
            "This crate contains all the required parts to build a no_std application (binary crate) that targets a Cortex-M microcontroller."
          ]
        },
        {
          "title": "Bare Metal Rust on RISC-V With Dynamic Memory",
          "url": "https://popovicu.com/posts/bare-metal-rust-risc-v-with-dynamic-memory/",
          "excerpts": [
            "revious article, we have to provide a linker script in order to lay the program bytes properly into the memory. Our linker script now will look very similar to the old one, just with some added details. Let’s take a look:",
            "``\nMEMORY {\n  program (rwx) : ORIGIN = 0x80000000, LENGTH = 2 * 1024 * 1024\n}\n\nSECTIONS {\n  .text.boot : {\n    *(.text.boot)\n  } > program\n\n  .text : {\n    *(.text)\n  } > program\n\n  .data : {\n    *(.data)\n  } > program\n\n  .rodata : {\n    *(.rodata)\n  } > program\n\n  .bss : {\n    *(.bss)\n  } > program\n\n  . = ALIGN(8);\n  . = . + 4096;\n  _STACK_PTR = .\n;\n}\n```\n\nWe want to create a special section we’ll call `.text.boot` and make sure it’s laid out at `0x80000000`. This section will contain our warmup for entry to the Rust code. Following that will be any code that the Rust compiler generates, followed by the section for data, etc. After all that, we want to lay our **stack**. In this example, we allocated 4 KB for the stack. The last few lines should be fairly self explanatory:\n\n1. We align the stack to the 8 byte boundary. 2. We allocate 4 KB for the stack. 3. Now we capture the starting point of the stack. You may be curious why do we capture it higher in the address space — this is because the stack “grows downwards” per the convention, i.e. when something is added to the stack, the stack pointer is **subtracted from**. The way we *capture* the position of the stack is we export the symbol `_STACK_PTR` to be visible to our code and we use that symbol to get the value of the address. It should be clearer once we get to our assembly warmup code. Now we need to make sure that Cargo uses our link script. This is done by tweaking the Cargo",
            "Assembly warmup",
            "\n\nInside the `src` directory, we add a file called `entry.s` with the following contents:",
            "```\n\t.global _start\n\t.extern _STACK_PTR\n\n\t.section .text.boot\n\n_start:\tla sp, _STACK_PTR\n\tjal main\n\tj . ```",
            "The `_start` symbol is global. It’s the typical way to mark the starting point of a program.",
            "uild.rs`.\nAssembly warmup\n---------------\n\nInside the `src` directory, we add a file called `entry.s` with the following contents:\n\n```\n\t.global _start\n\t.extern _STACK_PTR\n\n\t.section .text.boot\n\n_start:\tla sp, _STACK_PTR\n\tjal main\n\tj . ```\n\nThe `_start` symbol is global. It’s the typical way to mark the starting point of a program. It doesn’t matter too much for us here, as we’ll lay the instructions at the right physical address anyway, but let’s keep it for consistency. We instruct the assembler that the `_STACK_PTR` symbol is external. There’s essentially a hole wherever `_STACK_PTR` is used and that hole will be filled up by the linker. The linker will figure out to calculate the value of the symbol per instructions from the linker script, and that value will be placed into the hole that is supposed to hold the `_STACK_PTR` value. Next we declare the start of the `.text.boot` section which we ensured in the linker script starts from `0x80000000` and so these will be the first instructions run by the machine. We basically just wanted to set up the stack pointer before we jump into the `main` function from our Rust code. The final `j` instruction ensures we keep looping in case where for whatever reason we ever exit the Rust `main` function, but that should really never happen, so the last instruction should be effectively dead code. Now that the stack pointer is set up and we are ready to jump into the `main`, let’s write the Rust code.\n",
            "Rust logic",
            "static mut ARENA: [u8; 50000] = [0; 50000];",
            "\n\n#[global_allocator]\nstatic ALLOCATOR: Talck<spin::Mutex<()>, ClaimOnOom> = Talc::new(unsafe {ClaimOnOom::new(Span::from_array(&mut ARENA))}).lock();",
            "The memory allocation happens on a static blob of 50k bytes, marked as `ARENA`. Rust has an abstraction layer for memory allocation that can also work under the bare metal environment.",
            ". This library is the reason why we needed `#! [feature(const_mut_refs)]` above; without it, we cannot modify the statically allocated `ARENA`.",
            "GitHub repo",
            "Over there, you can checkout the `README` file which will tell you how to build and run this on QEMU.",
            "Finally, I’d like to note that I’ve run into some issues with the dynamic strings, and that *may* be due to the `Talc` librar"
          ]
        }
      ],
      "reasoning": "The finegrained field describes how memory layout and linking for no_std systems are governed by explicit linker scripts (memory.x for ARM/RISC-V style targets; link.x for Cortex-M families in some setups), how these scripts define FLASH vs RAM regions, and how startup/runtime crates rely on those sections. The most direct support comes from excerpts that show concrete memory maps and linker scripts placed in the project to drive placement of .text into FLASH and .data/.bss into RAM, as well as excerpts showing startup/copy of data, zeroing of BSS, and entry/init flow that depends on memory sections being located correctly by the linker. The following excerpts provide direct evidence of memory.x usage, memory maps, and startup/runtime interplay: - A Cortex-M RT example that explicitly mentions a memory.x and its role in memory layout and how .text is placed in FLASH and RAM data sections are placed for initialization. - Cortex-M runtime documentation that describes the required memory regions (FLASH and RAM) and the memory layout obligations, including the need to copy .data from FLASH to RAM and zero .bss. - Examples showing concrete memory.x contents and region aliases (REGION_TEXT, REGION_RODATA, REGION_DATA, REGION_BSS, REGION_HEAP, REGION_STACK) used to describe the layout. - Build script snippet that copies a memory.x into the build output to ensure the linker sees it. - Multiple specific memory.x examples in the Cortex-M and RISC-V spaces demonstrating how the linker script assigns FLASH/RAM and how startup code initializes sections prior to main. - References illustrating that the startup code (Reset, entry points) relies on those sections having been laid out by the linker so that .data can be copied from FLASH to RAM and .bss zeroed before main executes. The overall synthesis of these excerpts confirms the field value: the build and linking process for a no_std application is fundamentally controlled by a linker script (memory.x), which defines memory regions (FLASH, RAM) and placement of sections (.text to FLASH, .data/.bss to RAM), and startup/runtime crates rely on that layout to initialize memory before entering main. The remaining excerpts provide context on how the linker script is integrated into build tooling, and how memory layout is discussed in related no_std and embedded Rust literature, but the strongest support comes from explicit memory.x examples and the standard startup/init narrative tied to those sections.",
      "confidence": "high"
    },
    {
      "field": "persistent_storage_on_flash_and_eeprom",
      "citations": [
        {
          "title": "embedded_storage::nor_flash - Rust",
          "url": "https://docs.rs/embedded-storage/latest/embedded_storage/nor_flash/index.html",
          "excerpts": [
            "The `nor_flash` module provides technology-specific traits for NOR Flashes, including `NorFlash`, `ReadNorFlash`, and `MultiwriteNorFlash` traits."
          ]
        },
        {
          "title": "littlefs2 - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/littlefs2",
          "excerpts": [
            "Idiomatic Rust API for the littlefs microcontroller filesystem by Chris Haster. Number 2 refers to the on-disk format version, supporting inline files."
          ]
        },
        {
          "title": "nRF5 SDK v12.1.0: Experimental: Flash Data Storage",
          "url": "https://docs.nordicsemi.com/bundle/sdk_nrf5_v12.1.0/page/lib_fds.html",
          "excerpts": [
            "Jun 27, 2024 — The Flash Data Storage (FDS) module is a minimalistic file system for the flash storage on the chip that minimizes the risk of data corruption ..."
          ]
        },
        {
          "title": "Rust implementation of CRC.",
          "url": "https://lib.rs/crates/crc",
          "excerpts": [
            "no-std crc. Rust implementation of CRC with support of various standards. by Rui Hu, Akhil Velagapudi and 17 contributors · Audit · Install · API reference ..."
          ]
        },
        {
          "title": "New non-volatile storage system · Issue #77929 - GitHub",
          "url": "https://github.com/zephyrproject-rtos/zephyr/issues/77929",
          "excerpts": [
            "This storage needs to support millions of entries with solid CRC protection and multiple advanced features. Problem description. In Zephyr, ..."
          ]
        },
        {
          "title": "NVS Documentation (ESP-IDF) - ESP32 Non-Volatile Storage",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/nvs_flash.html",
          "excerpts": [
            "Set operations are appending new data to the free space after existing entries.",
            "Invalidation of old values doesn't require immediate flash erase operations.",
            "The organization of NVS space to pages and entries effectively reduces the frequency of flash erase to flash write operations by a factor of 126.",
            "NVS component includes flash wear levelling by design."
          ]
        },
        {
          "title": "ESP-IDF Wear Leveling Documentation",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/wear-levelling.html",
          "excerpts": [
            "The wear levelling component provides API functions related to reading, writing, erasing, and memory mapping of data in external SPI flash through the partition ... memory sector. ",
            "The wear levelling component helps to distribute wear and tear among sectors more evenly without requiring any attention from the user.",
            "The wear levelling component, together with the FAT FS component, uses FAT FS sectors of 4096 bytes, which is a standard size for flash memory.",
            "With this size, the component shows the best performance but needs additional memory in RAM.",
            "*Performance mode. ** Erase sector operation data is stored in RAM, the sector is erased, and then data is copied back to flash memory. However, if a device is powered off for any reason, all 4096 bytes of data is lost.",
            "  **Safety mode. ** The data is first saved to flash memory, and after the sector is erased, the data is saved back. If a device is powered off, the data can be recovered as soon as the device boots up.",
            "The wear levelling component does not cache data in RAM."
          ]
        },
        {
          "title": "AN4868 EEPROM emulation (NXP)",
          "url": "https://www.nxp.com/docs/en/application-note/AN4868.pdf",
          "excerpts": [
            "During the block swap\nprocedure, if a critical error occurs or if power is removed from the device before the software can write every record back\ninto flash memory, the data in these records will be lost."
          ]
        },
        {
          "title": "Storage in embedded_storage - Rust",
          "url": "https://docs.rs/embedded-storage/latest/embedded_storage/trait.Storage.html",
          "excerpts": [
            "Write a slice of data to the storage peripheral, starting the write operation at the given address offset (between 0 and self.capacity() )."
          ]
        },
        {
          "title": "Sequential-storage － Efficiently Store Data in Flash | Interrupt",
          "url": "https://interrupt.memfault.com/blog/sequential-storage-crate",
          "excerpts": [
            "A discussion of a sequential storage crate which can be used in Rust projects for efficiently storing data in NOR flash."
          ]
        },
        {
          "title": "crc-any - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/crc-any/2.0.0",
          "excerpts": [
            "Jul 6, 2019 — To compute CRC values by providing the length of bits, expression, reflection, an initial value and a final xor value. It has many built-in CRC functions."
          ]
        },
        {
          "title": "crc-any - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/crc-any",
          "excerpts": [
            "May 1, 2024 — To compute CRC values by providing the length of bits, expression, reflection, an initial value and a final xor value. It has many built-in CRC functions."
          ]
        },
        {
          "title": "DESIGN.html (LittleFS design overview)",
          "url": "https://mcuxpresso.nxp.com/mcuxsdk/25.09.00-pvw1/html/middleware/littlefs/DESIGN.html",
          "excerpts": [
            "This document covers the high-level design of littlefs, how it is different than other filesystems, and the design decisions that got us here."
          ]
        },
        {
          "title": "Non-Volatile Storage (NVS) - Zephyr Project Documentation",
          "url": "https://docs.zephyrproject.org/latest/services/storage/nvs/nvs.html",
          "excerpts": [
            "The flash area is divided into sectors. Elements are appended to a sector until storage space in the sector is exhausted. Then a new sector in the flash area is ..."
          ]
        },
        {
          "title": "An4894 Eeprom Emulation Techniques and Software For ...",
          "url": "https://www.scribd.com/document/647540745/an4894-eeprom-emulation-techniques-and-software-for-stm32-microcontrollers-stmicroelectronics",
          "excerpts": [
            "4.2 Wear leveling algorithm and Flash page allocation. A wear leveling algorithm allows monitoring and even distribution of Flash Write and Erase operations ..."
          ]
        },
        {
          "title": "EEPROM wear leveling algorithm",
          "url": "https://electronics.stackexchange.com/questions/742939/eeprom-wear-leveling-algorithm",
          "excerpts": [
            "I am using an EEPROM to store some configurations for the MCU logic that must be retained if a power down condition occurs."
          ]
        },
        {
          "title": "littlefs2 Documentation",
          "url": "https://docs.rs/littlefs2",
          "excerpts": [
            "the [`Storage`](driver/trait.Storage.html) trait defines a block device in\nterms of actual and `typenum` constants, and an implementation supplies methods to read, erase and write.",
            "The filesystem and each open file need memory for state and caching, this has to be allocated\nbeforehand and passed to constructors.",
            "All operations on the filesystem require passing a `&mut Storage`, which guarantees by Rust’s\nborrow checker that only one thread can manipulate the filesystem",
            "This library is `no_std` compatible, but there are two gotchas."
          ]
        },
        {
          "title": "sequential-storage crate (crates.io)",
          "url": "https://crates.io/crates/sequential-storage",
          "excerpts": [
            "Wear leveling"
          ]
        },
        {
          "title": "Tock TicKV Documentation",
          "url": "https://github.com/tock/tock/blob/master/libraries/tickv/README.md",
          "excerpts": [
            "Wear leveling",
            "Fully implemented in no_std Rust",
            "Power loss resilient",
            "Maintain data integrity and detect media errors"
          ]
        },
        {
          "title": "TickKV No_std Persistence and IC Concepts",
          "url": "https://docs.rs/tickv",
          "excerpts": [
            "Wear leveling",
            "Fully implemented in no_std Rust",
            "Power loss resilient",
            "Maintain data integrity and detect media errors",
            "Low memory usage",
            "Low storage overhead",
            "TicKV was written to allow the Tock OS kernel to persistently store app data\non flash",
            "It was written to be generic though, so other Rust applications can\nuse it if they want",
            "TicKV is based on similar concepts as",
            "ACID characteristics",
            "TicKV provides ACID properties",
            "FlashController`\nimplementation complete all transactions in a single operatio",
            "the\nflash `write()` function must either successfully write all of the data or\nnone",
            "If the implementation completes a partial operation, then the Atomicity\nand Consistency traits will be lost",
            "If the implementation reports completion\nwhen the data hasn’t been written yet, then the Isolation trait will be lost"
          ]
        },
        {
          "title": "AN4894 How to Use EEPROM Emulation on STM32 MCUs",
          "url": "https://www.st.com/resource/en/application_note/an4894-how-to-use-eeprom-emulation-on-stm32-mcus-stmicroelectronics.pdf",
          "excerpts": [
            "ear leveling algorithm allows monitoring and even distribution of flash memory write and erase operations  \nbetween flash memory pages",
            "he EEPROM  \nemulation software always returns the latest valid data value by finding the previous value for this data stored in  \nflash memo",
            "The EEPROM emulation software is designed and validated to be robust against power failures and  \nasynchronous reset",
            "To detect corrupted data (virtual address and/or data value), a 16-bit CRC (cyclic redundancy check) has been  \nimplemented. It is based on the ANSI CRC-16 with the following polynomial: x15 + x2 + 1 (represented as  \n0x80",
            "To store 4000 individual bytes, and knowing that each page can store up to 252 elements, a set of pages must  \ncomprise 16 flash memory pages. A second set of pages, of the same size, is required to transfer data when the  \nfirst one is f",
            "When writing a variable element, it is stored with its corresponding CRC value. When reading or transferring a  \nvariable element, the CRC is computed and checked against the value stored in the variable element. If it  \nmatches, the variable element is considered as valid. In the case of a mismatch, the variable element is  \ninvali",
            "In an embedded application, it is possible that a power failure or asynchronous reset might occur while  \nprogramming or erasing the flash memory. In this case, the content of the flash memory line (if programming) or  \nthe complete flash memory page (if erasing) is unkn"
          ]
        },
        {
          "title": "embedded_crc_macros - Rust",
          "url": "https://docs.rs/embedded-crc-macros",
          "excerpts": [
            "This crate provides macros that define portable CRC-8 algorithm implementations with the parameters directly provided at compile time and without any dependencies. Intended for use in `no_std`."
          ]
        },
        {
          "title": "EEPROM emulation for MC9S08AC128 - NXP Community",
          "url": "https://community.nxp.com/t5/-/-/m-p/155694?db=5",
          "excerpts": [
            "In order to implement EEPROM emulation using Flash memory, it is required to have a Flash driver that allows erase and write the Flash. When these actions are ..."
          ]
        },
        {
          "title": "AN1095 | Application Note",
          "url": "https://www.microchip.com/en-us/application-notes/an1095",
          "excerpts": [
            "Title. AN1095 - Emulating Data EEPROM for PIC18 and PIC24 Microcontrollers and dsPIC® Digital Signal Controllers · Name. AN1095 · Date. 06/18/2025 · Description."
          ]
        },
        {
          "title": "Protected EEPROM Operations in MAXQ Environments",
          "url": "https://www.analog.com/en/resources/technical-articles/protected-eeprom-operations-in-maxq-environments.html",
          "excerpts": [
            "A problem with any type of nonvolatile storage—from EEPROM to flash to rotating storage—is data loss due to interrupted write cycles. If power ..."
          ]
        },
        {
          "title": "apache/mynewt-nffs",
          "url": "https://github.com/apache/mynewt-nffs",
          "excerpts": [
            "The Newtron Flash File System (NFFS) is a flash file system with the following priorities: Minimal RAM usage; Reliability. RTOS support. NFFS currently supports ..."
          ]
        },
        {
          "title": "Mynewt Documentation",
          "url": "https://mynewt.apache.org/Mynewt.pdf",
          "excerpts": [
            "Sep 26, 2024 — Apache Mynewt is an operating system that makes it easy to develop applications for microcontroller environments."
          ]
        },
        {
          "title": "pellepl/spiffs: Wear-leveled SPI flash file system for ...",
          "url": "https://github.com/pellepl/spiffs",
          "excerpts": [
            "Spiffs is a file system intended for SPI NOR flash devices on embedded targets. Spiffs is designed with following characteristics in mind."
          ]
        },
        {
          "title": "Software-Managed Read and Write Wear-Leveling for Non-Volatile ...",
          "url": "https://dl.acm.org/doi/full/10.1145/3483839",
          "excerpts": [
            "We design a method to approximate read and write accesses to the memory to allow aging aware coarse-grained wear-leveling in the absence of special hardware."
          ]
        },
        {
          "title": "nvs vs spiff vs wear_levelling",
          "url": "https://esp32.com/viewtopic.php?t=3462",
          "excerpts": [
            "Oct 29, 2017 — The \"wear leveling\" library is a layer that is applied to fatfs, which can help to avoid dead blocks. fatfs and spiffs are two different types of file ..."
          ]
        },
        {
          "title": "MSPM0G1507: Problem with eeprom emulation type B - TI E2E",
          "url": "https://e2e.ti.com/administrators1/f/1/t/1470132",
          "excerpts": [
            "I´m using the eeprom emulation type B from the MSPM0 SDK (Version 2_03_00_07) and I encounter the following problem: After running my application on the device ..."
          ]
        },
        {
          "title": "Standard practice for saving data during power off : r/embedded",
          "url": "https://www.reddit.com/r/embedded/comments/yz6mtj/standard_practice_for_saving_data_during_power_off/",
          "excerpts": [
            "I have an array of about 60 bytes that I would like retain in memory when the mcu (STM32) is powered off. Is there a standard practice for this ?"
          ]
        },
        {
          "title": "Can I write directly to flash/partition without fatfs/wear lvl etc ...",
          "url": "https://esp32.com/viewtopic.php?t=18164",
          "excerpts": [
            "Nov 18, 2020 — I am writing to 2 files in the storage section where 1 is a configuration file that only needs to be ~40 bytes and the other is for measurement logging."
          ]
        },
        {
          "title": "Best practice of extending a no_std crate - help",
          "url": "https://users.rust-lang.org/t/best-practice-of-extending-a-no-std-crate/12281",
          "excerpts": [
            "Implement the set of the functionality working with no_std in a \"core crate\" and extend the functionality with a new crate depending on the original crate.",
            "Aug 9, 2017 — Implement the set of the functionality working with no_std in a \"core crate\" and extend the functionality with a new crate depending on the original crate."
          ]
        },
        {
          "title": "How can I use the format! macro in a no_std environment?",
          "url": "https://stackoverflow.com/questions/50200268/how-can-i-use-the-format-macro-in-a-no-std-environment",
          "excerpts": [
            "This macro first reserves a buffer on the stack. Then it uses the struct ArrForm to format text and numbers."
          ]
        },
        {
          "title": "The Road to defmt-1.0 · knurling-rs defmt · Discussion #888",
          "url": "https://github.com/knurling-rs/defmt/discussions/888",
          "excerpts": [
            "The defmt library is described in the defmt book as a highly efficient logging framework that targets resource-constrained devices, like microcontrollers."
          ]
        },
        {
          "title": "Rust custom bare metal compile target: linker expects ...",
          "url": "https://stackoverflow.com/questions/67918256/rust-custom-bare-metal-compile-target-linker-expects-start-symbol-and-discar",
          "excerpts": [
            "I'm cross compiling bare metal 32-bit code for x86 with Rust and I'm facing the problem, that the final object file is empty, if the entry function is not ..."
          ]
        },
        {
          "title": "AN1095, Emulating Data EEPROM for PIC18/PIC24 ...",
          "url": "https://ww1.microchip.com/downloads/en/appnotes/01095c.pdf",
          "excerpts": [
            "AN1095 emulates a data EEPROM for PIC18/PIC24 MCUs and dsPIC DSCs, using program memory for non-volatile data, as an alternative to external EEPROMs."
          ]
        },
        {
          "title": "AN4894 Application Note: EEPROM Emulation on STM32 ...",
          "url": "https://www.studocu.com/row/document/shahid-chamran-university-of-ahvaz/electronic/an4894-how-to-use-eeprom-emulation-on-stm32-mcus-stmicroelectronics/114451547",
          "excerpts": [
            "Simple API consisting of a few functions to format, initialize, read and write data, and clean up flash memory pages. • At least two flash memory pages to be ..."
          ]
        },
        {
          "title": "Data EEPROM Emulation Library (DEE) for dsPIC33 DSCs ...",
          "url": "https://www.microchip.com/en-us/software-library/dspic33-pic24-data-eeprom-emulation",
          "excerpts": [
            "The DEE library implementation is based on Application Note AN1095 - Emulating Data EEPROM for PIC24 Microcontrollers and dsPIC® Digital Signal Controllers."
          ]
        },
        {
          "title": "Lab 5: Multicore and Networking — CS-3210, Spring 2020 1 ...",
          "url": "https://tc.gts3.org/cs3210/2020/spring/lab/lab5.html",
          "excerpts": [
            "Apr 14, 2020 — smoltcp socket APIs are non-blocking. Unlike Berkeley socket API, our socket system calls are non-blocking by default. This is because we are ..."
          ]
        },
        {
          "title": "smoltcp-rs/smoltcp: a smol tcp/ip stack",
          "url": "https://github.com/smoltcp-rs/smoltcp",
          "excerpts": [
            "*smoltcp* does not need heap allocation *at all*, is [extensively documented](https://docs.rs/smoltcp/),\nand compiles on stable Rust 1.81 and later.",
            "smoltcp is a standalone, event-driven TCP/IP stack that is designed for bare-metal, real-time systems. Its design goals are simplicity and robustness."
          ]
        },
        {
          "title": "smoltcp - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/smoltcp/0.3.0",
          "excerpts": [
            "The alloc feature enables use of objects owned by the networking stack through a dependency on alloc::boxed::Box . This only works on nightly ..."
          ]
        },
        {
          "title": "smoltcp::wire - Rust",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/wire/index.html",
          "excerpts": [
            "Low-level packet access and construction. smoltcp::wire - Rust\n\n[Docs.rs](/)\n\n* [smoltcp-0.12.0](# \"A TCP/IP stack designed for bare-metal, real-time systems without a heap.\")",
            "Low-level packet access and construction. The wire module deals with the packet representation. It provides two levels of functionality.",
            "The `wire` module provides low-level packet access and construction, extracting/inserting fields and compacting packet data for parsing and emission."
          ]
        },
        {
          "title": "bytemuck - Rust",
          "url": "https://docs.rs/bytemuck",
          "excerpts": [
            "This crate gives small utilities for casting between plain data types. Basics Data comes in five basic forms in Rust, so we have five basic casting functions."
          ]
        },
        {
          "title": "`Pod` derive should work for generic types with `#[repr(C, ...",
          "url": "https://github.com/Lokathor/bytemuck/issues/70",
          "excerpts": [
            "Jul 20, 2021 — Generated structure must be Pod to support casting to/from bytes. For this I add #[repr(C, packed)] attribute, but have to implement Pod trait manually which I ..."
          ]
        },
        {
          "title": "etherparse/ lib.rs",
          "url": "https://docs.rs/etherparse/latest/src/etherparse/lib.rs.html",
          "excerpts": [
            "It is completely written in Rust and thoroughly tested.",
            "Special attention has been paid to not use allocations or syscalls.",
            "#! [no_std"
          ]
        },
        {
          "title": "embassy_net - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-net/",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "embassy-net - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embassy-net",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "embassy_net - Rust",
          "url": "https://docs.rs/embassy-net/latest/embassy_net/",
          "excerpts": [
            "embassy-net is a no-std no-alloc async network stack, designed for embedded systems. It builds on smoltcp. It provides a higher-level and more opinionated API."
          ]
        },
        {
          "title": "netstack-smoltcp - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/netstack-smoltcp",
          "excerpts": [
            "Jul 10, 2025 — Netstack Smoltcp. A netstack for the special purpose of turning packets from/to a TUN interface into TCP streams and UDP packets."
          ]
        },
        {
          "title": "Non-blocking socket with poll",
          "url": "https://stackoverflow.com/questions/3360797/non-blocking-socket-with-poll",
          "excerpts": [
            "Using poll() or select() with a non-blocking file descriptor gives you two advantages: You can set a timeout to block for;; You can wait for ..."
          ]
        },
        {
          "title": "Is it considered bad practice to use non blocking sockets ...",
          "url": "https://www.reddit.com/r/learnprogramming/comments/141swgo/is_it_considered_bad_practice_to_use_non_blocking/",
          "excerpts": [
            "Is it a bad practice to use non blocking sockets as a substitute for epoll, poll and disable naggles algorithm because I do not understand it?"
          ]
        },
        {
          "title": "Networking and syncing with embassy on embedded : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1eafqwn/networking_and_syncing_with_embassy_on_embedded/",
          "excerpts": [
            "embassy-net is a network stack for embassy applications. You will need it to use network on your esp32. Whatever you build to sync time is going ..."
          ]
        },
        {
          "title": "smolapps - Rust - Docs.rs",
          "url": "https://docs.rs/smolapps",
          "excerpts": [
            "It is a #![ no_std] -first crate, designed for bare-metal, real-time systems. Heap allocations (if at all present) are reduced to a minimum, and will always be ..."
          ]
        },
        {
          "title": "stm32h7xx-hal/src/ethernet/eth.rs at master - GitHub",
          "url": "https://github.com/stm32-rs/stm32h7xx-hal/blob/master/src/ethernet/eth.rs",
          "excerpts": [
            "/// You must move in ETH_MAC, ETH_MTL, ETH_DMA. ///. /// Sets up the descriptor structures, sets up the peripheral."
          ]
        },
        {
          "title": "intended api for serial dma read and write · Issue #9",
          "url": "https://github.com/rust-embedded/embedded-dma/issues/9",
          "excerpts": [
            "Nov 18, 2020 — Is there a good example of buffered read and write using current best practice? I think my setup functions should be able to return buffered ..."
          ]
        },
        {
          "title": "zero-packet",
          "url": "https://github.com/J-Schoepplenberg/zero-packet",
          "excerpts": [
            "Super simple library to efficiently build and parse network packets in-place with zero overhead. No async, no allocations, no dependencies, no std, no unsafe. It simply cannot be easier. Use `zero-packet` if you are working with raw sockets, low-level networking, or something similar. Supported\n---------\n\nYou can build and parse a wide variety of packets of arbitrary complexity.\n* Ethernet II\n  + Optional\n    - VLAN tagging\n    - Double tagging\n* ARP\n* IPv4\n* IPv6\n  + Extension headers\n    - Hop-by-Hop Options\n    - Routing\n    - Fragment\n    - Authentication Header\n    - Destination Options (1st and 2nd)\n* IP-in-IP\n  + Encapsulation\n    - IPv4 in IPv4\n    - IPv4 in IPv6\n    - IPv6 in IPv4\n    - IPv6 in IPv6\n* ICMPv4\n* ICMPv6\n* TCP\n* UDP\n\nUsage\n-----\n\n### Getting started\n\nInstall via your command line:\n\n```\ncargo add zero-packet\n```\n\nOr add the following to your `Cargo.toml`:\n\n```\n[dependencies]\nzero-packet = \"0.1.0\"\n```\n\n### PacketBuilder\n\nIf you want to create network packets manually and efficiently, look no further. ```\n// Raw packet that we will mutate in-place. // Ethernet header (14 bytes) + IPv4 header (20 bytes) + UDP header (8 bytes) = 42 bytes. let mut buffer = [0u8; 64]\n\n// Some random payload (11 bytes). let payload = b\"Hello, UDP! \";\n\n// PacketBuilder is a zero-copy packet builder. // Using the typestate pattern, a state machine is implemented at compile-time. // The state machine ensures that the package is built structurally correct. let mut packet_builder = PacketBuilder::new(&mut buffer);\n\n// Sets Ethernet, IPv4 and UDP header fields. // Optional: add payload to the packet. // Encapsulates everything in the given byte slice. let packet: &[u8] = packet_builder\n    .ethernet(src_mac, dest_mac, ethertype)? .ipv4(version, ihl, dscp, ecn, total_length, id, flags, fragment_offset, ttl, protocol, src_ip, dest_ip)?\n.udp(src_ip, src_port, dest_ip, dest_port, length, Some(payload))? .build();\n```\n\n### PacketParser\n\nParsing any received byte slice for which we don't know ahead of time what type of packet it is. ```\n// Some byte slice that we have received. // We don't know yet what it contains. let packet = [..];\n\n// PacketParser is a zero-copy packet parser. // The `parse` method recognizes which protocol headers are present. let parsed = PacketParser::parse(&packet)? ;\n\n// Now it is as easy as this. if let Some(ethernet) = parsed.ethernet {\n    let ethertype = ethernet.ethertype();\n    // ...\n}\n\n// Or this. if let Some(ipv4) = parsed.ipv4 {\n    let src_ip = ipv4.src_ip();\n    // ...\n}\n\n// Alternatively, just manually read headers directly. // By adjusting the index of the slice you can find different headers. if let Some(tcp) = TcpReader::new(&packet)? {\n    let src_port = tcp.src_port();\n    // ...\n}\n```\n\nAbout\n-----\n\nA zero-copy Rust library that builds and parses network packets in-place. [crates.io/crates/zero-packet](https://crates.io/crates/zero-packet \"https://crates.io/crates/zero-packet\")\n\n### Topics\n\n[networking](/topics/networking \"Topic: networking\")\n[packets](/topics/packets \"Topic: packets\")\n[no-allocation](/topics/no-allocation \"Topic: no-allocation\")\n[zero-copy](/topics/zero-copy \"Topic: zero-copy\")\n[packet-processing](/topics/packet-processing \"Topic: packet-processing\")\n\n### Resources\n\n[Readme]()\n\n### License\n\n[MIT license]()\n\n### Uh oh! There was an error while loading.",
            "Super simple library to efficiently build and parse network packets in-place with zero overhead. No async, no allocations, no dependencies, no std, no unsafe.",
            "no std",
            "no unsafe"
          ]
        },
        {
          "title": "zerocopy crates.io page",
          "url": "https://crates.io/crates/zerocopy",
          "excerpts": [
            " By default, `zerocopy` is `no_std` . When the `alloc` feature is enabled,\n  the `alloc` crate is added as a dependency, and some allocation-related\n  functionality is a",
            " By default, zerocopy is no_std",
            "Zerocopy provides six macros for safe casting between types:\n\n* ( `try_` [try\\_transmute]) `transmute` (conditionally) converts a value of\n  one type to a value of another type of the same size"
          ]
        },
        {
          "title": "How does ethernet RX descriptor wrapping work on STM32H7?",
          "url": "https://community.st.com/t5/stm32-mcus-embedded-software/how-does-ethernet-rx-descriptor-wrapping-work-on-stm32h7/td-p/239129",
          "excerpts": [
            "Descriptors up to N-1 is owned by the DMA and the DMA continues to process descriptors until the Current Descriptor Pointer == Tail Pointer.",
            "The DMA will not start if the tail is written the current pointer.",
            "The Descriptor ring length register (ETH\\_DMACRXRLR) must hod the number of descriptors. However, if I write it with the value 15 (meaning it must only access from index 0 to 14), then I can see the DMA accesses 16 buffers",
            "I cannot figure out the purpose of the tail pointer. I am now writing the value zero to it every chance I get to keep the DMA going. It wraps correctly given my first point.",
            "The ethernet DMA controller's current (internal) descriptor pointers are reset to ETH\\_DMACTXDLAR and ETH\\_DMACRXDLAR when ETH\\_DMACTXCR.ST and ETH\\_DMACRXCR.SR are set respectiv",
            "For receive, a driver might be implemented two ways: (1) write ETH\\_DMACRXDTPR the address of the last descriptor at start-up or the most recently used descriptor after receiving a packet or (2) write ETH\\_DMACRXDTPR any other address so the current descriptor pointer never increments to it and receive continues until the current pointer increments to a non-ready descriptor"
          ]
        },
        {
          "title": "DMA Networking — Matt Keeter Blog",
          "url": "https://www.mattkeeter.com/blog/2023-10-31-dma/",
          "excerpts": [
            "Oct 31, 2023 — This bit marks whether the descriptor is currently owned by DMA hardware or user code. When it is set, the descriptor is owned by the DMA ...",
            "```",
            "```"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "use smoltcp::phy::{self, DeviceCapabilities, Device, Medium};",
            "struct StmPhy {",
            "    rx_buffer: [u8; 1536],",
            "    tx_buffer: [0; 1536],",
            "impl<'a> StmPhy {",
            "    fn new() -> StmPhy {",
            "        StmPhy {",
            "            rx_buffer: [0; 1536],",
            "            tx_buffer: [0; 1536],",
            "        }",
            "impl phy::Device for StmPhy {",
            "    type RxToken<'a> = StmPhyRxToken<'a> where Self: 'a;",
            "    type TxToken<'a> = StmPhyTxToken<'a> where Self: 'a;",
            "    fn receive(&mut self, _timestamp: Instant) -> Option<(Self::RxToken<'_>, Self::TxToken<'_>)> {",
            "        Some((StmPhyRxToken(&mut self.rx_buffer[..]),",
            "              StmPhyTxToken(&mut self.tx_buffer[..])))",
            "    fn transmit(&mut self, _timestamp: Instant) -> Option<Self::TxToken<'_>> {",
            "        Some(StmPhyTxToken(&mut self.tx_buffer[..]))",
            "    fn capabilities(&self) -> DeviceCapabilities {",
            "        let mut caps = DeviceCapabilities::default();",
            "        caps.max_transmission_unit = 1536;",
            "        caps.max_burst_size = Some(1);",
            "        caps.medium = Medium::Ethernet;",
            "        caps",
            "struct StmPhyRxToken<'a>(&'a mut [u8]);",
            "impl<'a> phy::RxToken for StmPhyRxToken<'a> {",
            "    fn consume<R, F>(self, f: F) -> R",
            "        where F: FnOnce(& [u8]) -> R",
            "        // TODO: receive packet into buffer",
            "        let result = f(&self.0);",
            "        println!\n(\"rx called\")",
            "struct StmPhyTxToken<'a>(&'a mut [u8]);",
            "impl<'a> phy::TxToken for StmPhyTxToken<'a> {",
            "    fn consume<R, F>(self, len: usize, f: F) -> R",
            "        where F: FnOnce(&mut [u8]) -> R",
            "    {",
            "    {",
            "        let result = f(&mut self.0[..len]);",
            "        println! (\"tx called {}\", len);",
            "        // TODO: send packet out",
            "        result",
            "        result",
            "    }",
            "    }",
            "    }",
            "    }",
            "    }",
            "    }",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "    }",
            "```",
            "```",
            "extern crate panic_halt;",
            "fn main() -> ! {",
            "}",
            "}",
            "}",
            "#!\n[no_std",
            "#! [no_main"
          ]
        },
        {
          "title": "smoltcp - Rust",
          "url": "https://docs.rs/smoltcp/",
          "excerpts": [
            "The goal of smoltcp is not just to provide a simple interface for writing applications but also to be a toolbox of networking primitives."
          ]
        },
        {
          "title": "cotton_w5500 - Rust",
          "url": "https://docs.rs/cotton-w5500",
          "excerpts": [
            "A Wiznet W5500 driver for smoltcp. This crate includes an implementation of smoltcp::phy::Device which uses the W5500 crate to target smoltcp to the Wiznet ...",
            "The W5500 is operated in “MACRAW” (raw packet) mode, which allows more flexible networking (via smoltcp) than is possible using the W5500's onboard TCP/UDP mode "
          ]
        },
        {
          "title": "embassy-net-enc28j60",
          "url": "https://lib.rs/crates/embassy-net-enc28j60",
          "excerpts": [
            "embassy-net integration for the Microchip ENC28J60 Ethernet chip. Based on @japaric's enc28j60 crate. Interoperability. This crate can run on any executor."
          ]
        },
        {
          "title": "etherparse - Rust",
          "url": "https://docs.rs/etherparse",
          "excerpts": [
            "Etherparse is intended to provide the basic network parsing functions that allow for easy analysis, transformation or generation of recorded network data. Some ..."
          ]
        },
        {
          "title": "zero-packet - Rust Package Registry - Crates.io",
          "url": "https://crates.io/crates/zero-packet",
          "excerpts": [
            "Super simple library to efficiently build and parse network packets in-place with zero overhead. No async, no allocations, no dependencies, no ..."
          ]
        },
        {
          "title": "pdh11/cotton: Low-level networking functionality in Rust",
          "url": "https://github.com/pdh11/cotton",
          "excerpts": [
            "cotton-w5500 · Crates.io docs.rs : smoltcp driver for the Wiznet W5500 Ethernet controller in MACRAW mode, including interrupt-driven mode. These crates are ..."
          ]
        },
        {
          "title": "Embedded Rust device crates for STM32 microcontrollers",
          "url": "https://github.com/stm32-rs/stm32-rs",
          "excerpts": [
            "This repository provides Rust device support crates for all STM32 microcontrollers, providing a safe API to that device's peripherals using svd2rust."
          ]
        },
        {
          "title": "README.md - rust-embedded/critical-section - GitHub",
          "url": "https://github.com/rust-embedded/critical-section/blob/main/README.md",
          "excerpts": [
            "The nrf-softdevice crate provides a critical section that's compatible with the nRF soft-device firmware via its critical-section-impl feature. For example ..."
          ]
        },
        {
          "title": "bt_hci - Rust - Docs.rs",
          "url": "https://docs.rs/bt-hci",
          "excerpts": [
            "Rust types for the Bluetooth HCI (Host Controller Interface) specification, and traits for implementing the Controller part of the interface."
          ]
        },
        {
          "title": "nrf-softdevice - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/nrf-softdevice/dependencies",
          "excerpts": [
            "An implementation of futures and streams featuring zero allocations, composability, and iterator-like interfaces."
          ]
        },
        {
          "title": "STM32H7 ETHERNET - please help to review RX descri...",
          "url": "https://community.st.com/t5/stm32-mcus-embedded-software/stm32h7-ethernet-please-help-to-review-rx-descriptor-init-fix/td-p/261149",
          "excerpts": [
            "Nov 20, 2023 — Dear Ethernet experts, ST prepares a fix for RX descriptors initialization issue reported here previously. Please can you take a look?"
          ]
        },
        {
          "title": "List of all items in this crate - Docs.rs",
          "url": "https://docs.rs/zero-packet/latest/zero_packet/all.html",
          "excerpts": [
            "List of all items ; Structs. datalink::arp::ArpReader · datalink::arp::ArpWriter · datalink::ethernet::EthernetReader ; Enums. misc::EtherType · misc::Icmpv4Type ..."
          ]
        },
        {
          "title": "dlt_parse — Rust parser // Lib.rs",
          "url": "https://lib.rs/crates/dlt_parse",
          "excerpts": [
            "If you want to use the crate in no_std mode you will have to disable the default features: [dependencies] dlt_parse = { version = \"0.10.0\", default-features ..."
          ]
        },
        {
          "title": "Please help with Wiznet W5500 Ethernet module #1411",
          "url": "https://github.com/esp-rs/esp-hal/discussions/1411",
          "excerpts": [
            "I want to build a EspNow-Ethernet-Gateway with an ESP32 and a Wiznet W5500 Ethernet module, which should replace my Arduino EnigmaIOT setup i'm currently ..."
          ]
        },
        {
          "title": "Zerocopy Cargo Features",
          "url": "https://docs.rs/zerocopy/",
          "excerpts": [
            "**`alloc`** By default, `zerocopy` is `no_std` . When the `alloc` feature is enabled,",
            "the `alloc` crate is added as a dependency, and some allocation-related\n  functionality is adde",
            "**`std`** By default, `zerocopy` is `no_std` . When the `std` feature is enabled, the `std` crate is added as a dependency (ie, `no_std` is disabled), and"
          ]
        },
        {
          "title": "trouble_host - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/trouble-host",
          "excerpts": [
            "TrouBLE is a Bluetooth Low Energy (BLE) Host implementation for embedded devices written in Rust, with a future goal of qualification."
          ]
        },
        {
          "title": "trouble_host - Rust - Docs.rs",
          "url": "https://docs.rs/trouble-host",
          "excerpts": [
            "TrouBLE is a Bluetooth Low Energy (BLE) Host implementation for embedded devices written in Rust, with a future goal of qualification."
          ]
        },
        {
          "title": "TrouBLE - Embassy-RS Trouble repository",
          "url": "https://github.com/embassy-rs/trouble",
          "excerpts": [
            "TrouBLE is a Bluetooth Low Energy (BLE) Host implementation for embedded devices written in Rust, with a future goal of qualification.",
            "A BLE Host is one side of the Host Controller Interface (HCI). The BLE specification defines the software of a BLE implementation in terms of a `controller` (lower layer) and a `host` (upper layer). These communicate via a standardized protocol, that may run over different transports such as as UART, USB or a custom in-memory IPC implementation.",
            "TrouBLE can use any controller that implements the traits from `bt-hci` . At present, that includes:\n\n* [nRF Softdevice Controller](https://github.com/alexmoon/nrf-sdc) . * [UART HCI](https://docs.zephyrproject.org/latest/samples/bluetooth/hci_uart/README.html) . * [Raspberry Pi Pico W](https://github.com/embassy-rs/embassy/tree/main/cyw43) . * [Apache NimBLE Controller](https://github.com/benbrittain/apache-nimble-sys) . * [ESP32](https://github.com/esp-rs/esp-hal) . * [Linux HCI Sockets](/embassy-rs/trouble/blob/main/examples/linux",
            "Current status\n\n[]()\n\nThe implementation has the following functionality working:\n\n* Peripheral role - advertise as a peripheral and accept connections. * Central role - scan for devices and establish connec"
          ]
        },
        {
          "title": "multiboot2 header to properly go into \"EFI amd64 machine state with ...",
          "url": "https://stackoverflow.com/questions/67986406/multiboot2-header-to-properly-go-into-efi-amd64-machine-state-with-boot-service",
          "excerpts": [
            "I want to boot into EFI amd64 machine state with boot services enabled, which is defined in section 3.5 multiboot2 spec [1], but this causes problems."
          ]
        },
        {
          "title": "Booting from Grub2 to x86 long mode (64-bit mode)",
          "url": "http://ringzeroandlower.com/2017/08/08/x86-64-kernel-boot.html",
          "excerpts": [
            "In this post, I'm going to walk through the process of booting a kernel from grub and getting it up into 64 bit C code."
          ]
        },
        {
          "title": "GRUB - OSDev Wiki",
          "url": "https://wiki.osdev.org/GRUB",
          "excerpts": [
            "GRUB is the GNU project's bootloader. The current version 2 series have a more complete feature set than GRUB 0.97 (commonly referred to as \"GRUB Legacy\")."
          ]
        },
        {
          "title": "polished_gdt - Rust - Docs.rs",
          "url": "https://docs.rs/polished_gdt/latest/polished_gdt/",
          "excerpts": [
            "This module sets up and loads the Global Descriptor Table (GDT) for x86_64 systems. §What is the GDT? The Global Descriptor Table (GDT) is a fundamental data ..."
          ]
        },
        {
          "title": "Handling Exceptions | Writing an OS in Rust (First Edition)",
          "url": "https://os.phil-opp.com/handling-exceptions/",
          "excerpts": [
            "Mar 26, 2017 — The x86-interrupt calling convention and the Idt type made the exception handling process relatively straightforward and painless. If this was ...",
            "The x86-interrupt calling convention handles all that complexity. However, it doesn't know which handler function is used for which exception, ..."
          ]
        },
        {
          "title": "Paging on Intel x86-64",
          "url": "https://www.isec.tugraz.at/teaching/materials/os/tutorials/paging-on-intel-x86-64/",
          "excerpts": [
            "In these paging tables (. PML4. PML4 ,. PDPT. PDPT ,. PD. PD ,. PT. PT ), every entry has 8 bytes and each table has a size of 4kB. This means each table has ..."
          ]
        },
        {
          "title": "Hardware Interrupts | Writing an OS in Rust",
          "url": "https://os.phil-opp.com/hardware-interrupts/",
          "excerpts": [
            "The 8259 PIC\n\nThe [Intel 8259](https://en.wikipedia.org/wiki/Intel_8259) is a programmable interrupt controller (PIC) introduced in 1976. It has long been replaced by the newer [APIC](https://en.wikipedia.org/wiki/Intel_APIC_Architecture) , but its interface is still supported on current systems for backwards compatibility reasons.",
            "the timer uses line 0 of the primary PIC. This means that it arrives at the CPU as interrupt 32 (0 + offset 32).",
            "The 8259 PIC is significantly easier to set up than the APIC, so we will use it to introduce ourselves to interrupts before we switch to the APIC in a later post.",
            "The 8259 PIC is significantly easier to set up than the APIC, so we will use it to introduce ourselves to interrupts before we switch to the APIC in a later post.",
            "on handlers, because the CPU reacts identically to exceptions and external interrupts (the only difference is that some exceptions push an error code)."
          ]
        },
        {
          "title": "8259 PIC",
          "url": "http://wiki.osdev.org/8259_PIC",
          "excerpts": [
            "Disabling. If you are going to use the processor local APIC and the IOAPIC, you must first disable the PIC. This is done by masking every single interrupt ..."
          ]
        },
        {
          "title": "IOAPIC - OSDev Wiki",
          "url": "https://wiki.osdev.org/IOAPIC",
          "excerpts": [
            "The Intel I/O Advanced Programmable Interrupt Controller is used to distribute external interrupts in a more advanced manner than that of the standard 8259 PIC."
          ]
        },
        {
          "title": "APIC - OSDev Wiki",
          "url": "http://wiki.osdev.org/APIC",
          "excerpts": [
            "The APIC is used for sophisticated interrupt redirection, and for sending interrupts between processors. These things weren't possible using the older PIC ..."
          ]
        },
        {
          "title": "APIC Timer",
          "url": "https://wiki.osdev.org/APIC_Timer",
          "excerpts": [
            "The great benefit of the Local APIC timer is that it is hardwired to each CPU core, unlike the Programmable Interval Timer which is a separate circuit."
          ]
        },
        {
          "title": "[PDF] Building a Firmware for Virtual Machines using Rust - KVM Forum",
          "url": "https://kvm-forum.qemu.org/2019/KVM-Forum-Building-a-Firmware-for-Virtual-Machines.pdf",
          "excerpts": [
            "• Parses kernel command line for MMIO block device details. • Reads E820 table from zero page. • Probes block device and searches for filesystem. Basic setup."
          ]
        },
        {
          "title": "x86 calling conventions",
          "url": "https://en.wikipedia.org/wiki/X86_calling_conventions",
          "excerpts": [
            "This article describes the calling conventions used when programming x86 architecture microprocessors. Calling conventions describe the interface of called ..."
          ]
        },
        {
          "title": "Writing an OS in Rust: Advanced Paging",
          "url": "https://news.ycombinator.com/item?id=19017108",
          "excerpts": [
            "For GRUB, when loading a `x86_64` ELF kernel, it loads the kernel's segments at whatever physical address they are linked at (ELF records ...",
            "Jan 28, 2019 — ... higher-half and then remove the identity mappings. And they can do this without having to do any allocation because they can simply make the ..."
          ]
        },
        {
          "title": "Stuck on higher half kernel design : r/osdev - Reddit",
          "url": "https://www.reddit.com/r/osdev/comments/wsbuit/stuck_on_higher_half_kernel_design/",
          "excerpts": [
            "You can do higher half kernel PLUS identity mapping of the region of physical memory which holds important data. The 64-bit space is huge ..."
          ]
        },
        {
          "title": "Hypervisor Part 200: A Quick Overview of x86_64 Memory ...",
          "url": "https://medium.com/@bgallois/hypervisor-part-200-a-quick-overview-of-x86-64-memory-management-98267ea1bb97",
          "excerpts": [
            "Modern x86_64 systems use a 4-level paging system (PML4, PDPT, PD, PT) to translate virtual addresses into physical ones. This system reduces ..."
          ]
        },
        {
          "title": "[SOLVED] Calling 64-bit higher half kernel using uefi bootloader",
          "url": "https://forum.osdev.org/viewtopic.php?t=57371",
          "excerpts": [
            "Based on the highest available address in the map it then sets up paging with identity mapping up to that address. For my second approach I ...",
            "Aug 9, 2024 — I am new to the OSDev world and currently writing a 64-bit OS in rust. I split the project into a bootloader which uses the uefi-rs crate ..."
          ]
        },
        {
          "title": "Converting EFI memory Map to E820 map - linux - Stack Overflow",
          "url": "https://stackoverflow.com/questions/17591351/converting-efi-memory-map-to-e820-map",
          "excerpts": [
            "I suspect what the Linux kernel does is to use the E820 format as its internal representation of memory on the x86 architecture. However, when ..."
          ]
        },
        {
          "title": "Use cases for `no_std` on tier 1 targets - libs",
          "url": "https://internals.rust-lang.org/t/use-cases-for-no-std-on-tier-1-targets/20592",
          "excerpts": [
            "Rust-for-Linux uses no_std kernel targets (like *-unknown-none ), and they're actually moving away from their alloc fork in the near future too ..."
          ]
        },
        {
          "title": "Multiboot2 Specification (GRUB/EFI/UEFI boot concepts)",
          "url": "https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html",
          "excerpts": [
            "The Multiboot2 header must be contained completely within the first 32768 bytes of the OS image, and must be 64-bit aligned.",
            "is    value indicates to the operating system that it was loaded by a    Multiboot2-compliant boot loader (e.g. as opposed to another type of    boot loader that the operating system can also be loaded from).\n‘ EBX ’\n    Must contain the ",
            "When the boot loader invokes the operating system, the machine\nmust have the following state:",
            "    The OS image must create its own stack as soon as it needs one.",
            "  Even though the segment registers are set up as described above, the    ‘ GDTR ’ may be invalid, so the OS image must not load any segment    registers (even just reloading the same values!) until it sets up its  ",
            "    The OS image must leave interrupts disabled until it sets up its own `IDT` . On EFI system boot services must be terminated.",
            "EFI i386 machine state with boot services enabled"
          ]
        },
        {
          "title": "GitHub Gist: x86_64 multiboot2 long mode bootstrap (wireboy5/b1872cfe3164071e9b48afcaecbb3d5a)",
          "url": "https://gist.github.com/wireboy5/b1872cfe3164071e9b48afcaecbb3d5a",
          "excerpts": [
            "A basic multiboot2 compatible longmode bootstrap that loads into a higher half kernel. ; It identity maps the lower 1GB of memory.",
            "x86_64 multiboot2 long mode bootstrap."
          ]
        },
        {
          "title": "Double Faults and GDT/IDT in x86_64 - Writing an OS in Rust",
          "url": "https://os.phil-opp.com/double-fault-exceptions/",
          "excerpts": [
            "\nLet’s create a static `GDT` that includes a segment for our `TSS` static:",
            "The Interrupt Stack Table (IST) is part of an old legacy structure called *[Task State Segment](https://en.wikipedia.org/wiki/Task_state_segment)* (TSS). The TSS used to hold various pieces of information (e.g., processor register state) about a task in 32-bit mode and was, for example, used for [hardware context switching](https://wiki.osdev.org/Context_Switching). However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS has changed completely. On x86\\_64, the TSS no longer holds any task-specific information at all. Instead, it holds two stack tables (the IST is one of them)",
            "The Global Descriptor Table (GDT) is a relic that was used for [memory segmentation](https://en.wikipedia.org/wiki/X86_memory_segmentation) before paging became the de facto standard. However, it is still needed in 64-bit mode for various things, such as kernel/user mode configuration or TSS loading."
          ]
        },
        {
          "title": "Paging - Introduction to Paging (Philipp Oppermann)",
          "url": "https://os.phil-opp.com/paging-introduction/",
          "excerpts": [
            "The x86\\_64 architecture uses a 4-level page table and a page size of 4 KiB.",
            "A 4-level page table makes the translation of virtual addresses expensive because each translation requires four memory accesses. To improve performance, the x86\\_64 architecture caches the last few translations in the so-called *translation lookaside buffer* (TLB).",
            "The page table index for each level is derived directly from the virtual address:"
          ]
        },
        {
          "title": "7. Services — Boot Services — UEFI Specification 2.9A documentation",
          "url": "https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html",
          "excerpts": [
            "In principle, the ExitBootServices() call is intended for use by the operating system to indicate that its loader is ready to assume control of the platform and ..."
          ]
        },
        {
          "title": "Multiboot2 Specification version 2.0: Boot information format",
          "url": "https://www.gnu.org/software/grub/manual/multiboot2/html_node/Boot-information-format.html",
          "excerpts": [
            "This field is 64-bit wide but bootloader should set it under 4GiB if possible for compatibility with payloads which aren't aware of PAE or amd64. The field ..."
          ]
        },
        {
          "title": "multiboot2 - Rust",
          "url": "https://docs.rs/multiboot2",
          "excerpts": [
            "Tag that contains the pointer to the boot loader's UEFI image handle (64-bit). The type of a memory range. Flags describing the capabilities of a memory range.",
            "MemoryArea](struct.MemoryArea.html \"struct multiboot2::MemoryArea\")\n:   A descriptor for an available or taken area of physical memory"
          ]
        },
        {
          "title": "UEFI and Mulitboot 2 support. : r/osdev",
          "url": "https://www.reddit.com/r/osdev/comments/173y7w8/uefi_and_mulitboot_2_support/",
          "excerpts": [
            "I want to add support to UEFI and also Multiboot 2 to chain load. Can I implement like if UEFI is present use UEFI else use BIOS or if not possible do i have ..."
          ]
        },
        {
          "title": "Entering Long Mode | Writing an OS in Rust (First Edition)",
          "url": "https://os.phil-opp.com/entering-longmode/",
          "excerpts": [
            "The goal is to extend it and call 64-bit Rust code. But the CPU is currently in protected mode and allows only 32-bit instructions and up to 4GiB memory."
          ]
        },
        {
          "title": "InterruptDescriptorTable in x64::idt - Rust",
          "url": "https://docs.rs/x64/latest/x64/idt/struct.InterruptDescriptorTable.html",
          "excerpts": [
            "According to the x86_64 crate,. System logic signals an external interrupt request to the processor. The signaling mechanism and the method of communicating the ..."
          ]
        },
        {
          "title": "Tracking issue for the x86-interrupt calling convention #40180 - GitHub",
          "url": "https://github.com/rust-lang/rust/issues/40180",
          "excerpts": [
            "The x86-interrupt calling convention can be used for defining interrupt handlers on 32-bit and 64-bit x86 targets. The compiler then uses iret ..."
          ]
        },
        {
          "title": "[Pre-RFC] Interrupt Calling Conventions - language design",
          "url": "https://internals.rust-lang.org/t/pre-rfc-interrupt-calling-conventions/16182",
          "excerpts": [
            "Rust already supports three different interrupt calling conventions as experimental features: msp430-interrupt , x86-interrupt , and avr- ...",
            "This RFC proposes to add support for interrupt calling conventions to the Rust language. This makes it possible to define interrupt handlers directly as Rust ..."
          ]
        },
        {
          "title": "Double Faults · phil-opp blog_os · Discussion #1005",
          "url": "https://github.com/phil-opp/blog_os/discussions/1005",
          "excerpts": [
            "If a page fault occurs and the page fault handler is swapped out, a double fault occurs and the double fault handler is invoked. ... blog_os/debug/deps/bootimage- ..."
          ]
        },
        {
          "title": "Is It Possible to Switch from a GRUB-Loaded 32-Bit ...",
          "url": "https://www.reddit.com/r/osdev/comments/1g6ke6q/is_it_possible_to_switch_from_a_grubloaded_32bit/",
          "excerpts": [
            "All you would need in theory is to switch your CPU to long mode and switch to a different cross compiler for the 64bit part. Upvote"
          ]
        },
        {
          "title": "Where to go after Exiting UEFI Boot Services. : r/osdev - Reddit",
          "url": "https://www.reddit.com/r/osdev/comments/1163xmx/where_to_go_after_exiting_uefi_boot_services/",
          "excerpts": [
            "Am I already in Long mode after leaving UEFI? Yes, since you're using x86-64 OVMF. Can I access the keyboard like I am using the UEFI frame ..."
          ]
        },
        {
          "title": "More Interrupt ABIs needed (not just `extern \"x86-interrupt\"`)",
          "url": "https://internals.rust-lang.org/t/more-interrupt-abis-needed-not-just-extern-x86-interrupt/20839",
          "excerpts": [
            "One alternative proposed in the RFC is a \"preserve-all\" calling convention that preserves the contents of all CPU (and FPU, SSE, etc) registers."
          ]
        },
        {
          "title": "x86 Kernel Development & Relocatable Binaries - phips blog",
          "url": "https://phip1611.de/blog/x86-kernel-development-relocatable-binaries/",
          "excerpts": [
            "This post is roughly a summary of the obscure knowledge I learned about toolchains and relocatable code in the last couple of years."
          ]
        },
        {
          "title": "When to do or not do INVLPG, MOV to CR3 to minimize TLB flushing",
          "url": "https://stackoverflow.com/questions/28384234/when-to-do-or-not-do-invlpg-mov-to-cr3-to-minimize-tlb-flushing",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "x86-64 PML4 setup - OSDev.org",
          "url": "https://forum.osdev.org/viewtopic.php?p=351515",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "Flushing TLB in an SMP environment - OSDev.org",
          "url": "https://forum.osdev.org/viewtopic.php?t=23569",
          "excerpts": [
            "Missing: Rust no_std"
          ]
        },
        {
          "title": "Multiboot",
          "url": "https://wiki.osdev.org/Multiboot",
          "excerpts": [
            "The Multiboot specification is an open standard that provides kernels with a uniform way to be booted by Multiboot-compliant bootloaders. It is not backwards compatible, uses different structures and different magic numbers. Multiboot 2 compliant kernels used the magic number 0xE85250D6, and Multiboot-compliant bootloaders report themselves with magic number 0x36D76289. On x86, this magic number is stored in EAX just before the kernel is invoked. You can c",
            "The first part of the Multiboot2 header is a struct aligned on an 8-byte boundary containing four \"magic\" 32-bit integers. These fields contain the magic number 0xE85250D6, flags describing the architecture, the total length of the header including the subsequent tags, and the checksum of the magic fields respectively.",
            "The tags are used as hints by the bootloader to provide information about the kernel image and to request that it provide additional information in the boot information struct.",
            "GNU GRUB is compatible with the Multiboot2 specification as of version 2.02. You can boot a multiboot v2 kernel with the following command in your menuentry:",
            "multiboot2 /boot/kernel-file"
          ]
        },
        {
          "title": "Interrupt Descriptor Table - OSDev Wiki",
          "url": "https://wiki.osdev.org/Interrupt_Descriptor_Table",
          "excerpts": [
            "The IDT entries are called gates. It can contain Interrupt Gates, Task Gates and Trap Gates. Before you implement the IDT, make sure you have a working GDT.",
            "On 64-bit processors, the entries in the **IDT** are 16 bytes long and form a table like t",
            "There are 256 interrupt vectors (0..255), so the **IDT** should have 256 entries, each entry corresponding to a specific interrupt vec",
            "Gate Types"
          ]
        },
        {
          "title": "x86_64 Crate Documentation",
          "url": "https://docs.rs/x86_64/latest/x86_64/instructions/index.html",
          "excerpts": [
            "Provides functions to read and write segment registers. tables: Functions to load GDT, IDT, and TSS structures. tlb: Functions to flush the translation ... [x86\\_64-unknown-linux-gnu](/crate/x86_64/latest/target-redirect/x86_64-unknown-linux-gnu/x86_64/instructions/index.html)"
          ]
        },
        {
          "title": "RISC-V SBI and the full boot process",
          "url": "https://popovicu.com/posts/risc-v-sbi-and-full-boot-process/",
          "excerpts": [
            "Sep 9, 2023 — Detailed explanation on how RISC-V boot process works and what role SBI has in the RISC-V software stack. Concrete example with OpenSBI."
          ]
        },
        {
          "title": "OpenSBI Deep Dive",
          "url": "https://riscv.org/wp-content/uploads/2024/12/13.30-RISCV_OpenSBI_Deep_Dive_v5.pdf",
          "excerpts": [
            "Jun 12, 2019 — – Allows overriding device tree blob (i.e. DTB). – Very similar to BBL hence fits nicely in existing boot-flow of SiFive Unleashed board."
          ]
        },
        {
          "title": "edk2-platforms/Platform/RISC-V/PlatformPkg/Readme.md ...",
          "url": "https://github.com/tianocore/edk2-platforms/blob/master/Platform/RISC-V/PlatformPkg/Readme.md",
          "excerpts": [
            "As mentioned earlier, RiscVOpensbiLib provides the RISC-V SBI implementation and initialize the OpenSBI boot flow. SEC module is also linked with below ..."
          ]
        },
        {
          "title": "Selecting between TTBR0 and TTBR1, Short-descriptor ...",
          "url": "https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/Virtual-Memory-System-Architecture--VMSA-/Short-descriptor-translation-table-format/Selecting-between-TTBR0-and-TTBR1--Short-descriptor-translation-table-format?lang=en",
          "excerpts": [
            "Table 12.1 shows how the value of N determines the lowest address translated using TTBR1, and the size of the first-level translation table addressed by TTBR0."
          ]
        },
        {
          "title": "Double Faults | Writing an OS in Rust (First Edition)",
          "url": "https://os.phil-opp.com/double-faults/",
          "excerpts": [
            "Jan 2, 2017 — A double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered."
          ]
        },
        {
          "title": "Allocating Frames | Writing an OS in Rust (First Edition)",
          "url": "https://os.phil-opp.com/allocating-frames/",
          "excerpts": [
            "Nov 15, 2015 — In this post we create an allocator that provides free physical frames for a future paging module. To get the required information about available and used ..."
          ]
        },
        {
          "title": "Rust-OS Kernel buddy allocator - Part 1: Creating a simple ...",
          "url": "https://nfil.dev/kernel/rust/coding/rust-kernel-allocator/",
          "excerpts": [
            "Oct 24, 2019 — Our frame allocator is simply an iterator that iterates over a static struct (the static BootInformation given to us by the bootloader). We can' ..."
          ]
        },
        {
          "title": "Remapping and masking all IRQs instead of just disabling PIC",
          "url": "https://forum.osdev.org/viewtopic.php?t=29117",
          "excerpts": [
            "Mar 9, 2015 — You should first remap the pick and then mask all interrupts, the code on the PIC page, ie sending the two bytes 0xFF to I/O ports 0xA1 and 0x21 ..."
          ]
        },
        {
          "title": "Does RISC-V suffer from ARM-like fragmentation where each device ...",
          "url": "https://www.reddit.com/r/RISCV/comments/poil28/does_riscv_suffer_from_armlike_fragmentation/",
          "excerpts": [
            "Missing: handoff paging"
          ]
        },
        {
          "title": "RISC-V vs ARM: A Comprehensive Comparison of Processor ...",
          "url": "https://www.wevolver.com/article/risc-v-vs-arm",
          "excerpts": [
            "This comprehensive comparison explores the background, architectural differences, performance, power efficiency, ecosystem, licensing models, and future ..."
          ]
        },
        {
          "title": "CPU_ON on QEMU ARMv8A using PSCI from EL2/EL3",
          "url": "https://stackoverflow.com/questions/75210724/cpu-on-on-qemu-armv8a-using-psci-from-el2-el3",
          "excerpts": [
            "When the guest is not booting at EL3, the QEMU virt machine implements its own internal PSCI emulation. This is described in the DTB file ..."
          ]
        },
        {
          "title": "Porting FreeDOS to ARM and RISC-V architectures - Facebook",
          "url": "https://www.facebook.com/groups/freedosproject/posts/10161446236412887/",
          "excerpts": [
            "It could serve as a simple embedded OS for ARM or RISC-V-based devices when a larger OS like Linux or Unix is not necessary."
          ]
        },
        {
          "title": "x2apic - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/x2apic/0.1.2/dependencies",
          "excerpts": [
            "A library to parse the x86 CPUID instruction, written in rust with no external dependencies. The implementation closely resembles the Intel CPUID manual ..."
          ]
        },
        {
          "title": "Frame Allocators and the multiboot2 Crate in Rust OS ...",
          "url": "https://www.linkedin.com/pulse/frame-allocators-multiboot2-crate-rust-os-development-eduardo-lemos-us2bf",
          "excerpts": [
            "Implementing a Simple Frame Allocator. A naive frame allocator can use a bitmap or linked list to track available frames. Here's a basic ..."
          ]
        },
        {
          "title": "Parsing multiboot memory map. - OSDev.org",
          "url": "https://forum.osdev.org/viewtopic.php?t=42531",
          "excerpts": [
            "Apr 6, 2021 — In the case of Grub, the values for type match the ones from the E820 memory map. This is likely true here is well. Unfortunately I cannot seem ..."
          ]
        },
        {
          "title": "Booting AArch64 Linux",
          "url": "https://www.kernel.org/doc/html/v6.1/arm64/booting.html",
          "excerpts": [
            "The boot loader is expected to find and initialise all RAM that the\nkernel will use for volatile data storage in the system.",
            "The device tree blob (dtb) must be placed on an 8-byte boundary and must not exceed 2 megabytes in size. Since the dtb will be mapped cacheable",
            "Booting AArch64 Linux",
            "Booting AArch64 Linux",
            "Booting AArch64 Linux",
            "Booting AArch64 Linux",
            "1. Setup and initialise RAM",
            "2. Setup the device tree",
            "3. Decompress the kernel image",
            "4. Call the kernel image"
          ]
        },
        {
          "title": "ARM Paging - OSDev Wiki",
          "url": "https://wiki.osdev.org/ARM_Paging",
          "excerpts": [
            "ARMv7-A supports two different paging modes. These are the short descriptor format and long descriptor format described in B3.5 and B3.6 respectively of the ARMv7 reference manual.",
            "The long descriptor format is an ARM equivalent of the X86 [PAE](/PAE \"PAE\") system.",
            "ARM v8-A introduces a 64 bit architecture, AArch64",
            "The paging mode is controlled with the TTBCR (Translation Table Base Control Register)."
          ]
        },
        {
          "title": "polished_interrupts - Interrupt Handling Library",
          "url": "https://docs.rs/polished_interrupts",
          "excerpts": [
            "This crate provides low-level interrupt management for x86\\_64 systems, including the setup of the Interrupt Descriptor Table (IDT), CPU exception handlers, and hardware interrupt handlers. It is designed for use in OS kernels or bootloaders running in a `no_std` environment",
            "Interrupts are signals that temporarily halt the normal execution flow of the CPU to handle urgent events, such as hardware requests (keyboard, timer, etc.) or software exceptions (division by zero, page faults, etc.). When an interrupt occurs, the CPU saves its current state and jumps to a handler function specified in the Interrupt Descriptor Table (IDT). After the handler completes, the CPU resumes execution where it left off."
          ]
        },
        {
          "title": "Unsafe Rust - The Rust Programming Language - Rust Documentation",
          "url": "https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html",
          "excerpts": [
            "Wrapping unsafe code in a safe abstraction prevents uses of unsafe from leaking out into all the places that you or your users might want to use the functionality implemented with unsafe code , because using a safe abstraction is safe."
          ]
        },
        {
          "title": "Introduction - Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/",
          "excerpts": [
            "Rust's Unsafe Code Guidelines Reference. This document is a past effort by the UCG WG to provide a \"guide\" for writing unsafe code that \"recommends\" what ..."
          ]
        },
        {
          "title": "Simpler mental model for unsafe",
          "url": "https://internals.rust-lang.org/t/simpler-mental-model-for-unsafe/20363",
          "excerpts": [
            "The module boundary prevents external code from using the mistakenly safe fields without a safety argument, which the compiler cannot ..."
          ]
        },
        {
          "title": "Typestate - CS 242",
          "url": "https://stanford-cs242.github.io/f19/lectures/08-2-typestate.html",
          "excerpts": [
            "Typestate in Rust  The state machine is embedded inside a mod block so Rust treats the main function and A/B/C types as being in separate modules with distinct privacy scopes . Each state is a struct with no fields, and each struct has a set of methods implemented for it."
          ]
        },
        {
          "title": "Write-up on using typestates in Rust",
          "url": "https://users.rust-lang.org/t/write-up-on-using-typestates-in-rust/28997",
          "excerpts": [
            "I've found typestates (in the informal sense) to be indispensable for designing robust and easy-to-use APIs in Rust.",
            "If you want to see more complex examples of typestate,you can look at the readme for type_level as well as the type_level_examples crate. As ..."
          ]
        },
        {
          "title": "Verification results - The Kani Rust Verifier",
          "url": "https://model-checking.github.io/kani/verification-results.html",
          "excerpts": [
            "Kani determines the verification result for the harness based on the result (ie, <status> ) of each individual check (also known as \"properties\")."
          ]
        },
        {
          "title": "viperproject/prusti-assistant: VS Code extension to verify ...",
          "url": "https://github.com/viperproject/prusti-assistant",
          "excerpts": [
            "This Visual Studio Code extension provides interactive IDE features for verifying Rust programs with the Prusti verifier."
          ]
        },
        {
          "title": "Item 16: Avoid writing unsafe code - Effective Rust",
          "url": "https://effective-rust.com/unsafe.html",
          "excerpts": [
            "These features may still need a little caution to be used correctly, but the unsafe code has been encapsulated in a way that removes whole classes of problems."
          ]
        },
        {
          "title": "Setup - Prusti user guide",
          "url": "https://viperproject.github.io/prusti-dev/user-guide/tour/setup.html",
          "excerpts": [
            "Adding this crate works the same as for the prusti-contracts crate: cargo add prusti-std. or: [dependencies] prusti-std = \"0.1.6\". You do not need to import ..."
          ]
        },
        {
          "title": "Stubbing - The Kani Rust Verifier",
          "url": "https://model-checking.github.io/kani/reference/experimental/stubbing.html",
          "excerpts": [
            "Stubbing (or mocking) is an unstable feature which allows users to specify that certain items should be replaced with stubs (mocks) of those items during ..."
          ]
        },
        {
          "title": "The Rustonomicon: What Unsafe Rust Can Do",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "The only things that are different in Unsafe Rust are that you can:\n\n* Dereference raw pointers\n* Call `unsafe` functions (including C functions, compiler intrinsics, and the raw allocator)\n* Implement `unsafe` traits\n* Access or modify mutable statics\n* Access fields of `union` s\n\nThat's it. The reason these operations are relegated to Unsafe is that misusing\nany of these things will cause the ever dreaded Undefined Behavior. Invoking\nUndefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program. You definitely _should not_ invoke Undefined Behavior. Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)\nFor a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) . \"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation. A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers. That's it. That's all the causes of Undefined Behavior baked into Rust. Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.\nSome additional constraints may also derive from compiler\nintrinsics that make special assumptions about how code can be optimized. For instance,\nVec and Box make use of intrinsics that require their pointers to be non-null at all times. Rust is otherwise quite permissive with respect to other dubious operations. Rust considers it \"safe\" to:\n\n* Deadlock\n* Have a [race condition](races.html)\n* Leak memory\n* Overflow integers (with the built-in operators such as `+` etc.) * Abort the program\n* Delete the production database\n\nFor more detailed information, you may refer to [the reference](../reference/behavior-not-considered-unsafe.html) . However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent."
          ]
        },
        {
          "title": "Meet Safe and Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html",
          "excerpts": [
            "Unsafe Rust is exactly like Safe Rust with all the same rules and semantics. It just lets you do some *extra* things that are Definitely Not Safe\n(which we will define in the next section"
          ]
        },
        {
          "title": "Harnessing Rust's typesystem for reliable state machines in embedded systems",
          "url": "https://jitter.nl/blog/2023/04/06/harnessing-rust-s-typesystem-for-reliable-state-machines-in-embedded-systems/",
          "excerpts": [
            "TypeState pattern: compile-time state transitions",
            "Rust allows us to go one step further: its strict type system can be used to lock down the possible state transitions at compile-time.",
            "Note that in this code example, a `Printer` instance can only be constructed through an `IdlePrinter`. If you try to manually construct a `Printer` struct, the compiler won’t allow you: its `_dummy` property is private!"
          ]
        },
        {
          "title": "Rust Verification Tools for Std Safety Verification",
          "url": "https://rust-lang.github.io/rust-project-goals/2024h2/std-verification.html",
          "excerpts": [
            "Virtually every verification tool has its own contract specification language,\nwhich makes it hard to combine tools to verify the same system."
          ]
        },
        {
          "title": "Model-checking/verify-rust-std and related verification tools",
          "url": "https://github.com/model-checking/verify-rust-std",
          "excerpts": [
            "The goal is to have a verified Rust standard library and prove that it is safe. A",
            "This repository is a fork of the official Rust programming\nlanguage repository, created solely to verify the Rust standard\nlibrary.",
            "For questions, suggestions or feedback, feel free to open an [issue here"
          ]
        },
        {
          "title": "Nondeterministic variables - The Kani Rust Verifier",
          "url": "https://model-checking.github.io/kani/tutorial-nondeterministic-variables.html",
          "excerpts": [
            "Kani is able to reason about programs and their execution paths by allowing users to create nondeterministic (also called symbolic) values using kani::any() ."
          ]
        },
        {
          "title": "How Safe and Unsafe Interact - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html",
          "excerpts": [
            "You can use unsafe on a block to declare that all unsafe actions performed within are verified to uphold the contracts of those operations. For instance, the ..."
          ]
        },
        {
          "title": "Two Kinds of Invariants: Safety and Validity - Unsafe Code Guidelines",
          "url": "https://internals.rust-lang.org/t/two-kinds-of-invariants-safety-and-validity/8264",
          "excerpts": [
            "In an unsafe function or unsafe block, types must be valid but may temporarily be not safe. By the time the unsafe block/fn ends, however, ..."
          ]
        },
        {
          "title": "prusti-std - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/prusti-std",
          "excerpts": [
            "Sep 4, 2023 — Provides specifications for std functions. By importing this and adding extern crate prusti_std; to your root file, one can avoid needing to ..."
          ]
        },
        {
          "title": "About | Rust Verification Tools",
          "url": "https://project-oak.github.io/rust-verification-tools/about.html",
          "excerpts": [
            "Verification tools don't support every intrinsic function for every architecture: so they may reject hand-vectorized code. This article describes how to bypass ..."
          ]
        },
        {
          "title": "Rust Nomicon: Working with Unsafe",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the module boundary with privacy.",
            "However this works perfectly.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy. However this works *perfectly*. The existence of `make_room` is *not* a\nproblem for the soundness of Vec because we didn't mark it as public. Only the\nmodule that defines this function can call it. Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.",
            "Only the\nmodule that defines this function can call it.",
            "Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.",
            "This code is 100% Safe Rust but it is also completely unsound. Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec). This is not something the rest of Vec can guard against. It *has*\nto trust the capacity field because there's no way to verify it. Because it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.",
            "Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec).",
            "Because it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.",
            "Safety lives!",
            "```"
          ]
        },
        {
          "title": "Havelsan's Revenue in 2024",
          "url": "https://aws.amazon.com/blogs/opensource/how-open-source-projects-are-using-kani-to-write-better-software-in-rust/",
          "excerpts": [
            " It also supports the typical features of date time management libraries, like the formatting and parsing of date times in a no-std environment using the typical C89 tokens",
            "It is useful wherever a monotonic clock is needed, even in the presence of leap seconds or remote time corrections (like for Network Time Protocol or Precise Time Protocol).",
            "This blog post on the Kani Rust Verifier Blog shows how Kani helped solve a number of important non-trivial bugs in hifitime.",
            "analysis of the code using Kani has proven a valuable defense-in-depth measure for Firecracker, nicely complementing the existing testing infrastructure."
          ]
        },
        {
          "title": "The Typestate Pattern in Rust (Cliff Le) - cliffle.com/blog/rust-typestate/",
          "url": "https://cliffle.com/blog/rust-typestate/",
          "excerpts": [
            "The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type.",
            "Typestates are a broader topic than the specific pattern I’ll discuss here,\nwhich is why I’m calling it the “typestate pattern .",
            "Typestates are a technique for moving properties of state (the dynamic\ninformation a program is processing) into the type level (the static world\nthat the compiler can check ahead-of-time)",
            "design pattern that encodes information about\nan object’s run-time state in its compile-time type . In particular, an API\nusing the typestate pattern will have:",
            "Operations on an object (such as methods or functions) that are only available\nwhen the object is in certain states,",
            "A way of encoding these states at the type level, such that attempts to use\nthe operations in the wrong state fail to compile,",
            "State transition operations (methods or functions) that change the\ntype-level state of objects in addition to, or instead of, changing run-time\ndynamic state, such that the operations in the previous state are no longer\npossible.",
            "This pattern is so easy in Rust that it’s almost obvious , to the point that\nyou may have already written code that uses it, perhaps without realizing it",
            " the living and the dead\nThere’s a common pattern in Rust libraries that allows an API to have two\nstates, “living” and “dead.",
            "\nstd::fs::File from the standard library has two states: “open” and “closed.",
            "// Here, we have access to `file`, and it's open.",
            "An easy technique is to make both types simple wrappers for a smart\npointer to the actual state, which stays the same in all type-states:",
            "struct HttpResponse ( Box < ActualResponseState > ) ; struct HttpResponseAfterStatus ( Box < ActualResponseState > ) ; struct ActualResponseState { ... }",
            "A simple example: the living and the dead",
            "There are several examples of the typestate pattern in widespread use in the\nRust ecosystem.",
            "The highest-profile one that I’m aware of is\nserde : the\nSerializer models a fairly complex state machine using\ntypestates",
            "Starting with a\nSerializer ,\n    * The\nserialize_struct operation consumes it and produces an object that\nimplements the\nSerializeStruct",
            "You can call the\nserialize_field and/or\nskip_field methods zero or more\ntimes.",
            "Variation: state type parameter",
            "Instead of having a separate struct for each state, we can model state as a\ntype parameter for a single generic struct.",
            "In the\nHeaders state, though, we’re guaranteed to have\nresponse_code and we\ncan access it directly.",
            "The typestate pattern is natural to use in Rust, and lets us design APIs that\nare easy to use correctly and impossible to use incorrectly.",
            "... }",
            "... }",
            "... }"
          ]
        },
        {
          "title": "Embedded Rust Book - Peripherals as State Machines",
          "url": "https://doc.rust-lang.org/beta/embedded-book/static-guarantees/state-machines.html",
          "excerpts": [
            "Microcontroller peripherals, like GPIO, can be thought of as state machines, with states such as 'Disabled', 'Enabled', 'Output: High', and 'Input: High ... Peripherals as State Machines - The Embedded Rust Book\n",
            "The peripherals of a microcontroller can be thought of as set of state machines. For example, the configuration of a simplified [GPIO pin](https://en.wikipedia.org/wiki/General-purpose_input/output) could be represented as the following tree of states:",
            "* Disabled",
            "* Enabled",
            "  + Configured as Output",
            "    - Output: High",
            "    - Output: Low",
            "  + Configured as Input",
            "    - Input: High Resistance",
            "    - Input: Pulled Low",
            "    - Input: Pulled High",
            "If the peripheral starts in the `Disabled` mode, to move to the `Input: High Resistance` mode, we must perform the following steps:",
            "1. Disabled",
            "2. Enabled",
            "3. Configured as Input",
            "4. Input: High Resistance",
            "If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, we must perform the following steps:",
            "1. Input: High Resistance",
            "2. Input: Pulled Low",
            "Similarly, if we want to move a GPIO pin from configured as `Input: Pulled Low` to `Output: High`, we must perform the following steps:",
            "1. Input: Pulled Low",
            "2. Configured as Input",
            "3. Configured as Output",
            "4.\nOutput: High"
          ]
        },
        {
          "title": "Rust on an STM32 microcontroller",
          "url": "https://medium.com/digitalfrontiers/rust-on-a-stm32-microcontroller-90fac16f6342",
          "excerpts": [
            "Consider following this pattern by implementing unsafe features in encapsulated parts of the code that are well-tested and hard to use wrong."
          ]
        },
        {
          "title": "Learning Rust",
          "url": "https://lwn.net/Articles/1007981/",
          "excerpts": [
            "As long as `unsafe` blocks uphold the invariants, they are safe globally. And if you violate invariants inside the `unsafe` blocks, then the ..."
          ]
        },
        {
          "title": "verus-lang/verus: Verified Rust for low-level systems code",
          "url": "https://github.com/verus-lang/verus",
          "excerpts": [
            "Verus is a tool for verifying the correctness of code written in Rust. Developers write specifications of what their code should do.See more"
          ]
        },
        {
          "title": "A List of companies that use formal verification methods in software ...",
          "url": "https://github.com/ligurio/practical-fm",
          "excerpts": [
            "... CBMC Model Checking Boot Code ... Blockchain, Distributed Systems, Quint Quint specification language, TLA+ Apalache, Symbolic Model Checker for TLA+, Rust ..."
          ]
        },
        {
          "title": "Using the C Bounded Model Checker as a TLA+ - Philip Zucker",
          "url": "https://www.philipzucker.com/high_cbmc/",
          "excerpts": [
            "CBMC is a tool I'm pretty bullish on. It is a bounded model checker for C code. It more or less unrolls all loops in normal compileable C to ..."
          ]
        },
        {
          "title": "fips203 - Rust",
          "url": "https://docs.rs/fips203",
          "excerpts": [
            "This crate implements the released FIPS 203 standard in pure Rust with minimal and mainstream dependencies, and without any unsafe code. All three security ..."
          ]
        },
        {
          "title": "The Scope of Unsafe : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/4065l2/the_scope_of_unsafe/",
          "excerpts": [
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the module boundary with privacy. ... Well, yes, we could ask ..."
          ]
        },
        {
          "title": "How to modularise a multi-file embedded rust program?",
          "url": "https://users.rust-lang.org/t/how-to-modularise-a-multi-file-embedded-rust-program/126786",
          "excerpts": [
            "Mar 10, 2025 — It's definitely possible to write firmware without RTIC or embassy, but way more cumbersome and unsafe. Getting mutable global state correct in ..."
          ]
        },
        {
          "title": "golemparts/rppal: A Rust library that provides access to ...",
          "url": "https://github.com/golemparts/rppal",
          "excerpts": [
            "RPPAL provides access to the Raspberry Pi's GPIO, I2C, PWM, SPI and UART peripherals through a user-friendly interface."
          ]
        },
        {
          "title": "ESP32 Standard Library Embedded Rust: UART ...",
          "url": "https://blog.theembeddedrustacean.com/esp32-standard-library-embedded-rust-uart-communication",
          "excerpts": [
            "Jul 20, 2023 — Any gpio type can be used here since the None option is selected. Alternatively, one can also use the AnyIOPin generic pin type in the gpio ..."
          ]
        },
        {
          "title": "Is there anything that can be done to make rust embedded ...",
          "url": "https://www.reddit.com/r/rust/comments/15i1ntk/is_there_anything_that_can_be_done_to_make_rust/",
          "excerpts": [
            "Despite being relatively young, Rust has a wonderful collection of useful no_std libraries: serde and minicbor for sending custom messages ..."
          ]
        },
        {
          "title": "Unsafe register access option. · Issue #714 · rust-embedded/svd2rust",
          "url": "https://github.com/rust-embedded/svd2rust/issues/714",
          "excerpts": [
            "Following the definition of unsafety as described in Ferrocene spec and Rust reference, unsafe code may result in undefined behavior."
          ]
        },
        {
          "title": "https://rust-training.ferrous-systems.com/latest/book/kani",
          "url": "https://rust-training.ferrous-systems.com/latest/book/kani",
          "excerpts": [
            " [Building Robust Programs with Kani",
            " [Rust Guarantees are Very Strong",
            "\n* No `null` \\-dereferencing",
            "* No uninitialized memory access",
            "* No use-after-free",
            "* No double-free",
            "* No data races",
            "\"Does my program panic ?\" is a hard question in Rust",
            "panic-never. triggers a linker error if there's panicking code path in the binary"
          ]
        },
        {
          "title": "cortex_m_microclock - Rust - Docs.rs",
          "url": "https://docs.rs/cortex-m-microclock",
          "excerpts": [
            "The clock is based on the CYCCNT counter from the Cortex-M DWT peripheral, which increments\nwith each processor clock cycle. However as the CYCCNT upcounter is only 32 bits wide, it may overflow\nquite rapidly depending on your SYSCLK frequency.",
            "ch increments\nwith each processor clock cycle.",
            "ck::CYCCNTClock\") is the structure representing the software clock. This structure is a\nsingleton exposing all the methods of the crate available to user. All these methods are static and\ncan be called from any thread without concurrency issues.",
            "The [`CYCCNTClock`](struct.CYCCNTClock.html \"struct cortex_m_microclock::CYCCNTClock\") keeps track of\nmultiple CYCCNT cycles using an internal counter so it can be used to evaluate very large durations of time.",
            "In order to use the clock you should first call the [`CYCCNTClock::init()`](struct.CYCCNTClock.html.init \"associated function cortex_m_microclock::CYCCNTClock::init\") method which takes ownership of\nthe DWT peripheral.",
            "From this point you can use [`CYCCNTClock::now()`](struct.CYCCNTClock.html.now \"associated function cortex_m_microclock::CYCCNTClock::now\") and [`CYCCNTClock::delay()`](struct.CYCCNTClock.html.delay \"associated function cortex_m_microclock::CYCCNTClock::delay\") methods.",
            "The [`CYCCNTClock::update()`](struct.CYCCNTClock.html.update \"associated function cortex_m_microclock::CYCCNTClock::update\") method should be called periodically to avoid missing\nthe CYCCNT wrapping around.",
            "lock::CYCCNTClock\") is the structure representing the software clock. This structure is a\nsingleton exposing all the methods of the crate available to user.",
            "`min_update_freq = SYS_CLK_FREQ/(2³²)`"
          ]
        },
        {
          "title": "A first attempt in Rust - The Embedded Rust Book",
          "url": "https://doc.rust-lang.org/beta/embedded-book/peripherals/a-first-attempt.html",
          "excerpts": [
            "Let's look at the 'SysTick' peripheral - a simple timer which comes with every Cortex-M processor core."
          ]
        },
        {
          "title": "The Rust compiler is now compiled with (thin) LTO (finally) ...",
          "url": "https://www.reddit.com/r/rust/comments/ycmqml/the_rust_compiler_is_now_compiled_with_thin_lto/",
          "excerpts": [
            "rustc is now compiled with (thin) LTO (PR), which resulted in very nice gains across the board, and even without any noticeable regressions!See more",
            "The Rust compiler is now compiled with (thin) LTO (finally) for 5-10% improvements. There was a post about this already, apparently ..."
          ]
        },
        {
          "title": "Should default recommended opt-level for minimizing ...",
          "url": "https://internals.rust-lang.org/t/should-default-recommended-opt-level-for-minimizing-binary-size-be-s-or-z/19685",
          "excerpts": [
            "I have historically recommended opt-level = \"z\" since from the docs it seems like it should be \"s\" + also don't unroll loops (ie strictly better)."
          ]
        },
        {
          "title": "Distributed ThinLTO support in Rustc - compiler",
          "url": "https://internals.rust-lang.org/t/distributed-thinlto-support-in-rustc/22157",
          "excerpts": [
            "Having support for Distributed Thin LTO is an important thing for warehouse-like Rust applications that want to use ThinLTO as an additional optimization step.See more"
          ]
        },
        {
          "title": "Build Configuration - The Rust Performance Book",
          "url": "https://nnethercote.github.io/perf-book/build-configuration.html",
          "excerpts": [
            "If you want to minimize binary size, consider opt-level = \"z\" , codegen-units = 1 , lto = \"fat\" , panic = \"abort\" , and strip = \"symbols\" . In either case, ..."
          ]
        },
        {
          "title": "DWT in cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/struct.DWT.html",
          "excerpts": [
            "Enables the cycle counter. The global trace enable ( DCB::enable_trace ) should be set before enabling the cycle counter, the processor may ignore writes to ..."
          ]
        },
        {
          "title": "cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/index.html",
          "excerpts": [
            "DCB.enable_trace(); peripherals.DWT.enable_cycle_counter(); } // all the peripheral singletons are destroyed here // but this method can be called without a DWT ...",
            "To use (most of) the peripheral API first you must get an *instance* of the peripheral.\n",
            "All the core peripherals are modeled as singletons. cortex\\_m::peripheral - Rust",
            "let mut peripherals = Peripherals::take().unwrap();",
            "peripherals.DCB.enable_trace();",
            "} // all the peripheral singletons are destroyed here",
            "// actually safe because this is an atomic read with no side effects",
            "let cyccnt = unsafe { (*DWT::PTR).cyccnt.read() };",
            "```"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "```",
            "```",
            "extern crate panic_halt;",
            "    loop {}",
            "    loop {}",
            "}",
            "}",
            "#! [no_std]"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "    loop {}",
            "}",
            "#!\n[no_std",
            "#!\n[no_std",
            "#! [no_main"
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "```",
            "fn main() -> ! {",
            "}",
            "#! [no_std]"
          ]
        },
        {
          "title": "PSA for `std` Feature in `no_std` Libraries : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1hs6spy/psa_for_std_feature_in_no_std_libraries/",
          "excerpts": [
            "```",
            "```",
            "#!\n[no_std",
            "#!\n[no_std"
          ]
        },
        {
          "title": "Is it possible to enable a rust feature only in test? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/68618789/is-it-possible-to-enable-a-rust-feature-only-in-test",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The Embedded Rust Book - QEMU and no_std guidance",
          "url": "https://docs.rust-embedded.org/book/start/qemu.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Rust Bindgen no_std FFI and Bindgen Issues discussion",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1583",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Heapless and Rust Embedded: Portability and Multi-Target/Portability Aspects",
          "url": "http://github.com/rust-embedded/heapless",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Rust for Low Power Digital Signal Processing - Interrupt",
          "url": "https://interrupt.memfault.com/blog/rust-for-digital-signal-processing",
          "excerpts": [
            "A good option on Cortex-M4 is to use the Cycle Count register. Reading it before and after calling our function will tell us how many CPU ..."
          ]
        },
        {
          "title": "riscv::register::mcycle - Rust - mnemOS",
          "url": "https://mnemos-dev.jamesmunns.com/doc/riscv/register/mcycle/",
          "excerpts": [
            "Functions§ · read. Reads the CSR · read64. Reads the CSR as a 64-bit value."
          ]
        },
        {
          "title": "riscv::register::sepc - Rust - Docs.rs",
          "url": "https://docs.rs/riscv/latest/riscv/register/sepc/index.html",
          "excerpts": [
            "Functions§. read: Reads the CSR. try_read: Attempts to read the CSR. try_write ⚠: Attempts to write the CSR."
          ]
        },
        {
          "title": "riscv_csr::csr - Rust",
          "url": "https://docs.tockos.org/riscv_csr/csr/",
          "excerpts": [
            "ReadWriteRiscvCsr type for RISC-V CSRs. Structs§. ReadWriteRiscvCsr: Read/Write registers. Constants§. MCAUSE · MCYCLE · MCYCLEH · MEPC · MIE · MINSTRET ..."
          ]
        },
        {
          "title": "emit_stack_sizes - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html",
          "excerpts": [
            "The rustc flag -Z emit-stack-sizes makes LLVM emit stack size metadata. NOTE: This LLVM feature only supports the ELF object format as of LLVM 8.0."
          ]
        },
        {
          "title": "Cargo-call-stack Static Call-stack Analysis for Rust - IEEE Xplore",
          "url": "https://ieeexplore.ieee.org/document/8972088",
          "excerpts": [
            "In this paper we present an integrated tool for call-stack analysis of Rust applications. We cover both theoretical and practical challenges, ..."
          ]
        },
        {
          "title": "Help test out ThinLTO! - compiler",
          "url": "https://internals.rust-lang.org/t/help-test-out-thinlto/6017",
          "excerpts": [
            "Oct 9, 2017 — In this chapter of the war against Rust's long compile times we're going to take a look at LLVM optimizations and code generation."
          ]
        },
        {
          "title": "Truly abort on any panic - embedded - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/truly-abort-on-any-panic/72873",
          "excerpts": [
            "I am writing code for a custom RISC-V target and I am optimizing for small code size. When any panic happens, I want the code to jump to my custom abort ..."
          ]
        },
        {
          "title": "Panic handler binary size bloat #41 - rust-embedded/wg - GitHub",
          "url": "https://github.com/rust-embedded/wg/issues/41",
          "excerpts": [
            "Panic strings kept in the binary. Even when panic_fmt (the panic handler) is defined to simply abort the compiler still produces machine code ..."
          ]
        },
        {
          "title": "(Zero cost) stack overflow protection · Issue #34",
          "url": "https://github.com/rust-embedded/cortex-m-rt/issues/34",
          "excerpts": [
            "Sep 27, 2017 — Other options for stack overflow protection · Use the MPU (Memory Protection Unit) to mark the upper boundary of the static region as read-only."
          ]
        },
        {
          "title": "Measuring time in #[no_std] - cortex-m3 microcontroller",
          "url": "https://users.rust-lang.org/t/measuring-time-in-no-std-cortex-m3-microcontroller/36491/6",
          "excerpts": [
            "Jan 5, 2020 — Hello dear Rustaceans :crab:, I'm trying to port a Rust program to be run on QEMU with the configuration for LM3S6965, a Cortex-M3 ..."
          ]
        },
        {
          "title": "[discussion] Peripheral singletons are not multi-core friendly",
          "url": "https://github.com/rust-embedded/cortex-m/issues/149",
          "excerpts": [
            "Cortex-M memory mapped register that returns a \"core id\" (cf. RISC-V mhartid ); nor there is a processor register that can be used to hold a \" ..."
          ]
        },
        {
          "title": "What do the optimization levels `-Os` and `-Oz` do in rustc?",
          "url": "https://stackoverflow.com/questions/45608392/what-do-the-optimization-levels-os-and-oz-do-in-rustc",
          "excerpts": [
            "s means optimize for size, and z means optimize for size some more. All optimizations seem to be performed by the LLVM code-generation engine."
          ]
        },
        {
          "title": "Min-Sized Rust",
          "url": "https://github.com/johnthagen/min-sized-rust",
          "excerpts": [
            "LTO instructs the linker to optimize at the link stage. This can, for example, remove dead code and often times reduces binary size.",
            "Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true",
            "Build in Release Mode\nBy default,\ncargo build builds the Rust binary in debug mode. Debug mode disables many\noptimizations, which helps debuggers (and IDEs that run them) provide a better debugging\nexperience. Debug binaries can be 30% or more larger than release binaries. To minimize binary size, build in release mode:\n$ cargo build --release",
            "strip Symbols from Binary\nBy default on Linux and macOS, symbol information is included in the compiled\n.elf file. This\ninformation is not needed to properly execute the binary. Cargo can be configured to automatically\nstrip binaries . Modify\nCargo.toml in this way:\n[ profile . release ] strip = true # Automatically strip symbols from the binary. Prior to Rust 1.59 , run\nstrip directly on\nthe\n.elf file instead:\n$ strip target/release/min-sized-rust",
            "Optimize For Size\nCargo defaults its optimization level to\n3 for release builds ,\nwhich optimizes the binary for speed . To instruct Cargo to optimize for minimal binary size , use the\nz optimization level in\nCargo.toml :\n[ profile . release ] opt-level = \" z \" # Optimize for size.",
            "Note\nIn some cases the\n\"s\" level may result in a smaller binary than\n\"z\" , as explained in the\nopt-level documentation :\nIt is recommended to experiment with different levels to find the right balance for your project.",
            "Enable Link Time Optimization (LTO)\nBy default, Cargo instructs compilation units to be compiled and optimized in isolation . LTO instructs the linker to optimize at the\nlink stage. This can, for example, remove dead code and often times reduces binary size. Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "In this case, cargo-call-stack will use its own stack usage analysis based on machine code, which only supports the ARM Cortex-M architecture.",
            "Hardware ... (\"\") does *not* use the stack",
            "warning: assuming that llvm_asm! (\"\") does *not* use the stack",
            "Graphviz's `dot` can then be used to generate an image from this dot file. ```",
            "$ dot -Tsvg cg.dot > cg.svg",
            "[! [Call graph with direct function calls](/japaric/cargo-call-stack/raw/main/assets/direct.png)](https://japaric.github.io/cargo-call-stack/direct.svg)",
            "Each node in this graph represents a function, which could be a free function,",
            "an inherent method or a trait method. Each directed edge indicates a \"calls\"",
            "relationship. For example, in the above graph `Reset` calls both `main` and",
            "DefaultPreInit`. Each node also contains its `local` stack usage in bytes and its `max`-imum",
            "stack usage, also in bytes. The maximum stack usage includes the stack usage of",
            "all the other functions that the function could invoke. This is the `no_std` program used to generate the call graph shown above. ```",
            "#! [feature(llvm_asm)",
            "extern crate panic_halt;",
            "use core::ptr;",
            "use cortex_m_rt::{entry, exception};",
            "#[entry]",
            "fn main() -> ! {",
            "    foo();",
            "    bar();",
            "    loop {}",
            "fn foo() {",
            "    // spill variables onto the stack",
            "#[inline(never)]",
            "#[inline(never)]",
            "fn bar() {",
            "    unsafe { llvm_asm! (\"\" : : \"r\"(0) \"r\"(1) \"r\"(2) \"r\"(3) \"r\"(4) \"r\"(5)) }",
            "    unsafe { llvm_asm! (\"\" : : \"r\"(0) \"r\"(1) \"r\"(2) \"r\"(3) \"r\"(4) \"r\"(5)) }",
            "}",
            "}",
            "}",
            "#! [no_std",
            "#! [no_main"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "read64 in riscv::register::mcycle - Rust",
          "url": "https://docs.rs/riscv/latest/riscv32imac-unknown-none-elf/riscv/register/mcycle/fn.read64.html",
          "excerpts": [
            "Reads the CSR as a 64-bit value."
          ]
        },
        {
          "title": "Codegen Options - The rustc book - Rust Documentation",
          "url": "https://doc.rust-lang.org/rustc/codegen-options/index.html",
          "excerpts": [
            "When -C lto is not specified, LTO is disabled if codegen units is 1 or optimizations are disabled ( -C opt-level=0 ). That is: When -C lto is not specified:."
          ]
        },
        {
          "title": "Enable Link-Time Optimization (LTO) · rustcoreutils posixutils-rs ...",
          "url": "https://github.com/rustcoreutils/posixutils-rs/discussions/197",
          "excerpts": [
            "Another question - did you use Thin or Fat LTO? ThinLTO has lower build time overhead (in the price of a bit less aggressive optimizations but in practice it's ..."
          ]
        },
        {
          "title": "EventLoop::new() can panic with \"Bad File Descriptor\" #7680 - GitHub",
          "url": "https://github.com/alacritty/alacritty/issues/7680",
          "excerpts": [
            "* Use `thin` instead of `fat` LTO The performance between `thin` and `fat` is in the margin of error, however `thin` LTO is way faster to build."
          ]
        },
        {
          "title": "Multicore RTFM: No_std perf & timing (Cortex-M, RTIC) - Japaric blog",
          "url": "https://blog.japaric.io/multicore-rtfm/",
          "excerpts": [
            "The framework lets the user provide their own `monotonic` timer. In this example\nwe used the DWT cycle counter (AKA `CYCCNT`) which is a Cortex-M peripheral\nfound on all ARMv7-M devices and is clocked at the same frequency as the CP"
          ]
        },
        {
          "title": "Rust no_std Profiling and Build Optimization (Cargo Profiles)",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "Profiles provide a way to alter the compiler settings, influencing things like optimizations and debugging symbols.",
            "Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "The valid options are:\n    * 0 : no optimizations\n    * 1 : basic optimizations\n    * 2 : some optimizations\n    * 3 : all optimizations\n    * \"s\" : optimize for binary size\n    * \"z\" : optimize for binary size, but also turn off loop vectorization.",
            "The\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary.",
            "There may be surprising results, such as level\n3 being slower than\n2 , or the\n\"s\" and\n\"z\" levels not being necessarily\nsmaller"
          ]
        },
        {
          "title": "RTIC by example - Real-Time Interrupt-driven Concurrency",
          "url": "https://rtic.rs/1/book/en/by-example.html",
          "excerpts": [
            "This part of the book introduces the Real-Time Interrupt-driven Concurrency (RTIC) framework to new users by walking them through examples of increasing ..."
          ]
        },
        {
          "title": "embassy_stm32 - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-stm32/",
          "excerpts": [
            "The embassy-stm32 HAL aims to provide a safe, idiomatic hardware abstraction layer for all STM32 families. The HAL implements both blocking and async APIs for ..."
          ]
        },
        {
          "title": "embassy-rs/embassy: Modern embedded framework, using ... - GitHub",
          "url": "https://github.com/embassy-rs/embassy",
          "excerpts": [
            "Embassy is the next-generation framework for embedded applications. Write safe, correct and energy-efficient embedded code faster, using the Rust programming ...",
            "The Embassy project maintains HALs for select hardware, but you can still use HALs from other projects with Embassy.",
            "ub.io/async-book/) allows for unprecedentedly easy and efficient multitasking in embedded systems. Tasks get transformed at compile time into state machines that get run cooperatively. It requires no dynamic memory allocation and runs on a single stack, so no per-task stack size tuning is required."
          ]
        },
        {
          "title": "Embassy Book",
          "url": "https://embassy.dev/book/",
          "excerpts": [
            "The Embassy project maintains HALs for select hardware, but you can still use HALs from other projects with Embassy."
          ]
        },
        {
          "title": "Embassy - Modern embedded framework for Rust",
          "url": "http://github.com/embassy-rs/embassy",
          "excerpts": [
            "The Embassy project maintains HALs for select hardware, but you can still use HALs from other projects with Embassy.",
            "The Embassy project maintains HALs for select hardware, but you can still use HALs from other projects with Embassy."
          ]
        },
        {
          "title": "Embedded Rust and Embassy: DMA Controllers",
          "url": "https://blog.theembeddedrustacean.com/embedded-rust-and-embassy-dma-controllers",
          "excerpts": [
            "Jan 2, 2023 — In this post, I demonstrate DMA usage by creating a UART application that echoes messages received from a host PC."
          ]
        },
        {
          "title": "Embedded Rust and Embassy: DMA Controllers",
          "url": "https://dev.to/theembeddedrustacean/embedded-rust-and-embassy-dma-controllers-mng",
          "excerpts": [
            "Jan 2, 2023 — In this post, I demonstrate DMA usage by creating a UART application that echoes messages received from a host PC."
          ]
        },
        {
          "title": "USART interrupt handling in Rust",
          "url": "https://community.st.com/t5/stm32-mcus-products/usart-interrupt-handling-in-rust/td-p/707249",
          "excerpts": [
            "Aug 12, 2024 — Peripherals like UART have their own interrupts besides EXTI. See the reference manual RM0390 USART chapter for details at the register ...",
            "Missing: no_std driver polling nrf52",
            "Hi, I'm new to embedded (as in one week old) and am trying to build a small system to do a few things for an optical product we're building: ..."
          ]
        },
        {
          "title": "Why not always use DMA in favor of interrupts with UART ...",
          "url": "https://electronics.stackexchange.com/questions/340310/why-not-always-use-dma-in-favor-of-interrupts-with-uart-on-stm32",
          "excerpts": [
            "Nov 17, 2017 — DMA will mean more latency in claiming the data, especially since you don't get any real benefit unless you allow it to gather multiple characters."
          ]
        },
        {
          "title": "Are we embedded yet? - Blog",
          "url": "https://tweedegolf.nl/en/blog/101/are-we-embedded-yet",
          "excerpts": [
            "The answer is yes. At Tweede golf, we used Rust to write the software for a heart rate monitor for Glanum, and to build on-board firmware for a solar sail ..."
          ]
        },
        {
          "title": "rust-unofficial/awesome-rust: A curated list of Rust code ... - GitHub",
          "url": "https://github.com/rust-unofficial/awesome-rust",
          "excerpts": [
            "See awesome-embedded-rust for a curated, and more extended list of embedded Rust resources. Arduino. avr-rust/ruduino - Reusable components for the Arduino Uno."
          ]
        },
        {
          "title": "Embedded development — list of Rust libraries/crates // Lib.rs",
          "url": "https://lib.rs/embedded",
          "excerpts": [
            "A no-std embedded-hal package for the hx711 load cell, based on the embedded hal. Has optional support for interrupts on the esp32. v0.3.0 ...",
            "Embassy Hardware Abstraction Layer (HAL) for the Raspberry Pi RP2040 or RP235x microcontroller ... v0.10.0 3.2K no-std #stm32-hal #cortex-m #stm32 #hal ...",
            "Platform-independent I2C driver for MPU6050. Supports DMP usage. Fork of drogue-mpu-6050 which uses only embedded-hal traits (no dependency on embedded-time or ... #specification\n",
            "#### sntpc",
            "#### ux",
            "\n  Implement the following non standard integers: u2, u3, u4, u5, u6, u7, u9, u10, u11, u12, u13, u14, u15, u17, u18, u19, u20, u21, u22, u23, u24, u25, u26, u27, u28, u29, u30, u31, u33…",
            "no-std",
            "no-std",
            "no-std",
            "#### embassy-usb-driver",
            "  v0.3.0",
            "  no-std",
            "  bin+lib",
            "  #risc-v",
            "  #soc",
            "  #jh7110",
            "  #pac"
          ]
        },
        {
          "title": "embassy_nrf - Rust - embassy-executor",
          "url": "https://docs.embassy.dev/embassy-nrf/",
          "excerpts": [
            "The embassy-nrf HAL supports most variants of the nRF family: nRF51 (examples); nRF52 (examples); nRF53 (examples); nRF91 (examples). Most peripherals are ..."
          ]
        },
        {
          "title": "Port C project to Rust 🚗 - embedded",
          "url": "https://users.rust-lang.org/t/port-c-project-to-rust/46854",
          "excerpts": [
            "Aug 4, 2020 — The nRF52 series is also pretty good, it has its own set of HAL crates here that are also fairly nice to use. You can get the nRF52840-DK ...See more"
          ]
        },
        {
          "title": "Is there a way to use USART with DMA and Interrupt - embedded - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/is-there-a-way-to-use-usart-with-dma-and-interrupt/61215",
          "excerpts": [
            "Reference to the examples provided by stm32fxxx-hal, I have known how to use USART and use it with DMA (program 1) or use it with Interrupt( program2 ).",
            "#!\n[no_std",
            "! [no_main]\n#!\n ...",
            "serial.is_rxne() {\n            serial.unlisten(Event::Rxne);\n            match serial.read() {",
            "The only way I think now is to use these in `loop` . And set a flag to control it, and modify the flag in interrupt function.",
            "The data will be sent here. let sending = tx.write_all(tx_buf, tx_channel);",
            "The data will not be read here.",
            "#! [no_main"
          ]
        },
        {
          "title": "RTIC and no_std guidance with lock-free patterns",
          "url": "https://rtic.rs/1/book/en/by-example/tips_static_lifetimes.html",
          "excerpts": [
            "#!\n[no_std",
            "#! [no_main"
          ]
        },
        {
          "title": "Panic - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/panic.html",
          "excerpts": [
            "#! [no_std"
          ]
        },
        {
          "title": "Embedded Rust with Embassy UART Example",
          "url": "https://dev.to/theembeddedrustacean/embedded-rust-embassy-uart-serial-communication-4fd3",
          "excerpts": [
            "#! [no_std",
            "#! [no_main",
            "\n[feature(type_alias_impl_trait)]",
            "use embassy_stm32::dma::NoDma;",
            "use embassy_stm32::exti::ExtiInput;",
            "use embassy_stm32::gpio::{AnyPin, Input, Level, Output, Pin, Pull, Speed};",
            "use embassy_stm32::usart::{Config, UartTx};",
            "#[embassy_executor::task]",
            "async fn led_task(led: AnyPin) {",
            "#[embassy_executor::main]",
            "async fn main(spawner: Spawner) {",
            "let p = embassy_stm32::init(Default::default());",
            "let mut value: u8 = 0;",
            "let mut msg: String<8> = String::new();",
            "In this post, I will be configuring and setting up UART communication with a PC terminal using embassy for an STM32 device."
          ]
        },
        {
          "title": "Solved: Interrupt vs DMA - which one is more efficient for...",
          "url": "https://community.st.com/t5/stm32-mcus-products/interrupt-vs-dma-which-one-is-more-efficient-for-timer-pwm/td-p/80431",
          "excerpts": [
            "Individual DMA transfers do not directly involve the processor and generally they are faster, so you definitively want to use them in places where speed/latency ..."
          ]
        },
        {
          "title": "async/await on embedded Rust - Ferrous Systems",
          "url": "https://ferrous-systems.com/blog/async-on-embedded/",
          "excerpts": [
            "In this post we'll explore what could be done once async/await is available in no_std land and why we think async/await is a big deal for embedded development."
          ]
        },
        {
          "title": "Running Rust on STM32 Microcontrollers: A Practical Guide for ...",
          "url": "https://medium.com/@saifhajsalem12/running-rust-on-stm32-microcontrollers-a-practical-guide-for-embedded-enthusiasts-fed6550e4aef",
          "excerpts": [
            "In this guide, we'll walk through setting up a simple embedded application using Rust, specifically targeting a microcontroller."
          ]
        },
        {
          "title": "STM32 in Rust : r/embedded - Reddit",
          "url": "https://www.reddit.com/r/embedded/comments/yyd2dj/stm32_in_rust/",
          "excerpts": [
            "I understand STM SDK only supports C and C++, which i have both used in the past, so i assume the code generator is not an option.",
            "There is an STM32 HAL, and could use it with RTIC crate. There is Embassy, which supports STM32, has its own async HAL."
          ]
        },
        {
          "title": "Finally managed to write my first embedded HAL driver ... - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/kuk8b6/finally_managed_to_write_my_first_embedded_hal/",
          "excerpts": [
            "Embedded on rust means lots of page-long types full of generics. But if you use async and no_std, you can avoid the nastiness of storing all ..."
          ]
        },
        {
          "title": "How can we share a bus between multiple drivers? #35 - GitHub",
          "url": "https://github.com/rust-embedded/embedded-hal/issues/35",
          "excerpts": [
            "Missing: no_std study"
          ]
        },
        {
          "title": "Embedded Rust - nrf52840 programming : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/cbe1gp/embedded_rust_nrf52840_programming/",
          "excerpts": [
            "I have a simple example here that I stopped working on after compiling and flashing, but no interesting code. Not sure if it would be helpful or ..."
          ]
        },
        {
          "title": "Ideal board for Rust? : r/embedded",
          "url": "https://www.reddit.com/r/embedded/comments/izlnte/ideal_board_for_rust/",
          "excerpts": [
            "The STM32 series is best supported I believe. I think Atmel is relatively well supported as well because Arduino. TL;DR: Embedded Rust is a ..."
          ]
        },
        {
          "title": "Is anyone using Rust for embedded work - Reddit",
          "url": "https://www.reddit.com/r/embedded/comments/1amh6jq/is_anyone_using_rust_for_embedded_work/",
          "excerpts": [
            "Until Zig matures, Rust provides a better experience than C. But only if you are using Cortex M 32bit processors, especially STM32 family of ..."
          ]
        },
        {
          "title": "Handling sync+async for embedded-hal device drivers : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1h2rzlr/handling_syncasync_for_embeddedhal_device_drivers/",
          "excerpts": [
            "Missing: STM32 nRF52"
          ]
        },
        {
          "title": "USART using stm32f4xx_hal - embedded",
          "url": "https://users.rust-lang.org/t/usart-using-stm32f4xx-hal/99689",
          "excerpts": [
            "Sep 10, 2023 — I am trying to print something on putty using USART to learn how serial communication works. I need to use it to write adc voltage values from rtic-adc-dma.rs ..."
          ]
        },
        {
          "title": "Our First Rust “Blinky” Program on Raspberry Pi Pico W",
          "url": "https://murraytodd.medium.com/our-first-rust-blinky-program-on-raspberry-pi-pico-w-376211f1074d",
          "excerpts": [
            "Missing: performance stm32"
          ]
        },
        {
          "title": "[PDF] Concurrency Techniques and Hardware Abstraction Layer Concepts ...",
          "url": "https://www.acs.eonerc.rwth-aachen.de/global/show_document.asp?id=aaaaaaaacgnftdx",
          "excerpts": [
            "RTIC8 is a Real-Time Interrupt-driven Concurrency framework for ARM Cortex-M microcontrollers, recommended by the Rust embedded devices Working Group9. The."
          ]
        },
        {
          "title": "Benchmarking USB Transfer Speeds - Hackaday",
          "url": "https://hackaday.com/2013/06/03/benchmarking-usb-transfer-speeds/",
          "excerpts": [
            "CDC-ACM can be had in both windows and linux, it is not speed limited, and rather simple. So – yes, I use CDC-ACM, I wrote code for CDC-EEM ..."
          ]
        },
        {
          "title": "Rust + Embedded: A Development Power Duo",
          "url": "https://developer.espressif.com/blog/rust-embedded-a-development-power-duo/",
          "excerpts": [
            "Performance : Rust is designed for high performance and can go toe-to-toe with C and C++ in performance measures while still providing strong ..."
          ]
        },
        {
          "title": "STM32 Ethernet Port (TCP Throughput)",
          "url": "https://community.st.com/t5/stm32-mcus-products/stm32-ethernet-port-tcp-throughput/td-p/400549",
          "excerpts": [
            "May 28, 2018 — I am currently performing the TCP throughput Test by using lwiperf framework as provided. I have performed the test on below Nucleo 144 pins ..."
          ]
        },
        {
          "title": "when to choose stm32 MCUs over a raspberry pi Pico",
          "url": "https://www.reddit.com/r/embedded/comments/yptnau/when_to_choose_stm32_mcus_over_a_raspberry_pi_pico/",
          "excerpts": [
            "BTW, the RP2040 is a dual-core Cortex-M0+ while the STM32F407 is a Cortex-M4, so they don't play in the same league."
          ]
        },
        {
          "title": "awesome-embedded-rust/README.md at master",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust/blob/master/README.md",
          "excerpts": [
            "smoltcp: a small TCP/IP stack that runs without alloc . ... rmk: Mechanical keyboard firmware for stm32/rp2040, supports vial/dynamic keymap/eeprom, written in ..."
          ]
        },
        {
          "title": "Embassy",
          "url": "https://embassy.dev/",
          "excerpts": [
            "Write safe, correct and energy-efficient embedded code faster, using the Rust programming language, its async facilities, and the Embassy libraries."
          ]
        },
        {
          "title": "Towards Understanding the Runtime Performance of Rust",
          "url": "https://dl.acm.org/doi/fullHtml/10.1145/3551349.3559494",
          "excerpts": [
            "In this paper, we aim to understand the performance of Rust, using C as the baseline. First, we collect a set of micro benchmarks where each program is ..."
          ]
        },
        {
          "title": "[PDF] Using Rust as a Complement to C for Embedded Systems Software ...",
          "url": "https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=8938297&fileOId=8938299",
          "excerpts": [
            "This report presents a case study of using the Rust language and associated tooling such as debuggers and IDEs in practise. The study was ..."
          ]
        },
        {
          "title": "Using Rust Embedded to capture sensor data",
          "url": "https://murraytodd.medium.com/using-rust-embedded-to-capture-sensor-data-37db1f726d5c",
          "excerpts": [
            "In this fifth part in my series, we read sensor information both digitally via an I2C channel and via analog readings from the specialized ..."
          ]
        },
        {
          "title": "What are your best practices to make UART comms ...",
          "url": "https://www.reddit.com/r/embedded/comments/1d45tel/what_are_your_best_practices_to_make_uart_comms/",
          "excerpts": [
            "Simply setup the DMA for a max possible number of bytes to be recived (or for your biggest message or buffer size) and start it. Then in the CTI ..."
          ]
        },
        {
          "title": "How to avoid accidentally breaking no_std compatibility in ...",
          "url": "https://www.reddit.com/r/rust/comments/ef8nd9/how_to_avoid_accidentally_breaking_no_std/",
          "excerpts": [
            "Ran across this issue today when releasing the (supposedly) first no_std compatible version of my rn2xx3 driver crate, only to notice that code ..."
          ]
        },
        {
          "title": "USB CDC ACM max transfer speed - Nordic DevZone",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/83705/usb-cdc-acm-max-transfer-speed",
          "excerpts": [
            "Missing: rust benchmark"
          ]
        },
        {
          "title": "RTIC - Open Source Real-Time Operating Systems (RTOS)",
          "url": "https://www.osrtos.com/rtos/rtic/",
          "excerpts": [
            "Apr 7, 2025 — Examples of bringing up different sockets (TCP, UDP, WebSocket). Based on smoltcp crate.. arcus. Smart LED strip with embedded rust on rp2040."
          ]
        },
        {
          "title": "Porting the Slint UI Toolkit to a Microcontroller with 264K ...",
          "url": "https://slint.dev/blog/porting-slint-to-microcontrollers",
          "excerpts": [
            "A few months ago we started porting Slint to microcontrollers (MCUs), and this blog post describes how we achieved that."
          ]
        },
        {
          "title": "Introduction to Embedded Development with Rust",
          "url": "https://kerkour.com/introduction-to-embedded-development-with-rust",
          "excerpts": [
            "The ESP32 family of chips is certainly the easiest one to use with Rust because of the official support and investment from the manufacturer, and great official documentation.",
            "From my point of view, the only downsides of ESP32 chips is that they consume a little bit more energy than other microcontrollers, especially when wifi is running (we are talking about a few mA), and that they are slower than STM32 chips.",
            "RISC-V based ESP-32 microcontrollers with Rust and Embassy just work.",
            "You can find the Rust libraries supporting the ESP32 chips here: <https://github.com/esp-r",
            "Due to their BLE connectivity and very low power consumption, nRF chips are often used in smartwatches and similar devices, such as in the new [Core 2 Duo watch](https://ericmig",
            "You can find the Rust libraries supporting the nRF chips here: <https://github.com/nrf-r",
            "Raspberry Pi's microcontrollers have sexy development boards (the Raspberry pi pico / pico 2 w), but are unfortunately not that great otherwise.",
            "RP2040 & RP2350",
            "e. The older one, RP2040, is slow and has a small amount of RAM, while the newer one looks awesome on paper with it's double-core processor and 520 KB of on-chip RAM, but has an [unfortunate hardware issue]"
          ]
        },
        {
          "title": "Using Serial DMA for variable sized transfers—stm32-rs/stm32f3xx-hal/issues/325",
          "url": "https://github.com/stm32-rs/stm32f3xx-hal/issues/325",
          "excerpts": [
            "\nUsing Serial DMA for variable sized transfers #325",
            "s\n\nHello,\n\nI think this question might also be suited in a forum post. I am using a STM32F3-Disco in my current project so I thought that I can also ask this here.\nI am currently planning on how to perform variably sized transfers using DMA + IRQ + RTIC.",
            "According to some forum posts, this is definitely possible using the IDLE line or the Receiver Timeout IRQ by the USART peripheral.",
            "More specifically, I wanted to have one RTIC task which uses DMA to send all TX data, and one RTIC task to receive variable sized RX packets, which are only limited in their maximum size.",
            " Unfortunately, I have not really found an example for this in Rust yet and I only have experience with variable sized transfers using a combination of [FIFO + IRQ on a smaller Cortex-M0 based system]",
            "One problem is that I am forced to split the serial struct for DMA transfers, as the transfer struct takes ownership of the RX or TX part.",
            "What is the common approach when facing a problem like that? One idea I had was to adapt the split function to return the USART peripheral so I can use it at my own peril for things like this.",
            "TX: is usually a little bit easier. I have a RTIC task which reads from a heapless queue or some other form of queue and sends any contained frames with DMA.",
            "RX: I configure a receive timeout IRQ and then initiate a DMA transfer with the maximum expected packet length.",
            "I pass the read packet into a heapless queue or some other form of queue which is processed by another task."
          ]
        },
        {
          "title": "Portability - Rust Embedded MB2 Discovery Book",
          "url": "https://docs.rust-embedded.org/discovery-mb2/06-hello-world/portability.html",
          "excerpts": [
            "Portability - Rust Embedded MB2 Discovery Book",
            "One cool advantage, though, is that our code becomes really portable.",
            "#! [no_std]"
          ]
        },
        {
          "title": "meyerzinn.tech post on running Rust code on RISC-V in QEMU",
          "url": "https://meyerzinn.tech/posts/2023/03/05/running-rust-code-on-risc-v-in-qemu/",
          "excerpts": [
            "#! [no_std]"
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: DMA Controllers",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-hal-dma-controllers-daf",
          "excerpts": [
            "#! [no_std]"
          ]
        },
        {
          "title": "Flowcharts – Basic Syntax",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/flowchart.html",
          "excerpts": [
            "May 22, 2025 — The Mermaid code defines how nodes and edges are made and accommodates different arrow types, multi-directional arrows, and any linking to and ..."
          ]
        },
        {
          "title": "State diagrams | Mermaid",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/stateDiagram.html",
          "excerpts": [
            "Apr 11, 2025 — Composite states ​. In a real world use of state diagrams you often end up with diagrams that are multidimensional as one state can have several ...",
            "Apr 11, 2025 — These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 ...",
            "Apr 11, 2025 — Mermaid can render state diagrams. The syntax tries to be compliant with the syntax used in plantUml as this will make it easier for users to share diagrams."
          ]
        },
        {
          "title": "Directives",
          "url": "https://mermaid.js.org/config/directives",
          "excerpts": [
            "Changing Sequence diagram config via directive ​. Some common sequence diagram configurations are: width: number; height: number; messageAlign: left, center, ..."
          ]
        },
        {
          "title": "Diagram Syntax",
          "url": "https://mermaid.js.org/intro/syntax-reference.html",
          "excerpts": [
            "Mermaid's syntax is used to create diagrams. You'll find that it is not too tricky and can be learned in a day."
          ]
        },
        {
          "title": "Composite states using stateDiagram-v2 cant handle ...",
          "url": "https://github.com/mermaid-js/mermaid/issues/2026",
          "excerpts": [
            "Apr 30, 2021 — Composite states using stateDiagram-v2 cant handle descriptions. This diagram generates syntax error: stateDiagram-v2 state \"Not Shooting ..."
          ]
        },
        {
          "title": "Is there a list of supported mermaid diagram types ...",
          "url": "https://forum.obsidian.md/t/is-there-a-list-of-supported-mermaid-diagram-types-anywhere/62721",
          "excerpts": [
            "Jul 7, 2023 — Flowcharts Syntax | Mermaid. Create diagrams and visualizations using text and code. If are interested in themes with mermaid support, check out ..."
          ]
        },
        {
          "title": "Mermaid diagrams are now supported in code block. Use ...",
          "url": "https://www.reddit.com/r/Notion/comments/rmppnt/mermaid_diagrams_are_now_supported_in_code_block/",
          "excerpts": [
            "Mermaid diagrams are now supported in code block. Use Flowchart, Sequence diagram, Class diagram, State diagram, Entity relationship diagram ..."
          ]
        },
        {
          "title": "Progressive Disclosure",
          "url": "https://www.nngroup.com/articles/progressive-disclosure/",
          "excerpts": [
            "Dec 3, 2006 — Progressive disclosure defers advanced or rarely used features to a secondary screen, making applications easier to learn and less error-prone."
          ]
        },
        {
          "title": "Evidence-based pedagogy",
          "url": "https://stileeducation.com/us/why-choose-stile/evidence-based-pedagogy/",
          "excerpts": [
            "Stile is the ultimate Curriculum to encourage evidence-based teaching strategies. Learn more about the proven strategies that underpin everything we do!"
          ]
        },
        {
          "title": "Dual Coding Theory: The Complete Guide for Teachers",
          "url": "https://www.educationcorner.com/dual-coding-theory/",
          "excerpts": [
            "Dual coding theory explains and simplifies how we can teach students to get information into their long term memory easier and retrieve the ..."
          ]
        },
        {
          "title": "Cognitive Load Theory | Dual Coding: A Teacher's Guide",
          "url": "https://www.structural-learning.com/post/dual-coding-a-teachers-guide",
          "excerpts": [
            "Dual Coding is a research-backed learning strategy that enhances student understanding by combining verbal and visual information."
          ]
        },
        {
          "title": "Progressive Disclosure | I'd Rather Be Writing Blog and API ...",
          "url": "https://idratherbewriting.com/ucd-progressive-disclosure/",
          "excerpts": [
            "On this blog, I write about topics related to technical writing and communication — such as software documentation, API documentation, AI, information ..."
          ]
        },
        {
          "title": "The smallest #![no_std] program - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html",
          "excerpts": [
            "#![no_std] is a crate level attribute that indicates that the crate will link to the core crate instead of the std crate.See more"
          ]
        },
        {
          "title": "Full article: The effect of worked examples on learning solution steps ...",
          "url": "https://www.tandfonline.com/doi/full/10.1080/01443410.2023.2273762",
          "excerpts": [
            "The worked example effect has been well documented within the framework of Cognitive Load Theory (CLT), which suggests that teaching with ..."
          ]
        },
        {
          "title": "Computer Science Pedagogical Content Knowledge ...",
          "url": "https://dl.acm.org/doi/fullHtml/10.1145/3303770",
          "excerpts": [
            "by A Yadav · 2019 · Cited by 90 — The goal of this study was to design and administer a measure to characterize teachers' computer science pedagogical content knowledge performance."
          ]
        },
        {
          "title": "Mermaid Documentation and Mermaid OSS",
          "url": "https://docs.mermaidchart.com/mermaid-oss/syntax/sequenceDiagram.html",
          "excerpts": [
            "Apr 11, 2025 — A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order. Mermaid can render sequence diagrams. <",
            "Diagram Syntax"
          ]
        },
        {
          "title": "State diagrams",
          "url": "https://mermaid.js.org/syntax/stateDiagram.html",
          "excerpts": [
            "There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it ..."
          ]
        },
        {
          "title": "Directives",
          "url": "https://docs.mermaidchart.com/mermaid-oss/config/directives.html",
          "excerpts": [
            "Apr 11, 2025 — Directives give a diagram author the capability to alter the appearance of a diagram before rendering by changing the applied configuration."
          ]
        },
        {
          "title": "Sequence examples",
          "url": "https://docs.mermaidchart.com/mermaid/sequence/examples",
          "excerpts": [
            "Sequence diagram example  . sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight ..."
          ]
        },
        {
          "title": "Class diagrams | Mermaid",
          "url": "https://mermaid.js.org/syntax/classDiagram.html",
          "excerpts": [
            "A class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system."
          ]
        },
        {
          "title": "mermaid-js/mermaid: Generation of diagrams like ...",
          "url": "https://github.com/mermaid-js/mermaid",
          "excerpts": [
            "Mermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams."
          ]
        },
        {
          "title": "Examples",
          "url": "https://mermaid.js.org/syntax/examples.html",
          "excerpts": [
            "Examples ​. This page contains a collection of examples of diagrams and charts that can be created through mermaid and its myriad applications."
          ]
        },
        {
          "title": "The Embedded Rust book.pdf",
          "url": "https://kolegite.com/EE_library/books_and_lectures/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%80%D0%B0%D0%BD%D0%B5/Rust/The%20Embedded%20Rust%20book.pdf",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust. Programming Language on \"Bare Metal\" embedded systems, such as."
          ]
        },
        {
          "title": "Conventions around no_std · Issue #23 · rust-lang/api-guidelines",
          "url": "https://github.com/rust-lang/api-guidelines/issues/23",
          "excerpts": [
            "I strongly prefer std over with_std or use_std . It aligns better with the optional dependency / implicit feature mechanism. If you have an ..."
          ]
        },
        {
          "title": "Minimum Support Rust Version (MSRV) - Hyper",
          "url": "https://hyper.rs/contrib/msrv/",
          "excerpts": [
            "hyper's current policy is to always support a Rust version at least 6 months old . That is, a compiler version released within the last 6 months can compile hyper. It is possible that an older compiler can work, but that is not guaranteed."
          ]
        },
        {
          "title": "Practical guides on no_std and wasm support - tutorials",
          "url": "https://users.rust-lang.org/t/practical-guides-on-no-std-and-wasm-support/94762",
          "excerpts": [
            "I have drafted a \"Rust no_std Playbook\" summarizing my (admittedly limited) experience on making Rust libraries no_std and WASM supports."
          ]
        },
        {
          "title": "How many of you actually use/look for no_std in crates?",
          "url": "https://www.reddit.com/r/rust/comments/1639zkk/how_many_of_you_actually_uselook_for_no_std_in/",
          "excerpts": [
            "I typically support no_std when authoring libraries that don't actually require std. In the most extreme case I supported embedding lookup tables."
          ]
        },
        {
          "title": "What are binary crate MSRV policy best practices? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/zmv1j9/what_are_binary_crate_msrv_policy_best_practices/",
          "excerpts": [
            "The key thing with a binary is that if your MSRV is \"too new\" for a distro, then the distro can just package an older version of your binary that satisfies ..."
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "The Embedded Rust Book",
            "\n ... "
          ]
        },
        {
          "title": "Conditionally use different types based on no_std",
          "url": "https://users.rust-lang.org/t/conditionally-use-different-types-based-on-no-std/70947",
          "excerpts": [
            "Jan 27, 2022 — no_std isn't a feature of the environment; it is a modifier you can apply to your crate, removing the default dependency of your crate on the std crate."
          ]
        },
        {
          "title": "embedded_hal_mock - Rust",
          "url": "https://docs.rs/embedded-hal-mock",
          "excerpts": [
            "This is a collection of types that implement the embedded-hal traits. The implementations never access real hardware. Instead, the hardware is mocked."
          ]
        },
        {
          "title": "Mermaid Config Schema",
          "url": "http://mermaid.js.org/config/schema-docs/config.html",
          "excerpts": [
            "Create diagrams and visualizations using text and code."
          ]
        },
        {
          "title": "add boxes / containers in mermaid sequence diagram - Stack Overflow",
          "url": "https://stackoverflow.com/questions/60805200/add-boxes-containers-in-mermaid-sequence-diagram",
          "excerpts": [
            "I'm making sequence diagrams with Mermaid, and I find the loop feature very cool, drawing a labeled rectangle around a loop with this code chunk."
          ]
        },
        {
          "title": "Mermaid | Diagramming and charting tool",
          "url": "https://mermaid.js.org/",
          "excerpts": [
            "Missing: classDiagram annotations"
          ]
        },
        {
          "title": "Using worked examples to support novice learners",
          "url": "https://teachcomputing.org/blog/using-worked-examples-to-support-novice-learners/",
          "excerpts": [
            "Worked examples help novice learners in subjects like Maths and Science by showing problem-solving steps alongside practice problems."
          ]
        },
        {
          "title": "What is the rust core crate??",
          "url": "https://www.reddit.com/r/rust/comments/bpmy21/what_is_the_rust_core_crate/",
          "excerpts": [
            "The reason for both is that std is everything the language provides, but core is the subset of that which doesn't require features from the ..."
          ]
        },
        {
          "title": "What's the difference of the module core and std",
          "url": "https://users.rust-lang.org/t/whats-the-difference-of-the-module-core-and-std/2923",
          "excerpts": [
            "Sep 19, 2015 — Core should be self-contained. std depends on core , and a lot of other stuff, to provide a kind of \"facade\" to the end user."
          ]
        },
        {
          "title": "no global memory allocator found but one is required",
          "url": "https://stackoverflow.com/questions/74012369/no-global-memory-allocator-found-but-one-is-required-link-to-std-or-add-glob",
          "excerpts": [
            "If you link with alloc you need to have a global allocator. That is usually provided by std, but if you omit the std crate then you need to provide it yourself."
          ]
        },
        {
          "title": "cortex_m - Rust",
          "url": "https://docs.rs/cortex-m",
          "excerpts": [
            "Low level access to Cortex-M processors. This crate provides: Access to core peripherals like NVIC, SCB and SysTick. Access to core registers like CONTROL, ..."
          ]
        },
        {
          "title": "Help enabling `no-std` feature in a crate - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/help-enabling-no-std-feature-in-a-crate/61192",
          "excerpts": [
            "I want enable a feature in my crate for compile in a no-std environment, for this in the Cargo.toml I have: [dependencies] num = { version = \"0.4\", default- ..."
          ]
        },
        {
          "title": "Clarify std vs no-std · Issue #148 · esp-rs/book",
          "url": "https://github.com/esp-rs/book/issues/148",
          "excerpts": [
            "Mar 13, 2024 — The book currently says: When You Might Want to Use the Core Library (no_std) Small memory footprint: If your embedded system has limited ..."
          ]
        },
        {
          "title": "Similar items in core and std",
          "url": "https://users.rust-lang.org/t/similar-items-in-core-and-std/60167",
          "excerpts": [
            "May 23, 2021 — As a beginner to Rust, I am a bit confused by same (similar ?) items I find in the core and std libraries. For example there is core::iter::iterator and std:: ..."
          ]
        },
        {
          "title": "cortex-m - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cortex-m",
          "excerpts": [
            "This crate is guaranteed to compile on stable Rust 1.38 and up. It might compile with older versions but that may change in any new patch release."
          ]
        },
        {
          "title": "The Rust Alloc crate documentation",
          "url": "https://doc.rust-lang.org/alloc/",
          "excerpts": [
            "). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead.",
            "The Rust core allocation and collections library. This library provides smart pointers and collections for managing heap-allocated values.",
            "The Rust core allocation and collections library",
            "This library, like core, normally doesn’t need to be used directly\nsince its contents are re-exported in the [`std` crate](../std/index.html). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead.",
            "dex.html) module defines the low-level interface to the\ndefault global allocator."
          ]
        },
        {
          "title": "RTT works through probe-run but not through rtthost, nor pyocd",
          "url": "https://github.com/probe-rs/probe-rs/discussions/1237",
          "excerpts": [
            "In contrast, rtt-target is \"plain\" RTT and so should work with rtthost and pyocd, but it means formatting operations have to happen on the embedded system ..."
          ]
        },
        {
          "title": "Utest: Unit `#[test]`ing for microcontrollers and other `no_std` systems",
          "url": "https://users.rust-lang.org/t/utest-unit-test-ing-for-microcontrollers-and-other-no-std-systems/9695",
          "excerpts": [
            "Based on it, I've created two test runners: utest-cortex-m-qemu . A test runner to unit test crates on emulated Cortex-M processors (QEMU user ..."
          ]
        },
        {
          "title": "Embedded Rust (no_std) on Espressif",
          "url": "https://docs.espressif.com/projects/rust/no_std-training/03_7_defmt.html",
          "excerpts": [
            "In this chapter, we will cover [`defmt`](https://defmt.ferrous-systems.com/) , a highly efficient logging framework, and how to use it in the `no_std` environment.",
            "Embedded Rust (no\\_std) on Espressi",
            "no_std environment"
          ]
        },
        {
          "title": "defmt-test - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/defmt-test",
          "excerpts": [
            "Apr 1, 2025 — defmt-test is a test harness for embedded devices that lets you write and run unit tests on your device as if you were using the built-in #[test] attribute."
          ]
        },
        {
          "title": "What is no_std? Is it for things targeting no_std ... - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/what-is-no-std-is-it-for-things-targeting-no-std-or-no-std-compatibility/133156",
          "excerpts": [
            "Do you think that no_std category/tag should be for crates targetting no_std or for things which can be ran/built with no_std?"
          ]
        },
        {
          "title": "How to: Libraries and No-Std - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/how-to-libraries-and-no-std/119455",
          "excerpts": [
            "Reading about the no-std feature I think its a good idea to use no-std instead. So I added #![no_std] at the top and tried to build and test it."
          ]
        },
        {
          "title": "IndexSet in heapless - Rust - Docs.rs",
          "url": "https://docs.rs/heapless/latest/heapless/struct.IndexSet.html",
          "excerpts": [
            "IndexSet is a fixed capacity set, generic around the hashing algorithm, and cannot be used directly. Its capacity must be a power of 2."
          ]
        },
        {
          "title": "embedded_hal_bus - Rust",
          "url": "https://docs.rs/embedded-hal-bus",
          "excerpts": [
            "embedded_hal_bus provides bus sharing utilities for embedded-hal, enabling hardware-independent adapters for sharing a single bus between multiple devices."
          ]
        },
        {
          "title": "heapless - Rust - RIOT Documentation",
          "url": "https://doc.riot-os.org/rustdoc/latest/heapless/index.html",
          "excerpts": [
            "The core principle behind heapless is that its data structures are backed by a static memory allocation. For example, you can think of heapless::Vec as an ..."
          ]
        },
        {
          "title": "defmt_test - Rust",
          "url": "https://docs.rs/defmt-test",
          "excerpts": [
            "A test harness for embedded devices. This crate has a single API: the #[tests] macro. This macro is documented in the project README which can be found at:."
          ]
        },
        {
          "title": "`#![no_alloc]` attribute in 2021 edition? - Rust Internals",
          "url": "https://internals.rust-lang.org/t/no-alloc-attribute-in-2021-edition/13596",
          "excerpts": [
            "#![no_std] does opt-out from both std and alloc. If you need one of those, you opt-in for them using extern crate. You can not use alloc in a no_std crate"
          ]
        },
        {
          "title": "alloc::sync::Arc for core - libs - Rust Internals",
          "url": "https://internals.rust-lang.org/t/alloc-arc-for-core/14368",
          "excerpts": [
            "basically I want core::sync::atomic::AtomicCounter that lets you manually increment or decrement the strong/weak counts and perhaps has some ..."
          ]
        },
        {
          "title": "Making Rust core and alloc panic free - language design",
          "url": "https://internals.rust-lang.org/t/making-rust-core-and-alloc-panic-free/18826",
          "excerpts": [
            "The core and alloc (to some extent) seem to be present to allow using Rust where only basic C or similar low-level language can be used."
          ]
        },
        {
          "title": "Attributes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/attributes.html",
          "excerpts": [
            "Doc comments are transformed into doc attributes. Preludes. no_std — Removes std from the prelude. no_implicit_prelude — Disables prelude lookups within a ..."
          ]
        },
        {
          "title": "defmt_ringbuf - Rust - Docs.rs",
          "url": "https://docs.rs/defmt-ringbuf",
          "excerpts": [
            "defmt-ringbuf is a defmt global logger that logs into a persistent ring buffer. The ring buffer is not cleared at startup."
          ]
        },
        {
          "title": "Embedded Rust tooling for the 21st century",
          "url": "https://ferrous-systems.com/blog/21st-century-embedded-tooling/",
          "excerpts": [
            "In this blog post we'll share our vision for great embedded Rust tooling and share info about the tools we have been building. This is an early ..."
          ]
        },
        {
          "title": "rust-embedded/book: Documentation on how to use the ...",
          "url": "https://github.com/rust-embedded/book",
          "excerpts": [
            "The code samples and free-standing Cargo projects contained within this book are licensed under the terms of both the MIT License and the Apache License v2.0."
          ]
        }
      ],
      "reasoning": "The field captures how persistence is achieved in no_std Rust environments. The most directly relevant information identifies and defines the core abstractions and patterns for non-volatile storage in such contexts: the embedded-storage crate provides the abstraction layer (ReadNorFlash, NorFlash traits) for reading, writing, and erasing non-volatile memory in a platform-agnostic way, which is essential when std is not available. Building on that, the littlefs2 crate implements the LittleFS filesystem (Power-loss resilience through copy-on-write semantics and robust wear distribution), which is particularly suitable for microcontrollers and compact flash-like storage scenarios common in no_std environments. Additional no_std storage options such as sequential-storage and tickv present further approaches for persistent key-value storage with built-in wear leveling and data integrity guarantees (CRC-based checksums). The wear-leveling and power-fail safety patterns described (dynamic/static wear leveling, CRC integrity, copy-on-write semantics) align with the needs of embedded flash storage in constrained environments. Supporting examples also discuss how NVS-era wear leveling is implemented in ESP-IDF, illustrating real-world deployments of wear leveling in flash storage in no_std contexts. The combination of these sources provides a coherent view of how a Rust no_std project can achieve persistent storage: via a core, vendor-agnostic storage trait layer (embedded-storage), backed by a robust filesystem like LittleFS (littlefs2), complemented by alternative no_std storage patterns (sequential-storage, tickv) and CRC-based integrity checks, with wear leveling to extend flash lifespan. This set of excerpts directly supports claims about the architecture and guarantees provided by these crates and patterns, including how power-fail safety, data integrity, and wear leveling are achieved in the no_std embedded Rust ecosystem.",
      "confidence": "high"
    },
    {
      "field": "testing_simulation_and_debugging",
      "citations": [
        {
          "title": "Testing a no_std crate with QEMU and defmt-test? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/14bb0db/testing_a_no_std_crate_with_qemu_and_defmttest/",
          "excerpts": [
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ...",
            "What's the best way to locally test that no_std crate will really work on an embedded processor? I think I want to use the QEMU emulator ..."
          ]
        },
        {
          "title": "barretts.club Embedded Tests",
          "url": "https://barretts.club/posts/embedded-tests/",
          "excerpts": [
            "\n\n`embedded-hal-mock` does precisely that!",
            "The goal of the crate is to be able to test drivers in CI without having access to hardware."
          ]
        },
        {
          "title": "embedded-hal-mock (GitHub) - dbrgn",
          "url": "https://github.com/dbrgn/embedded-hal-mock",
          "excerpts": [
            "Mocks for testing embedded-hal based drivers without hardware access.",
            "Minimum Supported Rust Version (MSRV)",
            "This crate is guaranteed to compile on the latest stable Rust release."
          ]
        },
        {
          "title": "embedded-hal-mock - eh0 module - API docs",
          "url": "https://docs.rs/embedded-hal-mock/latest/i686-unknown-linux-gnu/embedded_hal_mock/eh0/index.html",
          "excerpts": [
            "This is a collection of types that implement the embedded-hal version 0.x\ntraits."
          ]
        },
        {
          "title": "embedded_hal_mock - Rust",
          "url": "https://docs.rs/embedded-hal-mock",
          "excerpts": [
            "This is a collection of types that implement the embedded-hal traits. The implementations never access real hardware. Instead, the hardware is mocked."
          ]
        },
        {
          "title": "Rustno-std testing discussion on The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/can-a-no-std-crate-have-std-dependencies-in-test-cases-only/72982",
          "excerpts": [
            "Integration tests (i.e. tests in the `tests/` directory) are compiled separately from your library and depend on `std` by default. No changes in Cargo.toml are needed.",
            "I am working on a UTF8 / UTF32 conversion crate with no\\_std support. Is it possible for the library itself be no\\_std, but the test cases be std? How would it look like in Cargo.toml file? 1 Li",
            "In practice gating `no_std` causes unpleasant issues related to prelude, especially if your crate has an `std` or `alloc` feature. Previously I was proponent of gating `no_std` , but after hitting several such issues I see the merit of using `extern crate std` . It's easier to think about crate code when `std` and `alloc` are explicit dependencies.",
            "]`\n\nYou should not use this approach. The `extern crate std;` approach is a preferred one.",
            "The `extern crate std;` approach is a preferred one",
            "Nevermind, use\n\n```rust\n#[cfg(test)]\nextern crate std;\n```\n\n1 Like"
          ]
        },
        {
          "title": "How to test code when #![no_std] is set",
          "url": "https://users.rust-lang.org/t/how-to-test-code-when-no-std-is-set/93180",
          "excerpts": [
            "Apr 27, 2023 — This post explores unit and integration testing in no_std executables. We will use Rust's support for custom test frameworks to execute test functions."
          ]
        },
        {
          "title": "Unit Testing - Writing an OS in Rust",
          "url": "https://os.phil-opp.com/unit-testing/",
          "excerpts": [
            "This post explores unit testing in no_std executables using Rust's built-in test framework. We will adjust our code so that cargo test works."
          ]
        },
        {
          "title": "Features - The Cargo Book - Rust Documentation",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo sets features in the package using the rustc --cfg flag, and code can test for their presence with the cfg attribute or the cfg macro. Features can list ...",
            "For example, if you want to optionally support no_std environments, do not use a no_std feature. Instead, use a std feature that enables std . For example: #!["
          ]
        },
        {
          "title": "PSA for `std` Feature in `no_std` Libraries : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1hs6spy/psa_for_std_feature_in_no_std_libraries/",
          "excerpts": [
            "If you declare your crate as unconditionally no_std, with a feature flag to include the std crate, you'll always have the core::prelude, making your code much ...",
            "Instead, if you declare your crate as unconditionally `no_std`, with a feature flag to include the `std` crate, you'll *always* have the `core::prelude`, making your code much more consistent between the two features.",
            "Tl;dr: don't use `#! [cfg_attr(not(feature = \"std\"), no_std)]` to have an `std` feature, always use:",
            "One line at the top of the crate, and (while wordy) it makes sense. *If I don't have the* `std` *feature, then I'm* `no_std`. However, this has a side-effect that can make working with the `alloc` crate a massive pain: enabling or disabling the `std` feature changes the [implicit prelude](https://doc.rust-lang.org/reference/names/preludes.html) between `std::prelude` and `core::prelude`.",
            " PSA for `std` Feature in `no\\_std` Libraries : r/rust",
            "#!\n[no_std",
            "#!\n[no_std",
            "#[cfg(feature = \"std\")]",
            "#[cfg(feature = \"std\")]",
            "extern crate std;",
            "extern crate std;",
            "Read more",
            "```",
            "```"
          ]
        },
        {
          "title": "riscv_rt - Rust",
          "url": "https://docs.rs/riscv-rt",
          "excerpts": [
            "#!\n[no_std",
            "```",
            "```",
            "#! [no_main",
            "extern crate panic_halt;",
            "fn main() -> ! {",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "#!\n[no_std",
            "#!\n[no_std",
            "#! [no_main]",
            "```",
            "```",
            "```",
            "The panicking message is logged to the host using the semihosting technique. You may be able to find even more crates searching for the panic-handler keyword on ...",
            "* [`panic-semihosting`](https://crates.io/crates/panic-semihosting) . The panicking message is logged to the host using the\n  semihosting techniqu",
            "* [`panic-itm`](https://crates.io/crates/panic-itm) . The panicking message is logged using the ITM, an ARM Cortex-M\n  specific periphera",
            "Some examples include:\n\n* [`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the abort instruction to be executed. * [`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the program, or the current thread, to halt by\n  entering an infinite loop. * [`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is logged using the ITM, an ARM Cortex-M\n  specific peripheral. * [`panic-semihosting`](https://crates.io/crates/panic-semihosting). The panicking message is logged to the host using the\n  semihosting technique. You may be able to find even more crates searching for the [`panic-handler`](https://crates.io/keywords/panic-handler)\nkeyword on crat",
            "* [`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is logged using the ITM, an ARM Cortex-M\n  specific periphera",
            "* [`panic-semihosting`](https://crates.io/crates/panic-semihosting). The panicking message is logged to the host using the\n  semihosting techniqu",
            "You may be able to find even more crates searching for the [`panic-handler`](https://crates.io/keywords/panic-handler)\nkeyword on crates.io.",
            "#! [no_main",
            "    loop {}",
            "}"
          ]
        },
        {
          "title": "RTIC and no_std guidance with lock-free patterns",
          "url": "https://rtic.rs/1/book/en/by-example/tips_static_lifetimes.html",
          "excerpts": [
            "#!\n[no_std",
            "#! [no_main]",
            "#! [no_main"
          ]
        },
        {
          "title": "Is there a way to use USART with DMA and Interrupt - embedded - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/is-there-a-way-to-use-usart-with-dma-and-interrupt/61215",
          "excerpts": [
            "#!\n[no_std",
            "#! [no_main"
          ]
        },
        {
          "title": "Cfg item for detecting no_std builds - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/cfg-item-for-detecting-no-std-builds/14783",
          "excerpts": [
            "A std feature goes a long way to communicating that a crate supports conditional no_std. This could be just replaced with the advertising of implicit no_std ..."
          ]
        },
        {
          "title": "Is there any point in avoiding std when testing a no_std library?",
          "url": "https://users.rust-lang.org/t/is-there-any-point-in-avoiding-std-when-testing-a-no-std-library/122731",
          "excerpts": [
            "If your library is no_std because it's pure functionality with no OS interaction, then it should run the same whether std is there or not, and therefore ..."
          ]
        },
        {
          "title": "Is it possible to enable a rust feature only in test? - Stack Overflow",
          "url": "https://stackoverflow.com/questions/68618789/is-it-possible-to-enable-a-rust-feature-only-in-test",
          "excerpts": [
            "This is a [requested feature](https://github.com/rust-lang/cargo/issues/2911) of Cargo and is only possible using the [version 2 resolver](https://doc.rust-lang.org/nightly/cargo/reference/features.html). If crate A has the function you mentioned, then crate B's `Cargo.toml` may contain",
            "[package]",
            "name = \"B\"",
            "resolver = \"2\"",
            "[features]",
            "test-utils = []",
            "[dependencies]",
            "A = \"*\"",
            "[dev-dependencies]",
            "A = { version = \"*\", features = [\"test-utils\"] }",
            "B = { path = \". \", features = [\"test-utils\"] }",
            "This would ensure that both crates are built with the `test-utils` feature *only* when testing them.",
            "```"
          ]
        },
        {
          "title": "The Embedded Rust Book - QEMU and no_std guidance",
          "url": "https://docs.rust-embedded.org/book/start/qemu.html",
          "excerpts": [
            "sole\nqemu-system-arm \\\n  -cpu cortex-m3 \\\n  -machine lm3s6965evb \\\n  -nographic \\\n  -semihosting-config enable=on,target=native \\\n  -kernel target/thumbv7m-none-eabi/debug/examples/hello",
            "This is the QEMU emulator. There are a few variants of these QEMU binaries; this one does full system emulation of ARM machines hence the name. -cpu cortex ...",
            "```"
          ]
        },
        {
          "title": "How to cleanly exit QEMU after executing bare metal ...",
          "url": "https://stackoverflow.com/questions/31990487/how-to-cleanly-exit-qemu-after-executing-bare-metal-program-without-user-interve",
          "excerpts": [
            "Don't forget to run QEMU with -semihosting argument, like this: qemu-system-arm -nographic -semihosting -kernel your_binary. Here is the code ..."
          ]
        },
        {
          "title": "Emulation — QEMU documentation",
          "url": "https://www.qemu.org/docs/master/about/emulation.html",
          "excerpts": [
            "QEMU's implementation allows for semihosting calls to be passed to the host system or via the gdbstub . Generally semihosting makes it easier to bring up low ..."
          ]
        },
        {
          "title": "Qemu baremetal emulation - how to view UART output?",
          "url": "https://stackoverflow.com/questions/60552355/qemu-baremetal-emulation-how-to-view-uart-output",
          "excerpts": [
            "I want to be able to capture the output of messages sent to UART. If this is done by redirecting to stdout, that's fine. If it goes through a TCP socket, that' ..."
          ]
        },
        {
          "title": "QEMU Semihosting not working when building QEMU from Source",
          "url": "https://stackoverflow.com/questions/75326323/qemu-semihosting-not-working-when-building-qemu-from-source",
          "excerpts": [
            "I'm emulating a Cortex-M33 using QEMU on a linux host. I've installed QEMU using sudo apt-get qemu-system-arm and semihosting is working fine (printf and file ..."
          ]
        },
        {
          "title": "How to start qemu directly in the console (*not* in curses or ...",
          "url": "https://serverfault.com/questions/471719/how-to-start-qemu-directly-in-the-console-not-in-curses-or-sdl",
          "excerpts": [
            "Jan 23, 2013 — Short anwser : qemu -nographic -serial mon:stdio -append 'console=ttyS0' binary.img ttyS0 valid on most PC. it would be something different on ARM system."
          ]
        },
        {
          "title": "QEMU User Documentation",
          "url": "https://www.qemu.org/docs/master/system/qemu-manpage.html",
          "excerpts": [
            "See the -semihosting-config option documentation for further information about the facilities this enables. -semihosting-config [enable=on ..."
          ]
        },
        {
          "title": "meyerzinn.tech post on running Rust code on RISC-V in QEMU",
          "url": "https://meyerzinn.tech/posts/2023/03/05/running-rust-code-on-risc-v-in-qemu/",
          "excerpts": [
            "Add a `runner` to your `.cargo/config.toml` file:",
            "```\n# .cargo/config.toml\n\n# ... from before\n\n[target.riscv32imac-unknown-none-elf]\nrunner = \"\"\" qemu-system-riscv32\n  -cpu rv32\n  -machine virt\n  -m 150M\n  -s\n  -nographic\n  -bios \"\"\"\n\n```\n\nWe’ll add more flags as our kernel becomes more complete, but we’ll start with the basics:",
            "#! [no_std]"
          ]
        },
        {
          "title": "Documentation/Platforms/ARM",
          "url": "https://wiki.qemu.org/Documentation/Platforms/ARM",
          "excerpts": [
            "Mar 22, 2021 — QEMU has generally good support for ARM guests. It has support for nearly fifty different machines. The reason we support so many is that ARM hardware is much ..."
          ]
        },
        {
          "title": "japaric-archived/lm3s6965evb: An example of running a ` ...",
          "url": "https://github.com/japaric-archived/lm3s6965evb",
          "excerpts": [
            "This Cargo project demonstrates how to debug a Rust program running on qemu-system-arm . Try it yourself. Build the example program. $ # from ..."
          ]
        },
        {
          "title": "FreeRTOS MPS2 QEMU Demo (Arm Cortex-M3) For both ...",
          "url": "https://key.freertos.org/freertos-on-qemu-mps2-an385-model.html",
          "excerpts": [
            "[RTOS Ports]. This page documents a FreeRTOS kernel demo that targets the Arm Cortex-M3 mps2-an385 QEMU external_link model. Preconfigured build projects ..."
          ]
        },
        {
          "title": "Stellaris boards (lm3s6965evb, lm3s811evb)",
          "url": "https://www.qemu.org/docs/master/system/arm/stellaris.html",
          "excerpts": [
            "The Luminary Micro Stellaris LM3S6965EVB emulation includes the following devices: Cortex-M3 CPU core. 256k Flash and 64k SRAM. Timers, UARTs, ADC, I2 ..."
          ]
        },
        {
          "title": "How do I write a bare-metal RISC-V program to go from ...",
          "url": "https://stackoverflow.com/questions/74901787/how-do-i-write-a-bare-metal-risc-v-program-to-go-from-boot-to-writing-to-the-uar",
          "excerpts": [
            "I would like to write a program which writes \"Hello World\" to the UART0 device, and then halts (either with a busy loop, or somehow by powering off the board)."
          ]
        },
        {
          "title": "Failed to run Ubuntu/Debian on QEMU RISC-V #29",
          "url": "https://github.com/riscvarchive/risc-v-getting-started-guide/issues/29",
          "excerpts": [
            "I followed the instructions in RISC-V getting started guide with #26 and #28 to run Ubuntu/Debian on QEMU RISC-V. But failed to do that."
          ]
        },
        {
          "title": "How to Emulate Playdate (Arm) with QEMU",
          "url": "https://devforum.play.date/t/how-to-emulate-playdate-arm-with-qemu/11538",
          "excerpts": [
            "May 26, 2023 — QEMU has support for the Cortex-M3 (specifically the board mps2-an385 ); while the Playdate uses the Cortex-M7, these are similar enough -- they ..."
          ]
        },
        {
          "title": "Bare metal RISC-V assembly hello world",
          "url": "https://github.com/noteed/riscv-hello-asm",
          "excerpts": [
            "This is a bare metal 64-bit RISC-V assembly program outputing Hello. It is compiled with the riscv-gnu-toolchain and can be run with the QEMU sifive_u and ..."
          ]
        },
        {
          "title": "How to load my RISC-V executable code to a particular ...",
          "url": "https://www.reddit.com/r/RISCV/comments/1dgd4mq/how_to_load_my_riscv_executable_code_to_a/",
          "excerpts": [
            "I realized that the boot process of qemu is different than x86 systems, and Qemu directly starts executing the code from location 0x80000000.See more"
          ]
        },
        {
          "title": "Road to testing applications on RISC-V with QEMU and ...",
          "url": "https://www.youtube.com/watch?v=6qsLVq3XyGk",
          "excerpts": [
            "At the moment it might be challenging to get real RISC-V hardware, however there is an alternative by using emulators such as QEMU. This ..."
          ]
        },
        {
          "title": "Hello, RISC-V and QEMU",
          "url": "https://mth.st/blog/riscv-qemu/",
          "excerpts": [
            "Oct 28, 2020 — I've been trying to run and debug RISC-V binaries using QEMU. This post covers things I'm unsure of and a topic I don't know much about.See more"
          ]
        },
        {
          "title": "The RISC-V QEMU port is upstream",
          "url": "https://www.sifive.com/blog/risc-v-qemu-part-2-the-risc-v-qemu-port-is-upstream",
          "excerpts": [
            "QEMU 2.12.0 was released on April 24th 2018 and this version is the first official QEMU version to contain the RISC-V port.",
            "Apr 25, 2018 — The virt machine models a Generic RISC-V Virtual machine with support for the VirtIO standard networking and block storage devices. ... example ..."
          ]
        },
        {
          "title": "probe-rs and cargo-embed - Comprehensive Rust - Google",
          "url": "https://google.github.io/comprehensive-rust/bare-metal/microcontrollers/probe-rs.html",
          "excerpts": [
            "cargo-embed is a cargo subcommand to build and flash binaries, log RTT (Real Time Transfers) output and connect GDB. It's configured by an Embed.toml file in ..."
          ]
        },
        {
          "title": "Cannot Debug or Attach to STM32F4 Using Probe-RS",
          "url": "https://users.rust-lang.org/t/cannot-debug-or-attach-to-stm32f4-using-probe-rs/129729",
          "excerpts": [
            "May 19, 2025 — I am able to flash and erase and program the chip using cargo embed, but attempting to step through the instructions using probe-rs does not work."
          ]
        },
        {
          "title": "Rust Tools and Resources for Embedded - EEVblog",
          "url": "https://www.eevblog.com/forum/microcontrollers/rust-tools-and-resources-for-embedded/",
          "excerpts": [
            "cargo-flash: downloads the code to the MCU, starts it, and returns cargo-embed: downloads the code to the MCU, starts it, open RTT terminal ..."
          ]
        },
        {
          "title": "default.toml - probe-rs/cargo-embed - GitHub",
          "url": "https://github.com/probe-rs/cargo-embed/blob/master/src/config/default.toml",
          "excerpts": [
            "Jan 14, 2023 — The target handles RTT outputs that won't fit in the buffer. This can be overridden per-channel. If left unset, the firmware will determine the default for ..."
          ]
        },
        {
          "title": "Debugger",
          "url": "https://probe.rs/docs/tools/debugger/",
          "excerpts": [
            "The probe-rs VS Code extension uses the Microsoft Debug Adapter Protocol to implement an interactive debugging experience between VS Code and a probe-rs target."
          ]
        },
        {
          "title": "Releases · probe-rs/probe-rs",
          "url": "https://github.com/probe-rs/probe-rs/releases",
          "excerpts": [
            "Fixed nRF91xx memory map: set correct RAM size, added UICR memory region. Fixed an issue where RTT channel modes weren't configured properly (#3364) by @ ..."
          ]
        },
        {
          "title": "Set up hardware-in-loop testing #809 - esp-rs/esp-hal - GitHub",
          "url": "https://github.com/esp-rs/esp-hal/issues/809",
          "excerpts": [
            "I have managed to flash and run tests on-device using teleprobe / probe-rs and defmt , so we're unblocked and back on track here.",
            "Sep 21, 2023 — I have managed to flash and run tests on-device using teleprobe / probe-rs and defmt , so we're unblocked and back on track here."
          ]
        },
        {
          "title": "Debugging with `probe-rs` and VS code: and nRF52840",
          "url": "https://users.rust-lang.org/t/debugging-with-probe-rs-and-vs-code-and-nrf52840-cant-set-breakpoints/108566",
          "excerpts": [
            "Mar 19, 2024 — I'm trying to debug a program on a NordicSemi nRF52840 controller. So far I followed the instructions at hackmd.io and from the probe-rs debugging docu."
          ]
        },
        {
          "title": "probe-rs",
          "url": "https://probe.rs/",
          "excerpts": [
            "Run a program on your microchip with the ease of a native application. Easily print to STDOUT via RTT and defmt encoding when using probe-rs run."
          ]
        },
        {
          "title": "run - probe-rs",
          "url": "https://probe.rs/docs/tools/probe-rs/",
          "excerpts": [
            "The probe-rs CLI utility features many subcommands which are explained in the sections in this document. The most commonly used one is the probe-rs run ..."
          ]
        },
        {
          "title": "cargo-embed",
          "url": "https://probe.rs/docs/tools/cargo-embed/",
          "excerpts": [
            "cargo-embed is a tool that can flash a target, open an RTT terminal, and a GDB server. It builds binaries, detects probes, and uploads content.",
            "cargo-embed is the big brother of cargo-flash. It can also flash a target just like cargo-flash, but it can also open an RTT terminal as well as a GDB server."
          ]
        },
        {
          "title": "probe_rs - Rust",
          "url": "https://docs.rs/probe-rs",
          "excerpts": [
            "Debugging toolset for embedded devices. Prerequisites, Examples, Halting the attached chip. use probe_rs::probe::{list::Lister, Probe};"
          ]
        },
        {
          "title": "probe-rs - The Rust on ESP Book",
          "url": "https://docs.esp-rs.org/book/tooling/debugging/probe-rs.html",
          "excerpts": [
            "The probe-rs project is a set of tools to interact with embedded MCU's using various debug probes. It is similar to OpenOCD, pyOCD, Segger tools, etc."
          ]
        },
        {
          "title": "probe-rs-cli - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/probe-rs-cli",
          "excerpts": [
            "Install. cargo install probe-rs-cli. Running the above command will globally install the probe-rs-cli binary. Documentation. docs.rs/probe-rs ..."
          ]
        },
        {
          "title": "probe-rs Basics and Ecosystem Documentation",
          "url": "https://probe.rs/docs/library/basics/",
          "excerpts": [
            "The Probe struct represents the physical probe in code form. To list available probes, use the Lister struct."
          ]
        },
        {
          "title": "Probe-rs",
          "url": "https://github.com/probe-rs/probe-rs",
          "excerpts": [
            "The goal of this library is to provide a toolkit to interact with a variety of embedded MCUs and debug probes and provides a direct interface to the debug probe ..."
          ]
        },
        {
          "title": "Conditional Compilation in Rust",
          "url": "https://doc.rust-lang.org/reference/conditional-compilation.html",
          "excerpts": [
            "The `cfg` attribute is allowed anywhere attributes are allowed.",
            "The `cfg_attr` [attribute](attributes.html) conditionally includes [attributes](attributes.html) based on a\nconfiguration predi",
            ")\n\nKey-value option set to further disambiguate the `target_env` with information\nabout the target ABI. [[cfg .target\\_abi .dis",
            "### [`target_arch`]()",
            "* `\"x86\"`",
            "* `\"x86\"`",
            "* `\"x86_64\"`",
            "* `\"x86_64\"`",
            "* `\"mips\"`",
            "* `\"mips\"`",
            "* `\"powerpc\"`",
            "* `\"powerpc\"`",
            "* `\"powerpc64\"`",
            "* `\"powerpc64\"`",
            "* `\"arm\"`",
            "* `\"arm\"`",
            "* `\"aarch64\"`",
            "* `\"aarch64\"`",
            "### [`target_os`]()",
            "* `\"macos\"`",
            "* `\"ios\"`",
            "* `\"linux\"`",
            "* `\"android\"`",
            "* `\"none\"` (typical for embedded targets)",
            "### [`target_family`]()",
            "* `\"unix\"`",
            "* `\"windows\"`",
            "* `\"windows\"`",
            "* `\"wasm\"`",
            "* Both `\"unix\"` and `\"wasm\"`",
            "### [`target_has_atomic`]()",
            "### [`target_endian`]()",
            "Key-value option set once with either a value of “little” or “big” depending\non the endianness of the target’s",
            "* `\"16\"`",
            "* `\"16\"`",
            "* `\"32\"`",
            "* `\"32\"`",
            "* `\"64\"`",
            "* `\"64\"`",
            "### [`target_vendor`]()",
            "* `\"apple\"`",
            "* `\"fortanix\"`",
            "* `\"pc\"`",
            "* `\"unknown\"`",
            "### [`target_env`]()",
            "* `\"gnu\"`",
            "* `\"msvc\"`",
            "* `\"musl\"`",
            "* `\"sgx\"`",
            "### [`target_abi`]()",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "Example values:",
            "* `\"\"`",
            "* `\"\"`",
            "* `\"llvm\"`",
            "* `\"eabihf\"`",
            "* `\"abi64\"`",
            "* `\"sim\"`",
            "* `\"macabi\"`",
            "\n### [`target_endian`]",
            "### [`target_pointer_width`]()",
            "### [`target_pointer_width`]()",
            "The `cfg_attr` [attribute](attributes.html) conditionally includes [attributes](attributes.html) based on a\nconfiguration predicate. [[cfg .cfg\\_attr .behaviour]",
            "Zero, one, or more attributes may be listed. Multiple attributes will each be\nexpanded into separate attributes.",
            "The `cfg_attr` attribute is allowed anywhere attributes are allowed. The [`crate_type`](linkage.html) and [`crate_name`](crates-and-source-files.html) attributes cannot be used with `cfg_attr` . [[cfg .macro]",
            "### [The `cfg` macro]()",
            "The built-in `cfg` macro takes in a single configuration predicate and evaluates\nto the `true` literal when the predicate is true and the `false` literal when\nit is false. For example:"
          ]
        },
        {
          "title": "Rust Conditional Compilation",
          "url": "https://dev-doc.rust-lang.org/beta/reference/conditional-compilation.html",
          "excerpts": [
            "For example, target_arch = \"x86_64\" is a configuration option.",
            ". Note: Whitespace around the = is ignored. foo=\"bar\" and foo = \"bar\" are equivalent ... `)`",
            ">\n> *ConfigurationNot*  \n>    `not` `(` *ConfigurationPredicate* `)`",
            ">",
            ">",
            " `)`\n>\n> *ConfigurationPredicateList*  \n>    *ConfigurationPredicate* (`,` *ConfigurationPredicate*)\\* `,`? *Conditionally compiled source code* is source code that may or may not be\nconsidered a part of the source code depending on certain conditions. Source code can be conditionally compiled\nusing the [attributes](attributes.html) [`cfg`]() and [`cfg_attr`]() and the built-in [`cfg` macro](). These conditions are based on the target architecture of the compiled crate,\narbitrary values passed to the compiler, and a few other miscellaneous things\nfurther described below in detail. Each form of conditional compilation takes a *configuration predicate* that\nevaluates to true or false. The predicate is one of the following:\n",
            "### [`target_arch`]()\n\nKey-value option set once with the target's CPU architecture. The value is\nsimilar to the first element of the platform's target triple, but not\nidentical. Example values:\n\n* `\"x86\"`\n* `\"x86_64\"`\n* `\"mips\"`\n* `\"powerpc\"`\n* `\"powerpc64\"`\n* `\"arm\"`\n* `\"aarch64\"`",
            "### [`target_os`]()\n\nKey-value option set once with the target's operating system. This value is\nsimilar to the second and third element of the platform's target triple.\nExample values:\n\n* `\"windows\"`\n* `\"macos\"`\n* `\"ios\"`\n* `\"linux\"`\n* `\"android\"`\n* `\"freebsd\"`\n* `\"dragonfly\"`\n* `\"openbsd\"`\n* `\"netbsd\"`\n* `\"none\"` (typical for embedded targets)",
            "### [`target_family`]()\n\nKey-value option providing a more generic description of a target, such as the family of the\noperating systems or architectures that the target generally falls into. Any number of\n`target_family` key-value pairs can be set. Example values:\n\n* `\"unix\"`\n* `\"windows\"`\n* `\"wasm\"`",
            "### [`target_endian`]()\n\nKey-value option set once with either a value of \"little\" or \"big\" depending\non the endianness of the target's CPU.",
            "### [`target_pointer_width`]()\n\nKey-value option set once with the target's pointer width in bits.\nExample values:\n\n* `\"16\"`\n* `\"32\"`\n* `\"64\"`",
            "### [`target_vendor`]()\n\nKey-value option set once with the vendor of the target. Example values:\n\n* `\"apple\"`\n* `\"fortanix\"`\n* `\"pc\"`\n* `\"unknown\"`",
            "### [`target_has_atomic`]()\n\nKey-value option set for each bit width that the target supports\natomic loads, stores, and compare-and-swap operations. When this cfg is present, all of the stable [`core::sync::atomic`](../core/sync/atomic/index.html) APIs are available for\nthe relevant atomic width. Possible values:\n\n* `\"8\"`\n* `\"16\"`\n* `\"32\"`\n* `\"64\"`\n* `\"128\"`\n* `\"ptr\"`",
            "butes.html))\\* `,`? The `cfg_attr` [attribute](attributes.html) conditionally includes [attributes](attributes.html) based on a\nconfiguration predicate. When the configuration predicate is true, this attribute expands out to the\nattributes listed after the predicate. For example, the following module will\neither be found at `linux.rs` or `windows.rs` based on the target.\n```\n#[cfg_attr(target_os = \"linux\", path = \"linux.rs\")]\n#[cfg_attr(windows, path = \"windows.rs\")]\nmod os;\n```\n",
            "### [The `cfg` macro]()\n\nThe built-in `cfg` macro takes in a single configuration predicate and evaluates\nto the `true` literal when the predicate is true and the `false` literal when\nit is false. For example:\n\n```\n\n\n```\n#! [allow(unused)]\nfn main() {\nlet machine_kind = if cfg! (unix) {\n  \"unix\"\n} else if cfg! (windows) {\n  \"windows\"\n} else {\n  \"unknown\"\n};\n\nprintln! (\"I'm running on a {} machine! \", machine_kind);\n}\n```\n",
            ".\n}\n\n}\n```\n\n\n```\n\nThe `cfg` attribute is allowed anywhere attributes are allowed. ### [The `cfg_attr` attribute]()\n\n> **Syntax**  \n> *CfgAttrAttribute* :  \n>    `cfg_attr` `(` *ConfigurationPredicate* `,` *CfgAttrs*? `)`\n>\n> *CfgAttrs* :  \n>    [*Attr*](attributes.html)",
            "Zero, one, or more attributes may be listed. Multiple attributes will each be\nexpanded into separate attributes. For example:\n\n```\n#[cfg_attr(feature = \"magic\", sparkles, crackles)]\nfn bewitched() {}\n\n// When the `magic` feature flag is enabled, the above will expand to:\n#[sparkles]\n#[crackles]\nfn bewitched() {}\n```\n"
          ]
        },
        {
          "title": "Rust RFC 3239 cfg-target",
          "url": "https://rust-lang.github.io/rfcs/3239-cfg-target.html",
          "excerpts": [
            "This proposes a new cfg:target, which matches the entire target triple string (eg arm-unknown-linux-gnueabihf). This also adds a CARGO_CFG_TARGET environment ... Adding a build script\nincreases compile time and makes a crate incompatible with certain build\nsystems",
            ". Note that the target ABI cannot currently be\n`#[cfg]`-ed against, so a `build.rs` is still necessary to match all target\ncomponents.",
            "``\n\nThis includes `#[cfg_attr(target = \"...\", attr)]`. It would also support to specify each `target_*` inside a new `target`\nattribute as follows:",
            "```\n\nThis includes `#[cfg_attr(target = \"...\", attr)]`. It would also support to specify each `target_*` inside a new `target`\nattribute as follows:",
            "---\n\nThe shorthand form of `#[cfg(target(os = \"linux))]` is expanded and entirely\nequivalent to `#[cfg(target_os = \"linux\")]` (and so on for `arch` and the other\npotential attributes)."
          ]
        },
        {
          "title": "defmt-test - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/defmt-test",
          "excerpts": [
            "Apr 1, 2025 — defmt-test is a test harness for embedded devices that lets you write and run unit tests on your device as if you were using the built-in #[test] attribute."
          ]
        },
        {
          "title": "defmt_test - Rust",
          "url": "https://docs.rs/defmt-test",
          "excerpts": [
            "A test harness for embedded devices. This crate has a single API: the #[tests] macro. This macro is documented in the project README which can be found at:."
          ]
        },
        {
          "title": "defmt-decoder - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/defmt-decoder",
          "excerpts": [
            "This library is for decoding defmt frames into formatted strings. It is used by defmt-print and other tools. MSRV. The minimum supported Rust ..."
          ]
        },
        {
          "title": "defmt (embedded logging and panic handling) - Source Summary",
          "url": "https://defmt.ferrous-systems.com/",
          "excerpts": [
            "This library can be added to an Embedded Rust application to provide an\nimplementation of `#[panic_handler]`. It can optionally route the\n`core::panic::PanicInfo` structure over RTT (using the `rtt_target` crate) or\nover defmt (using the `defmt` ",
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers.Se",
            "`defmt` achieves high performance using deferred formatting and string compression. Deferred formatting means that formatting is not done on the machine that's logging data but on a second machine.",
            "is library is a *logging transport* for `defmt` that sends data over\nSEGGER's RTT transport protocol. This is a good choice when using `probe-rs` because support is built-in to that\nrunner.",
            "\n\nThis library is a *logging transport* for defmt that sends data over\n*semihosting* calls (i.e. breakpoints that wake up your debugger). You should only use this when running firmware inside QEMU, because otherwise\nit's very slow.",
            "\n\nThe `defmt` crate runs on your microcontroller or other target device. It\nexports macros, like `info!` that libraries can use to emit logging messages",
            "er]`. It can optionally route the\n`core::panic::PanicInfo` structure over RTT (using the `rtt_target` crate) or\nover defmt (using the `defmt` crate)",
            "The defmt-print CLI program uses defmt-decoder to turn defmt log frames into human-readable Unicode text. You can use this if your log frames aren't coming via ...",
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers."
          ]
        },
        {
          "title": "defmt Repository",
          "url": "https://github.com/knurling-rs/defmt",
          "excerpts": [
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, like microcontrollers.",
            "/defmt) | On-target code for highly efficient logging"
          ]
        },
        {
          "title": "Defmt Setup",
          "url": "https://defmt.ferrous-systems.com/setup",
          "excerpts": [
            "By default, only ERROR level messages are logged. To learn how to enable other logging levels and filters logs per modules read the [Filtering section](./filtering.html) . ",
            "* [`defmt-rtt`](https://docs.rs/defmt-rtt/) , logs over RTT. Note that this crate can _not_ be used together with `rtt-target` . * [`defmt-itm`](https://docs.rs/defmt-itm/) , logs over ITM (Instrumentation Trace Macrocell) stimulus port 0. * [`defmt-semihosting`](https://github.com/knurling-rs/defmt/tree/6cfd947384debb18a4df761cbe454f8d86cf3441/firmware/defmt-semihosting) , logs over semihosting. Meant only for testing `defmt` on a virtual Cortex-M device (QEMU).",
            "defmt-rtt , logs over RTT. Note that this crate can not be used together with rtt-target . ",
            "defmt-semihosting) , logs over semihosting. Meant only for testing `defmt` on a virtual Cortex-M device (QEMU).",
            "When in a tight memory situation and logging over RTT, the buffer size (default: 1024 bytes) can be configured with the `DEFMT_RTT_BUFFER_SIZE` environment variable. Use a power of 2 for best performance."
          ]
        },
        {
          "title": "Defmt is going to 1.0 - Ferrous Systems",
          "url": "https://ferrous-systems.com/blog/defmt-1-0/",
          "excerpts": [
            "The Reference Logging Transport called defmt-rtt , which sends encoded defmt frames over Segger's Real Time Transport (RTT). RTT is an in-memory ..."
          ]
        },
        {
          "title": "akiles/defmt-rtt-target - GitHub",
          "url": "https://github.com/akiles/defmt-rtt-target",
          "excerpts": [
            "This library exists as an alternate option for when you do need control over RTT, for example to log extra non-defmt data on other channels."
          ]
        },
        {
          "title": "defmt, a highly efficient Rust logging framework for ...",
          "url": "https://ferrous-systems.com/blog/defmt/",
          "excerpts": [
            "Aug 21, 2020 — defmt stands for \"deferred formatting\" and it's a highly efficient logging framework. As we covered in our blog post about embedded tooling for the 21st ...See more",
            "#! [no_main]",
            "use my_app as _; // global logger + panicking-behavior + memory layout",
            "#[cortex_m_rt::entry]",
            "    defmt::info! (\"Hello, world! \");",
            "    my_app::exit()",
            "```",
            "defmt, a highly efficient Rust logging framework for embedded devices",
            "#! [no_std]",
            "fn main() -> ! {",
            "}"
          ]
        },
        {
          "title": "The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/panic-handler.html",
          "excerpts": [
            "```",
            "```",
            "#[panic_handler]",
            "#! [no_std]",
            "extern crate panic_halt;",
            "    loop {}",
            "    loop {}",
            "}",
            "}"
          ]
        },
        {
          "title": "Rust Bindgen no_std FFI and Bindgen Issues discussion",
          "url": "https://github.com/rust-lang/rust-bindgen/issues/1583",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Heapless and Rust Embedded: Portability and Multi-Target/Portability Aspects",
          "url": "http://github.com/rust-embedded/heapless",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "DMA Networking — Matt Keeter Blog",
          "url": "https://www.mattkeeter.com/blog/2023-10-31-dma/",
          "excerpts": [
            "```",
            "```"
          ]
        },
        {
          "title": "smoltcp phy module documentation",
          "url": "https://docs.rs/smoltcp/latest/smoltcp/phy/index.html",
          "excerpts": [
            "```",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Rust Nomicon: Working with Unsafe",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "cortex_m::peripheral - Rust",
          "url": "https://docs.rs/cortex-m/latest/cortex_m/peripheral/index.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Embedded Rust (no_std) on Espressif",
          "url": "https://docs.espressif.com/projects/rust/no_std-training/03_7_defmt.html",
          "excerpts": [
            "In this chapter, we will cover [`defmt`](https://defmt.ferrous-systems.com/) , a highly efficient logging framework, and how to use it in the `no_std` environment.",
            "Embedded Rust (no\\_std) on Espressi",
            "no_std environment"
          ]
        },
        {
          "title": "defmt_ringbuf - Rust - Docs.rs",
          "url": "https://docs.rs/defmt-ringbuf",
          "excerpts": [
            "defmt-ringbuf is a defmt global logger that logs into a persistent ring buffer. The ring buffer is not cleared at startup."
          ]
        },
        {
          "title": "Embedded Rust tooling for the 21st century",
          "url": "https://ferrous-systems.com/blog/21st-century-embedded-tooling/",
          "excerpts": [
            "In this blog post we'll share our vision for great embedded Rust tooling and share info about the tools we have been building. This is an early ..."
          ]
        },
        {
          "title": "rust-embedded/awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "\n11. [`panic-rtt-target`](https://crates.io/crates/panic-rtt-target): Logs panic messages over RTT. Uses `rtt-target`.",
            "s/panic_rtt): Set the panicking behavior to log to a JLINK debugger and loop",
            "d/panic-semihosting): Prints the panic message via semihosting to an attached debugger (Cortex-M only)"
          ]
        },
        {
          "title": "panic_probe - Rust",
          "url": "https://docs.rs/panic-probe",
          "excerpts": [
            "print-defmt : Prints the panic message via defmt's transport (note that defmt will not be used to efficiently format the message). Functions§. hard_fault ...",
            "Panic handler for `probe-run`. When this panic handler is used, panics will make `probe-run` print a backtrace and exit with a\nnon-zero status code, indicating failure. This building block can be used to run on-device\ntests.",
            "By default, `panic-probe` *ignores* the panic message. You can enable one of the following\nfeatures to print it instead:\n\n* `print-rtt`: Prints the panic message over plain RTT (via `rtt-target`). RTT must be\n  initialized by the app. * `print-defmt`: Prints the panic message via [defmt](https://github.com/knurling-rs/defmt/)’s transport (note that defmt will not be\n  used to efficiently format the message). Functions"
          ]
        },
        {
          "title": "panic-probe 1.0.0",
          "url": "https://docs.rs/crate/panic-probe/latest/source/",
          "excerpts": [
            "panic-probe 1.0.0. Panic handler that exits `probe-run` with an error code. Crate · Source · Builds · Feature flags · Documentation."
          ]
        },
        {
          "title": "panic-probe - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/panic-probe",
          "excerpts": [
            "Apr 1, 2025 — Panic handler that exits probe-run with an error code. panic-probe can optionally log the panic message using the defmt logging framework."
          ]
        },
        {
          "title": "panic-probe - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/panic-probe/0.3.2",
          "excerpts": [
            "May 13, 2024 — Panic handler that exits probe-run with an error code. panic-probe can optionally log the panic message using the defmt logging framework."
          ]
        },
        {
          "title": "defmt-rtt",
          "url": "https://lib.rs/crates/defmt-rtt",
          "excerpts": [
            "defmt (\"de format\", short for \"deferred formatting\") is a highly efficient logging framework that targets resource-constrained devices, ...See more"
          ]
        },
        {
          "title": "Customizing log output - defmt book",
          "url": "https://defmt.ferrous-systems.com/custom-log-output",
          "excerpts": [
            "The way a printer outputs logs can be customized by providing a format string to defmt. The format string takes a set of metadata and format specifiers."
          ]
        },
        {
          "title": "probe-rs/rtt-target",
          "url": "https://github.com/probe-rs/rtt-target",
          "excerpts": [
            "Target side implementation of the RTT (Real-Time Transfer) I/O protocol. RTT implements input and output via a debug probe using in-memory ring buffers and ...",
            "RTT implements input and output via a debug probe using in-memory ring buffers and polling. This enables debug logging from the microcontroller with minimal ..."
          ]
        },
        {
          "title": "rtt_target - Rust",
          "url": "https://docs.rs/rtt-target/latest/rtt_target/",
          "excerpts": [
            "rtt_target is a target-side implementation of the RTT I/O protocol, enabling debug logging from the microcontroller with minimal delays."
          ]
        },
        {
          "title": "rtt-target",
          "url": "https://crates.io/crates/rtt-target/versions",
          "excerpts": [
            "Target side implementation of the RTT (Real-Time Transfer) I/O protocol."
          ]
        },
        {
          "title": "CHANGELOG.md - knurling-rs/defmt",
          "url": "https://github.com/knurling-rs/defmt/blob/main/CHANGELOG.md",
          "excerpts": [
            "#350 panic-probe now uses defmt s Display2Format to log panic messages. In consequence, panic messages won't get truncated anymore. #355 Clarify the docs on ..."
          ]
        },
        {
          "title": "cortex_m_semihosting - Rust",
          "url": "https://docs.rs/cortex-m-semihosting",
          "excerpts": [
            "Semihosting operations are very slow. Like, each WRITE operation can take hundreds of milliseconds. §Example. §Using hio::hstdout. This example will demonstrate ..."
          ]
        },
        {
          "title": "Exploring printf on Cortex-M - Interrupt - Memfault",
          "url": "https://interrupt.memfault.com/blog/printf-on-embedded",
          "excerpts": [
            "Sep 20, 2023 — TLDR, semihosting operates by the target executing the breakpoint instruction with a special breakpoint id, bkpt 0xab , with the I/O opcode ..."
          ]
        },
        {
          "title": "Using the system allocator in a no_std context",
          "url": "https://users.rust-lang.org/t/using-the-system-allocator-in-a-no-std-context/27983",
          "excerpts": [
            "May 6, 2019 — You can just use the \"system allocator\" by calling malloc/free of the provided library. With that allocator you can use String, Vec, and many more.",
            "You can just use the \"system allocator\" by calling malloc/free of the provided library. With that allocator you can use String, Vec, and many more."
          ]
        },
        {
          "title": "How to use Allocator API in no-std binary?",
          "url": "https://users.rust-lang.org/t/how-to-use-allocator-api-in-no-std-binary/76380",
          "excerpts": [
            "Jun 2, 2022 — I am trying to use the (currently unstable) allocator API in a no-std binary. By my understanding: I need to make an allocator (say a ...",
            "* I need to make an allocator (say a bitmap-allocator) and implement the `Allocator` trait on it. * Since it's a `no-std` binary, I cannot use `std::vec::Vec` directly, so I need to go via `alloc::vec::Vec` . * `alloc` needs to be explicitly declared as extern crate, so I would do something like `extern crate alloc as std_alloc` (The rename is because there is a `alloc` module in the binary crate)",
            "alloc::vec::Vec` has a second type parameter which specifies the allocator - so I would create a new vector as `let v: Vec<i32, BitmapAllocator> = Vec::new()` . This is where I get a million errors of the form `The size of for values of type <insert-type> cannot be known at compile time. The trait core::marker::Size is not implemented for <insert-same-type>` , even for primitive types such as `usize` , which is most certainly `Size` ",
            "o global memory allocator found but one is required; link to std or add \\`#[global_allocator]\\` to a static item that implements the GlobalAlloc trai",
            "`#[alloc_error_handler]\\` function required, but not foun",
            "note: use \\`#! [feature(default_alloc_error_handler)]\\` for a default error handl",
            "I noticed in your original message you mentioned `Vec::new()` but that function includes a reference to the global allocator; you need `new_in()` instead.",
            "Maybe fixing that will help? I don't know if merely linking `alloc` needs a global allocator.",
            "I am trying to use the (currently unstable) allocator API in a no-std binary. By my understanding: I need to make an allocator (say a ..."
          ]
        },
        {
          "title": "alloc-no-stdlib - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/alloc-no-stdlib",
          "excerpts": [
            "Sep 11, 2022 — A dynamic allocator that may be used with or without the stdlib. This allows a package with nostd to allocate memory dynamically.",
            "A dynamic allocator that may be used with or without the stdlib. This allows a package with nostd to allocate memory dynamically."
          ]
        },
        {
          "title": "tlsf - Rust",
          "url": "https://docs.rs/tlsf",
          "excerpts": [
            "An implementation of the Two-Level Segregated Fit (TLSF) allocator with optimized memory footprint. §Design features. The alloc and dealloc operations ..."
          ]
        },
        {
          "title": "buddyalloc : A simple \"buddy allocator\" for bare-metal Rust",
          "url": "https://crates.io/crates/buddyalloc",
          "excerpts": [
            "Safe and simple drop-in allocator for Rust running on embedded or bare metal systems (no_std) ... Why this crate over the original buddy allocator?"
          ]
        },
        {
          "title": "Collections - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/collections/",
          "excerpts": [
            "\n\nTo be able to use any collection you'll first need use the `global_allocator`\nattribute to declare the global allocator your program will use. It's required\nthat the allocator you select implements the [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) trait.",
            "\n\nextern crate alloc;",
            "\n#! [feature(alloc_error_handler)]",
            "\n\n#[alloc_error_handler]",
            "]\nfn on_oom(_layout: Layout) -> ! {",
            "oc {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        ",
            "\n\n// Bump pointer allocator for *single* core systems",
            "s\nstruct BumpPointerAlloc {",
            "{\n    head: UnsafeCell<usize>,",
            "\n\n// Declaration of the global memory allocator",
            "m\n#[global_allocator]",
            "m\n#[global_allocator]",
            "]\nstatic HEAP: BumpPointerAlloc = BumpPointerAlloc {",
            "{\n    head: UnsafeCell::new(0x2000_0100),"
          ]
        },
        {
          "title": "try_reserve - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/try_reserve",
          "excerpts": [
            "This allows for easier and unified creation of custom collections that need to return appropriate allocation error types. Features. no_std ..."
          ]
        },
        {
          "title": "alloc_metrics - Rust",
          "url": "https://docs.rs/alloc-metrics",
          "excerpts": [
            "Description. alloc-metrics is a simple crate that adds a new global allocator type that tracks the total number of allocations and actual bytes allocated."
          ]
        },
        {
          "title": "TryReserveError in std::collections - Rust",
          "url": "https://doc.rust-lang.org/std/collections/struct.TryReserveError.html",
          "excerpts": [
            "Converts TryReserveError to an error with ErrorKind::OutOfMemory. TryReserveError won't be available as the error source(), but this may change in the future."
          ]
        },
        {
          "title": "metricus_allocator - Rust",
          "url": "https://docs.rs/metricus_allocator",
          "excerpts": [
            "Structs§. CountingAllocator: This allocator will use instrumentation to count the number of allocations and de-allocations occurring in the program."
          ]
        },
        {
          "title": "SFBdragon/talc: A fast and flexible allocator for no_std and ...",
          "url": "https://github.com/SFBdragon/talc",
          "excerpts": [
            "The most powerful feature of the allocator is that it has a modular OOM handling system, allowing you to fail out of or recover from allocation failure easily."
          ]
        },
        {
          "title": "RP2040, Embassy, no_std and the memory allocator",
          "url": "https://www.reddit.com/r/EmbeddedRust/comments/1gj7sdm/rp2040_embassy_no_std_and_the_memory_allocator/",
          "excerpts": [
            "While testing Embassy and Rust on my RP2040, I often ran into the no global memory allocator found but one is required."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required",
          "url": "https://stackoverflow.com/questions/72791679/rust-no-std-find-why-global-memory-allocator-is-required",
          "excerpts": [
            "Missing: minimal example",
            "The only advice I saw online for this situation is to make a dummy custom allocator and then look through the compiled binary for references to it.",
            "The only advice I saw online for this situation is to make a dummy custom allocator and then look through the compiled binary for references to it.See more"
          ]
        },
        {
          "title": "TLSF Allocator for #![no_std] environment - rust",
          "url": "https://stackoverflow.com/questions/79089038/tlsf-allocator-for-no-std-environment",
          "excerpts": [
            "When placing brackets around an allocation, the code within that scope will execute, but then at the end of the scope, it will fail as it is ..."
          ]
        },
        {
          "title": "Talloc, a better no_std allocator : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/155x2ew/talloc_a_better_no_std_allocator/",
          "excerpts": [
            "This is a no_std allocator (thus single threaded, it won't do much good in hosted, multithreaded systems) which distinguishes itself by being faster than the ...",
            "Missing: internal external"
          ]
        },
        {
          "title": "Why does Vec panic instead of returning an Error? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1dvg7zd/why_does_vec_panic_instead_of_returning_an_error/",
          "excerpts": [
            "This applies to many methods like: Insert: Index put of bounds, probably also try reserve error. Push: try reserve error."
          ]
        },
        {
          "title": "No_std, no allocator/heap, no void* ... how?",
          "url": "https://users.rust-lang.org/t/no-std-no-allocator-heap-no-void-how/115809?page=2",
          "excerpts": [
            "Aug 12, 2024 — You could argue that Embedded Rust is even more safe than std Rust, because it won't even allow invalid states to exist at compile time in many ...",
            "Aug 12, 2024 — With embedded-hal you could for example write a driver crate for a GPIO-expander that works with any HAL (even avr-hal ). And the Pin objects ...See more",
            "With embedded-hal you could for example write a driver crate for a GPIO-expander that works with any HAL (even avr-hal ). And the Pin objects ..."
          ]
        },
        {
          "title": "no_std and liballoc in Rust (alloc + global allocator examples)",
          "url": "https://github.com/rust-lang/rust/issues/66740",
          "excerpts": [
            "Summary. This issue formally proposes stabilizing the #[alloc_error_handler] attribute as-is, after adding some documentation. Any low-level code that makes allocations and wants to expose an infallible API is expected to call this function.",
            "For example a custom container library could look like:",
            "```\nuse std::alloc::{Layout, alloc, handle_alloc_error};\nuse std::ptr::NonNull;\n\nimpl<T> MyBox<T> {\n    pub fn new(x: T) -> Self {\n        let layout = Layout::new::<T>();\n        assert! (layout.size() > 0); // Not dealing with the zero-size case for example brevity\n        let maybe_null = unsafe { alloc(layout) };\n        let ptr = NonNull::new(maybe_null)\n            .unwrap_or_else(|| handle_alloc_error(layout));\n        Self(ptr.cast())\n    }\n}\n```\n\n### `no_std` and `liballoc`\n\nThe Rust standard library is split into three crates (that are relevant to this issue): `core`, `alloc`, and `std`. * `std` expects much functionality to be provided by the underlying operating system or environment: a filesystem, threads, a network stack, … and relevant here: a memory allocator and a way to abort the current process. Large parts of its code are target-specific. Porting it to a new target can take non-trivial efforts. * `core` contains the subset of `std` that has almost no such requirement. A crate can use the `#! [no_std]` attribute to opt into having its implicit dependency to `std` replaced by an implicit dependency to `core`. When all crates in an application do this, this enables porting to a target that might not have `std` at all.\n ... \nThe attribute is effectively a procedural macro that checks the signature of the function and turns it into an `extern \"Rust\" fn` with a known symbol name, so that it can be called without going through Rust’s usual crate/module/path name resolution. The compiler also checks for “top-level” compilations (executables, `cdylib`s, etc.) that there is exactly one panic handler in the whole crate dependency graph. `std` (effectively) provides one, so the attribute is both necessary for `no_std` applications and can only be used there. ### `#[global_allocator]`\n\nDepending on the workload, an alternative allocator may be more performant than the platform’s default. In earlier versions of Rust, the standard library used jemalloc. In order to leave that choice to users, Rust 1.28 stabilized [the `GlobalAlloc` trait](https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html) and [`#[global_allocator]` attribute](http://localhost/rust/std/alloc/index.html), and changed the standard library’s default to the system’s allocator. This incidentally enabled (in Nightly) the use of `alloc` in `no_std` applications which can now provide an allocator implementation not just to be used instead of `std`’s default, but where `std` is not necessarily available at all. However such applications still require Rust Nightly in order to fulfil `alloc`’s second requirement: the allocation error handler.\n ... \nWe call an application `no_std` if it doesn’t link the `std` crate. That is, if all crates in its dependency graph have the `#! [no_std]` attribute and (after `cfg`-expansion) do not contain `extern crate std;`. A `no_std` application may use the standard library’s `alloc` crate if and only if it specifies both a global allocator with the `#[global_allocator]` attribute, and an allocation error handler with the `#[alloc_error_handler]` attribute. Each may only be defined once in the crate dependency graph. They can be defined anywhere, not necessarily in the top-level crate. The handler defines what to do when `handle_alloc_error` is called. It must be a function with the signature as follows:\n\n```\n#[alloc_error_handler]\nfn my_example_handler(layout: core::alloc::Layout) -> ! {\n    panic! (\"memory allocation of {} bytes failed\", layout.size())\n}\n```\n\nThe handler is given the `Layout` of the allocation that failed, for diagnostics purpose. As it is called in cases that are considered not recoverable, it may not return. `std` achieves this by aborting the process. In a `no_std` environment − which might not have processes in the first place − panicking calls the `#[panic_handler]` which is also required to not re",
            "`alloc` requires:\n\n  + A heap memory allocator, that provides an implementation of the `alloc` function and related functions. + An allocation error handler, that provides an implementation of the `handle_alloc_error` fu"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The libcore crate in turn is a platform-agnostic subset of the std crat",
            "which makes no assumptions about the system the program will run on.",
            " Bare Metal Environments\nIn a bare metal environment no code has been loaded before your program. Without the software provided by an OS we can not load the standard library.\nInstead the program, along with the crates it uses, can only use the hardware (bare metal) to run. To prevent rust from loading the standard library use\nno_std",
            "no_std Rust Environment",
            "a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "The libcore crate in turn is a platform-agnostic subset of the std crate\nwhich makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions.",
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "Missing: MMIO svd2rust",
            "Missing: x ARM Instead the program, along with the crates it uses, can only use the hardware (bare metal) to run. To prevent rust from loading the standard library use\nno_std . The platform-agnostic parts of the standard library are available through libcore . libcore also excludes things which are not always desirable in an embedded environment. One of these things is a memory allocator for dynamic memory allocation. If you require this or any other functionalities there are often crates which provide these. The libstd Runtime\nAs mentioned before using libstd requires some sort of system integration, but this is not only because libstd is just providing a common way of accessing OS abstractions, it also provides a runtime. This runtime, among other things, takes care of setting up stack overflow protection, processing command line arguments,\nand spawning the main thread before a program's main function is invoked. This runtime also won't be available in a\nno_std environment. Summary",
            "\n#! [no_std] is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.",
            "Because of these properties no_std and libcore code can be used for any kind of\nbootstrapping (stage 0) code like bootloaders, firmware or kernels.",
            "As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features\nlike atomic operations and SIMD instructions",
            ". If you require this or any other functionalities there are often crates which provide these.",
            "The libcore crate in turn is a platform-agnostic subset of the std crate",
            "\n\nA\nno_std Rust Environment",
            ". To prevent rust from loading the standard library use\nno_std .",
            "However it lacks APIs for anything that involves platform integration."
          ]
        },
        {
          "title": "Rust Lang Items and no_std Guide",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/lang-items.html",
          "excerpts": [
            ")]\n#! [no_std]\n#!\n[no_main]\n\nextern crate libc;\nextern crate ",
            "#!\n[no_main]",
            "#[panic_handler]\nfn panic_handler(_info: &PanicInfo) -> ! { intrinsics::abort() }",
            ". The marker is the attribute `#[lang = \"...\"]` and there are\nvarious different values of `...`, i.e. various different 'lang\nitems'.",
            "An up-to-date list of all language items can be found [here](https://github.com/rust-lang/rust/blob/master/compiler/rustc_hir/src/lang_items.rs) in the compiler code.",
            "Most lang items are defined by core, but if you're trying to build an executable without the std crate, you might run into the need for lang item definitions. l",
            "use core::panic::PanicInfo;",
            "#[panic_handler]"
          ]
        },
        {
          "title": "Rust target tiers and freestanding/no_std targets",
          "url": "https://doc.rust-lang.org/beta/rustc/platform-support.html",
          "excerpts": [
            " targets are those which the Rust codebase has support for, but which the\nRust project does not build or test automatically, so they may or may not work. Official builds are not available. For the full requirements, see Tier 3\ntarget policy in the Target Tier\nPolicy. The\nstd column in the table below has the following meanings:\n    * ✓ indicates the full standard library is available. * * indicates the target only supports\nno_std development. * ? indicates the standard library support is unknown or a work-in-progre",
            "    * target: aarch64-unknown-none\n    * target: *\n    * target: Bare ARM64, hardfloat",
            "    * target: aarch64-unknown-none-softfloat\n    * target: *\n    * target: Bare ARM64, softfloat",
            "    * target: aarch64-unknown-uefi\n    * target: ?",
            "target: 64-bit x86 Android",
            "\n\n    * target: x86_64-unknown-fuchsia\n    * target: ✓\n    * target: 64-bit x86 Fuchsia",
            "\n\n    * target: x86_64-unknown-linux-gnux32\n    * target: ✓\n    * target: 64-bit Linux (x32 ABI) (kernel 4.15+, glibc 2.27)",
            "    * target: x86_64-unknown-none\n    * target: *\n    * target: Freestanding/bare-metal x86_64, softfloat",
            "\n\n\n    * target: x86_64-unknown-redox\n    * target: ✓\n    * target: Redox OS",
            "    * target: x86_64-unknown-uefi\n    * target: ? * target: 64-bit UEFI"
          ]
        },
        {
          "title": "How do I bootstrap Rust to cross-compile for a new platform?",
          "url": "https://www.reddit.com/r/rust/comments/5ag60z/how_do_i_bootstrap_rust_to_crosscompile_for_a_new/",
          "excerpts": [
            "Out of tree, no_std support. One should be able to cross compile e.g. the core crate using a target specification file. A target specification ..."
          ]
        },
        {
          "title": "Everything you need to know about cross compiling Rust ...",
          "url": "https://github.com/japaric/rust-cross",
          "excerpts": [
            "Feb 4, 2016 — To compile a Rust program we need 4 things: Find out what's the triple for the target system. A gcc cross compiler, because rustc uses gcc to \" ..."
          ]
        },
        {
          "title": "Can't find core , the `thumbv7m-none-eabi` target may not ...",
          "url": "https://users.rust-lang.org/t/cant-find-core-the-thumbv7m-none-eabi-target-may-not-be-installed/39183",
          "excerpts": [
            "Mar 7, 2020 — I am using Ubuntu and have installed thumbv7-none-eabi target using rustup. When I build the example project I get following errors."
          ]
        },
        {
          "title": "How to use the std I built for my tier 3 target in cross compile",
          "url": "https://users.rust-lang.org/t/how-to-use-the-std-i-built-for-my-tier-3-target-in-cross-compile/116675",
          "excerpts": [
            "Aug 27, 2024 — I'm trying to cross compile for my board which is in tier 3 target list, using command cargo +nightly build -Z build-std --target armv7-unknown-linux- ..."
          ]
        },
        {
          "title": "`no_std` / `no_main` Hello World example for Windows - help",
          "url": "https://users.rust-lang.org/t/no-std-no-main-hello-world-example-for-windows/108355",
          "excerpts": [
            "I've had a few people ask for Windows examples of no_std and no_main Hello World over at min-sized-rust. I'd like to update or make Windows ..."
          ]
        },
        {
          "title": "Discussion: changing the sysroot for cross-compilation",
          "url": "https://internals.rust-lang.org/t/discussion-changing-the-sysroot-for-cross-compilation/8676",
          "excerpts": [
            "Oct 25, 2018 — Each triple subdirectory contains the compiled form of central rust libraries compiled for that target triple. In particular, they must contain ..."
          ]
        },
        {
          "title": "error[E0463]: can't find crate for `core` note: the `thumbv7m ...",
          "url": "https://stackoverflow.com/questions/63663245/errore0463-cant-find-crate-for-core-note-the-thumbv7m-none-eabi-target",
          "excerpts": [
            "error[E0463]: can't find crate for `core` note: the `thumbv7m-none-eabi` target may not be installed · The code you've provided compiles fine for ..."
          ]
        },
        {
          "title": "Win32: no_std, no_main, no libc? - help - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/win32-no-std-no-main-no-libc/30038",
          "excerpts": [
            "When coding little windows console programs I try to avoid to C-Runtime. I just use the Win32 API to get small, statically linked programms."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "https://os.phil-opp.com/",
          "excerpts": [
            "This blog series creates a small operating system in the Rust programming language. Each post is a small tutorial and includes all needed code.",
            "This blog series creates a small operating system in the Rust programming language.",
            "[A Freestanding Rust Binary](/freestanding-rust-binary/)",
            "A Minimal Rust Kernel",
            "Memory Management",
            "Memory Management",
            "Introduction to Paging",
            "This post introduces *paging*, a very common memory management scheme that we will also use for our operating system. It explains why memory isolation is needed, how *segmentation* works, what *virtual memory* is, and how paging solves memory fragmentation issues. It also explores the layout of multilevel page tables on the x86\\_64 archit",
            "Paging Implementation",
            "This post shows how to implement paging support in our kernel. It first explores different techniques to make the physical page table frames accessible to the kernel and discusses their respective advantages and drawbacks. It then implements an address translation function and a function to create a new mapping.",
            "Heap Allocation",
            "This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post, all the allocation and collection types of the built-in `alloc` crate will be available to our kernel.",
            "Allocator Designs",
            "This post explains how to implement heap allocators from scratch. It presents and discusses different allocator designs, including bump allocation, linked list allocation, and fixed-size block allocation."
          ]
        },
        {
          "title": "Philipp Oppermann phil-opp",
          "url": "https://github.com/phil-opp",
          "excerpts": [
            "blog_os blog_os · Writing an OS in Rust ; x86_64 rust-osdev/x86_64 · Library to program x86_64 hardware. ; bootloader rust-osdev/bootloader · An experimental pure- ..."
          ]
        },
        {
          "title": "Making an RISC-V OS (Part 1): Project Setup",
          "url": "https://traxys.me/riscv_os_setup.html",
          "excerpts": [
            "Jan 22, 2024 — This project is meant to be a way to learn about low-level systems subjects, and in the longer term maybe higher level subjects.",
            "Jan 22, 2024 — link.x is a script defined in the riscv-rt crate that implements the different REGION_ALIAS we defined in the memory.x ."
          ]
        },
        {
          "title": "How to define an entry point (no_std!) : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1ebwbnw/how_to_define_an_entry_point_no_std/",
          "excerpts": [
            "You make a symbol called _start and when linking the object files together ld (unless you've passed a flag saying use another symbol as the ..."
          ]
        },
        {
          "title": "Tooling - The Embedded Rust Book",
          "url": "https://doc.rust-lang.org/beta/embedded-book/intro/tooling.html",
          "excerpts": [
            "Bare metal programs are non-standard (`no_std`) Rust programs that require some\nadjustments to the linking process in order to get the memory layout of the program\nright.",
            "This requires some additional files (like linker scripts) and\nsettings (like linker flags)."
          ]
        },
        {
          "title": "no_std, no_main in Rust",
          "url": "https://pico.implrust.com/core-concepts/no-std-main.html",
          "excerpts": [
            "In environments without the standard library (when using no_std attribute), you need to create this function yourself using the #[panic_handler] attribute. This ...",
            "The #![no_std] attribute disables the use of the standard library (std). This is necessary most of the times for embedded systems development."
          ]
        },
        {
          "title": "【Rust】\"Hello world!\" without Standard Library",
          "url": "https://zenn.dev/zulinx86/articles/rust-nostd-101",
          "excerpts": [
            "To tell the Rust compiler that we don't want to use the normal entry point chain, we add the #![no_main] attribute. #![no_std] #![no_main] use ..."
          ]
        },
        {
          "title": "build-std - Rust Project Goals - GitHub Pages",
          "url": "https://rust-lang.github.io/rust-project-goals/2025h1/build-std.html",
          "excerpts": [
            "build-std is a well-known unstable feature in Cargo which enables Cargo to re-build the standard library, this is useful for a variety of reasons."
          ]
        },
        {
          "title": "The rustc book - Rust Documentation",
          "url": "https://doc.rust-lang.org/rustc/?search=triple",
          "excerpts": [
            "Platform Support » Platform SupportTier Policy . Targets are identified by their \"target triple\" which is the string to inform the compiler what kind of output ..."
          ]
        },
        {
          "title": "Cargo doesn't recognize `build-std`",
          "url": "https://users.rust-lang.org/t/cargo-doesnt-recognize-build-std/116560",
          "excerpts": [
            "Aug 25, 2024 — This means that cargo-features = [\"build-std\"] should work but it instead it says error: failed to parse manifest at `C:\\Users\\hrudk\\Documents\\coding\\DOS in ..."
          ]
        },
        {
          "title": "Running Rust on Microcontrollers",
          "url": "https://blog.mbedded.ninja/programming/languages/rust/running-rust-on-microcontrollers/",
          "excerpts": [
            "o_std` also means you have to define what `panic` does. In embedded development, you are not allowed to return from the panic function, as it is forced to have the signature `fn(&PanicInfo) -> !`.",
            "The `core-crate` is a subset of the `std-crate` which **does not contain any APIs which assume/require the use of an operating syste"
          ]
        },
        {
          "title": "Writing a #[no_std] compatible crate in Rust - Silicon Island",
          "url": "https://siliconislandblog.wordpress.com/2022/04/24/writing-a-no_std-compatible-crate-in-rust/",
          "excerpts": [
            "Apr 24, 2022 — no_std is useful for a myriad of use cases like embedded platforms, it can even work in environments with no memory allocation."
          ]
        },
        {
          "title": "Nine Rules for Running Rust on Embedded Systems - Medium",
          "url": "https://medium.com/data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e",
          "excerpts": [
            "Porting your Rust project to a no_std environment allows you to target microcontrollers and deeply embedded systems, creating highly efficient software for ..."
          ]
        },
        {
          "title": "Std Embedded Rust - Tim Hut",
          "url": "https://blog.timhutt.co.uk/std-embedded-rust/index.html",
          "excerpts": [
            "#! [no_main]\n#! [no_std]\n\nuse panic_halt as _",
            "static ALLOCATOR: CortexMHeap = CortexMHeap::empty();",
            "const HEAP_SIZE: usize = 1024; // in bytes",
            "unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }",
            "                  // 👈\nfn alloc_error(_layout: core::alloc::Layout) -> !",
            "\nextern crate alloc;   // ",
            "\nextern crate alloc;   // ",
            "\nextern crate alloc;   // ",
            "\nuse alloc::vec::Vec;  // ",
            "\nuse alloc::vec::Vec;  // ",
            "\nuse alloc::vec::Vec;  // ",
            "#[global_allocator]",
            "Apr 19, 2021 — Conveniently there's an example at examples/allocator.rs that we can copy & paste from: #![no_main] #![no_std] #![feature(alloc_error_handler)] ...",
            "Apr 19, 2021 — build-std can be constrained to build only core or core and alloc but by default it builds core , alloc and std which is what we want."
          ]
        },
        {
          "title": "Buddy System Allocator - GitHub (rcore-os/buddy_system_allocator)",
          "url": "https://github.com/rcore-os/buddy_system_allocator",
          "excerpts": [
            "To use buddy\\_system\\_allocator for global allocato",
            "```\nuse buddy_system_allocator::LockedHeap;\n\n#[global_allocator]\nstatic HEAP_ALLOCATOR: LockedHeap = LockedHeap::<33>::empty();\n```",
            "```\nunsafe {\n    HEAP_ALLOCATOR.lock().init(heap_start, heap_size);\n    // or\n    HEAP_ALLOCATOR.lock().add_to_heap(heap_start, heap_end);\n}\n```"
          ]
        },
        {
          "title": "Emballoc No-Std Allocator Documentation",
          "url": "https://docs.rs/emballoc",
          "excerpts": [
            "The allocator itself is thread-safe, as there is no potentially unsafe Cell<T> -action done in this crate.",
            ". Instead it uses the popular spin crate to use a ... While this is\nsimple for the implementation, this is not good for performance on\nmulti-threaded systems: you have a global lock for each memory allocation,\nso only on thread can do a memory allocation at a time.",
            "ime. However, this isn’t\nreally a problem in embedded systems anyway, as there is only on thread\npossible without Real Time Operating Systems (RTOS) (which in turn often\nprovide a memory allocator as well, so that one can be used). Therefore this\ncrate is **sound** and safe to use in multi-threaded contexts, but the\nperformance is not as good as it might be on a lock-free implementation\n(converting this crate to such a lock free version would be possible, but\nlikely complicate the algorithm and thus is incompatible with the goal to be\n“simple”).",
            "A general problem with non-lock-free allocators is the following: it can\ncause deadlocks even in single-threaded environments if there are interrupts\nthat will *allocate memory*. The interrupt is kind of a second thread, that\npreempts the first one at any time, even if an allocation is currently in\nprogress. In such a case the interrupt would wait on the lock and never\nobtain it, since the main program is interrupted and thus cannot release the\nlock.",
            ". Therefore it is advised to never use any allocations (or deallocations\nto the same extend) in an interrupt handler. Performance-wise this shouldn’t\nbe done anyway."
          ]
        },
        {
          "title": "Tracking issue for the #[alloc_error_handler] attribute (for ...",
          "url": "https://github.com/rust-lang/rust/issues/51540",
          "excerpts": [
            "Jun 13, 2018 — This attribute is mandatory when using the alloc crate without the std crate. It is used like this: #[alloc_error_handler] fn foo(_: ..."
          ]
        },
        {
          "title": "A heap allocator for embedded systems - GitHub",
          "url": "https://github.com/rust-embedded/embedded-alloc",
          "excerpts": [
            "This project is developed and maintained by the libs team. Example. Starting with Rust 1.68, this crate can be used as a global allocator on stable Rust:."
          ]
        },
        {
          "title": "alloc_cortex_m - Rust",
          "url": "https://docs.rs/alloc-cortex-m",
          "excerpts": [
            "A heap allocator for Cortex-M processors. Note that using this as your global allocator requires nightly Rust. §Example. For a usage example, see examples ...See more"
          ]
        },
        {
          "title": "buddy_system_allocator - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/buddy_system_allocator",
          "excerpts": [
            "buddy_system_allocator v0.11.0. A bare metal allocator that uses buddy system. #allocator · #heap · #no_std."
          ]
        },
        {
          "title": "bumpalo - Rust",
          "url": "https://docs.rs/bumpalo/latest/bumpalo/",
          "excerpts": [
            "Bump allocation is a fast, but limited approach to allocation. We have a chunk of memory, and we maintain a pointer within that memory.",
            "This implementation will allocate a new memory chunk from the global allocator\nand then start bump allocating into this new memory chunk"
          ]
        },
        {
          "title": "Memory management - Lib.rs",
          "url": "https://lib.rs/memory-management",
          "excerpts": [
            "Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "slaballoc - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slaballoc",
          "excerpts": [
            "Sep 29, 2024 — This crate provides a lockless no_std compatible slab allocator, for fixed-size allocations. This slab allocator takes a fixed-size block of ..."
          ]
        },
        {
          "title": "slab_allocator_rs - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/slab_allocator_rs",
          "excerpts": [
            "Jan 7, 2023 — Slab allocator for no_std systems. Uses multiple slabs with blocks of different sizes and a buddy system allocator for blocks larger than 4096 bytes."
          ]
        },
        {
          "title": "bbqueue - Rust",
          "url": "https://docs.rs/bbqueue/latest/bbqueue/",
          "excerpts": [
            "BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded systems. While Circular/Ring Buffers allow you to send data ...",
            "BBQueue is a single producer, single consumer, lockless, thread-safe, First-In, First-Out queue based on BipBuffers, designed for DMA on embedded systems.",
            "BBQueue, short for “BipBuffer Queue”, is a Single Producer Single Consumer, lockless, no_std, thread safe, queue, based on BipBuffers.",
            "BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded\nsystems.",
            "By default BBQueue uses atomic operations which are available on most platforms. However on some\n(mostly embedded) platforms atomic support is limited and with the default features you will get\na compiler error about missing atomic methods.",
            "This crate contains special support for Cortex-M0(+) targets with the `thumbv6` feature. By\nenabling the feature, unsupported atomic operations will be replaced with critical sections\nimplemented by disabling interrupts.",
            "The critical sections are very short, a few instructions at\nmost, so they should make no difference to most applications.",
            "Modules",
            "Local usage",
            "Static usage",
            "features"
          ]
        },
        {
          "title": "arrayvec - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/arrayvec",
          "excerpts": [
            "Aug 17, 2024 — A vector with fixed capacity, backed by an array (it can be stored on the stack too). Implements fixed capacity ArrayVec and ArrayString."
          ]
        },
        {
          "title": "acid_alloc - Rust - Docs.rs",
          "url": "https://docs.rs/acid_alloc",
          "excerpts": [
            "This crate provides allocators that are suitable for use on bare metal or with low-level allocation facilities like mmap(2) / brk(2)."
          ]
        },
        {
          "title": "fitzgen/bumpalo: A fast bump allocation arena for Rust",
          "url": "https://github.com/fitzgen/bumpalo",
          "excerpts": [
            "This implementation will allocate a new memory chunk from the global allocator and then start bump allocating into this new memory chunk. Example. use bumpalo:: ..."
          ]
        },
        {
          "title": "Writing no_std-friendly libraries? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/mpfnua/writing_no_stdfriendly_libraries/",
          "excerpts": [
            "Everything in the alloc crate will honor a global allocator set by the host application. I built a no_std crate with allocation, if you'd ..."
          ]
        },
        {
          "title": "Making a buddy allocator in no_std rust. - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/152mwwr/making_a_buddy_allocator_in_no_std_rust/",
          "excerpts": [
            "Missing: slab TLSF"
          ]
        },
        {
          "title": "heapless - Rust - Docs.rs",
          "url": "https://docs.rs/heapless/latest/heapless/",
          "excerpts": [
            "static friendly data structures that don't require dynamic memory allocation. The core principle behind heapless is that its data structures are backed by a ...",
            "`static` friendly data structures that don't require dynamic memory allocation",
            "A fixed capacity multiple-producer, multiple-consumer (MPMC) lock-free queue",
            "A fixed capacity single-producer, single-consumer (SPSC) lock-free queue",
            "- [portable-atomic ^1.0\n      *normal*\n      *optional*](/portable-atomic/^1.0)",
            "critical-section ^1.1",
            "The heapless crate provides static data structures with fixed capacity, backed by static memory allocation, and doesn't use dynamic memory allocation."
          ]
        },
        {
          "title": "Alternative for Vec for variable size arrays in no_std ...",
          "url": "https://www.reddit.com/r/rust/comments/uriyq2/alternative_for_vec_for_variable_size_arrays_in/",
          "excerpts": [
            "In no_std environments, I am often using the heapless crate. It contains a lot of useful data structures that can be used in no_std ..."
          ]
        },
        {
          "title": "API alignment · Issue #442 · rust-embedded/heapless",
          "url": "https://github.com/rust-embedded/heapless/issues/442",
          "excerpts": [
            "Jan 15, 2024 — Currently the heapless::Vec API is significantly different from both std::Vec and alternative no_std/no-alloc Vec implementations like ..."
          ]
        },
        {
          "title": "jamesmunns/bbqueue: A SPSC, lockless, no_std, thread ...",
          "url": "https://github.com/jamesmunns/bbqueue",
          "excerpts": [
            "With BBQueue, you instead are granted a block of contiguous memory, which can be filled (or emptied) by a DMA engine. Local usage. // Create a buffer with six ...",
            "BBQueue, short for BipBuffer Queue, is a Single Producer Single Consumer, lockless, no_std, thread safe, queue, based on BipBuffers.",
            "BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded\nsystems. While Circular/Ring Buffers allow you to send data between two threads (or from an interrupt to\nmain code), you must push the data one piece at a time. With BBQueue, you instead are granted a\nblock of contiguous memory, which can be filled (or emptied) by a DMA engine. Local usage",
            "Static usage\n------------\n\n```\nuse bbqueue::BBBuffer;\n\n// Create a buffer with six elements\nstatic BB: BBBuffer<6> = BBBuffer::new();\n\nfn main() {\n    // Split the bbqueue into producer and consumer halves. // These halves can be sent to different threads or to\n    // an interrupt handler for thread safe SPSC usage\n    let (mut prod, mut cons) = BB.try_split().unwrap();\n\n    // Request space for one byte\n    let mut wgr = prod.grant_exact(1).unwrap();\n\n    // Set the data\n    wgr[0] = 123;\n\n    assert_eq! (wgr.len(), 1);\n\n    // Make the data ready for consuming\n    wgr.commit(1);\n\n    // Read all available bytes\n    let rgr = cons.read().unwrap();\n\n    assert_eq! (rgr[0], 123);\n\n    // Release the space for later writes\n    rgr.release(1);\n\n    // The buffer cannot be split twice\n    assert! (BB.try_split().is_err());\n}\n```",
            "The `bbqueue` crate is located in `core/`, and tests are located in `bbqtest/`. Features\n--------\n\nBy default BBQueue uses atomic operations which are available on most platforms. However on some\n(mostly embedded) platforms atomic support is limited and with the default features you will get\na compiler error about missing atomic methods."
          ]
        },
        {
          "title": "arrayvec crate documentation",
          "url": "https://docs.rs/arrayvec/latest/arrayvec/",
          "excerpts": [
            "arrayvec** provides the types [`ArrayVec`](struct.ArrayVec.html \"struct arrayvec::ArrayVec\") and [`ArrayString`](struct.ArrayString.html \"struct arrayvec::ArrayString\"",
            "arrayvec provides the types `ArrayVec` and `ArrayString`: array-backed vector and string types, which store their contents inline.",
            "The arrayvec package has the following cargo features:",
            "* `std`",
            "  + Optional, enabled by default",
            "  + Use libstd; disable to use `no_std` instead."
          ]
        },
        {
          "title": "Rust embedded alloc_error_handler",
          "url": "https://users.rust-lang.org/t/rust-embedded-alloc-error-handler/88448",
          "excerpts": [
            "Custom alloc error handlers are still unstable. However, starting with Rust 1.68 there is a stable default_error_handler which just panics on ..."
          ]
        },
        {
          "title": "Is std::alloc::Allocator likely to be stable any time soon?",
          "url": "https://users.rust-lang.org/t/is-std-allocator-likely-to-be-stable-any-time-soon/111541",
          "excerpts": [
            "In the module std::alloc there is an \"experimental\" (that is available on nightly only ) trait Allocator. I was wondering when it might be stabilised."
          ]
        },
        {
          "title": "embedded-alloc - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embedded-alloc",
          "excerpts": [
            "A heap allocator for embedded systems. Note that using this as your global allocator requires Rust 1.68 or later. (With earlier versions, you ..."
          ]
        },
        {
          "title": "FluenTech/alloc-cortex-m - GitHub",
          "url": "https://github.com/FluenTech/alloc-cortex-m",
          "excerpts": [
            "A heap allocator for Cortex-M processors. This project is developed and maintained by the Cortex-M team."
          ]
        },
        {
          "title": "daniel5151/libc_alloc: A simple global allocator for Rust ...",
          "url": "https://github.com/daniel5151/libc_alloc",
          "excerpts": [
            "A simple global allocator for Rust which hooks into libc functions. Useful when linking no_std + alloc code into existing C codebases."
          ]
        },
        {
          "title": "Announcing coca v0.3.0: Allocation-free Data Structures, ...",
          "url": "https://www.reddit.com/r/rust/comments/t6npfj/announcing_coca_v030_allocationfree_data/",
          "excerpts": [
            "Announcing coca v0.3.0: Allocation-free Data Structures, now including Strings, Sets, Maps, Object Pools, and more!"
          ]
        },
        {
          "title": "alloc-cortex-m 0.4.4 - Docs.rs",
          "url": "https://docs.rs/crate/alloc-cortex-m/0.4.4/source/README.md",
          "excerpts": [
            "alloc-cortex-m 0.4.4. A heap allocator for Cortex ... toml · Cargo.toml.orig · CHANGELOG.md · CODE_OF_CONDUCT.md · LICENSE-APACHE · LICENSE-MIT · README ... alloc- ..."
          ]
        },
        {
          "title": "#![no_std] slab allocator in bare kernel : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/ozh40o/no_std_slab_allocator_in_bare_kernel/",
          "excerpts": [
            "I believe if you set a global allocator you can use the alloc crate which allows you to use certain heap structs/smart pointers from std on bare ..."
          ]
        },
        {
          "title": "embedded-alloc 0.6.0 - Docs.rs",
          "url": "https://docs.rs/crate/embedded-alloc/latest/source/CODE_OF_CONDUCT.md",
          "excerpts": [
            "1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed."
          ]
        },
        {
          "title": "Fallible allocation · Issue #886 · rustls/rustls",
          "url": "https://github.com/rustls/rustls/issues/886",
          "excerpts": [
            "Dec 21, 2021 — By consolidating allocations in a smaller number of places, and making those allocations fallible, we would make rustls a better library for Rust users as well."
          ]
        },
        {
          "title": "bbqueue - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/bbqueue",
          "excerpts": [
            "Dec 17, 2021 — BBQueue is designed (primarily) to be a First-In, First-Out queue for use with DMA on embedded systems. While Circular/Ring Buffers allow ..."
          ]
        },
        {
          "title": "slaballoc - no-std fixed-size memory allocator",
          "url": "https://docs.rs/slaballoc",
          "excerpts": [
            "This crate provides a lockless `no_std` compatible slab allocator, for fixed-size\nallocations.",
            " for fixed-size\nallocations. This slab allocator takes a fixed-size block of memory, as well as a ",
            "The slab allocator will partition the block of memory into two parts: an area\nfor allocated objects, and an area for an allocation bitmap."
          ]
        },
        {
          "title": "Heapless SPSC Queue (no_std) Documentation",
          "url": "https://docs.rs/heapless/latest/heapless/spsc/index.html",
          "excerpts": [
            "Queue can be split and then be used in Single Producer Single Consumer mode.",
            "“no alloc” applications can create a &'static mut reference to a Queue – using a ... heapless",
            "Module spsc",
            "After splitting a `&'static mut Queue`, the resulting [`Producer`](struct.Producer.html \"struct heapless::spsc::Producer\") and [`Consumer`](struct.Consumer.html \"struct heapless::spsc::Consumer\")\ncan be moved into different execution contexts, e.g. threads, interrupt handlers, etc.",
            "A fixed capacity single-producer, single-consumer (SPSC) lock-free queue.",
            "*Note:* This module requires atomic load and store instructions. On\ntargets where they’re not natively available, they are emulated by the\n[`portable-atomic`](https://crates.io/crates/portable-atomic) crate.",
            "ner::split\") can be used to split the queue into a [`Producer`](struct.Producer.html \"struct heapless::spsc::Producer\")/[`Consumer`](struct.Consumer.html \"struct heapless::spsc::Consumer\") pair.",
            "tc. ```\nuse heapless::spsc::{Producer, Queue};\n\n#[derive(Debug)]\nenum Event {\n    A,\n    B,\n}\n\nfn main() {\n    let queue: &'static mut Queue<Event, 4> = {\n        static mut Q: Queue<Event, 4> = Queue::new();\n        // SAFETY: `Q` is only accessible in this scope\n        // and `main` is only called once. unsafe { &mut Q }\n    };\n\n    let (producer, mut consumer) = queue.split();\n\n    // `producer` can be moved into `interrupt_handler` using a static mutex or the mechanism\n    // provided by the concurrency framework you are using, e.g. a resource in RTIC. loop {\n        match consumer.dequeue() {\n            Some(Event::A) => { /* .. */ }\n            Some(Event::B) => { /* .. */ }\n            None => { /* Sleep. */ }\n        }\n    }\n}\n\n// This is a different execution context that can preempt `main`.\nfn interrupt_handler(producer: &mut Producer<'static, Event>) {\n\n    // ..\n\n    if condition {\n        producer.enqueue(Event::A).unwrap();\n    } else {\n        producer.enqueue(Event::B).unwrap();\n    }\n\n    // ..\n}\n```\n",
            "§]()Benchmarks\n--------------------------\n\nMeasured on an ARM Cortex-M3 core running at 8 MHz and with zero flash wait cycles, compiled with `-C opt-level=3`:\n\n| Method | Time |\n| --- | --- |\n| `Producer::<u8, _>::enqueue()` | 16 |\n| `Queue::<u8, _>::enqueue()` | 14 |\n| `Consumer::<u8, _>::dequeue()` | 15 |\n| `Queue::<u8, _>::dequeue()` | 12 |\n\n* All execution times are in clock cycles (1 clock cycle = 125 ns). * Execution time is *dependent* on `mem::size_of::<T>()`, as both operations include\n  `ptr::read::<T>()` or `ptr::write::<T>()` in their successful path. * The numbers reported correspond to the successful path, i.e. `dequeue` returning `Some`\n  and `enqueue` returning `Ok`. [§]"
          ]
        },
        {
          "title": "bbqueue - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/bbqueue/0.0.2",
          "excerpts": [
            "BBQueue, short for \"BipBuffer Queue\", is a (work in progress) Single Producer Single Consumer, lockless, no_std, thread safe, queue, based on ..."
          ]
        },
        {
          "title": "bbqueue/ lib.rs - Docs.rs",
          "url": "https://docs.rs/bbqueue/latest/src/bbqueue/lib.rs.html",
          "excerpts": [
            "1//! # BBQueue 2//! 3//! BBQueue, short for \"BipBuffer Queue\", is a Single Producer Single Consumer, 4//! lockless, no_std, thread safe, queue, ..."
          ]
        },
        {
          "title": "fring - Rust",
          "url": "https://docs.rs/fring",
          "excerpts": [
            "Memory safety and thread safety are enforced at compile time; the buffer is lock-free at runtime. The buffer length is required to be a power of two, and the ..."
          ]
        },
        {
          "title": "Queue in heapless::spsc - Rust - Straw Lab",
          "url": "https://strawlab.org/strand-braid-api-docs/latest/heapless/spsc/struct.Queue.html",
          "excerpts": [
            "A statically allocated single producer single consumer queue with a capacity of N - 1 elements. IMPORTANT: To get better performance use a value for N that ..."
          ]
        },
        {
          "title": "The design and implementation of a lock-free ring-buffer ...",
          "url": "https://www.reddit.com/r/rust/comments/bwr2yg/the_design_and_implementation_of_a_lockfree/",
          "excerpts": [
            "Regarding point 1: It is a SPSC queue, and both implementations use Rust's ownership system to enforce that through ownership of the Producer ..."
          ]
        },
        {
          "title": "Heapless SPSC Queue Documentation",
          "url": "https://docs.rs/heapless/latest/heapless/spsc/struct.Queue.html",
          "excerpts": [
            "A statically allocated single producer single consumer queue with a capacity of N - 1 elements.",
            "The `Queue` is a statically allocated single producer, single consumer queue with a capacity of N-1 elements. It can be created with `new()` and has `enqueue` ..."
          ]
        },
        {
          "title": "Spin Crate Documentation",
          "url": "https://docs.rs/spin/",
          "excerpts": [
            "This crate provides [spin-based](https://en.wikipedia.org/wiki/Spinlock) versions of the\nprimitives in `std::sync` and `std::lazy` .",
            "Features",
            "  `Mutex` , `RwLock` , `Once` / `SyncOnceCell` , and `SyncLazy` equivalents",
            "  Support for `no_std` environments",
            "  [`lock_api`](https://crates.io/crates/lock_api) compatibility",
            "  Upgradeable `RwLock` guards",
            "  Guards can be sent and shared between threads",
            "  Guard leaking",
            "  Ticket locks",
            "  Different strategies for dealing with contention",
            "Relationship with `std::sync`",
            "While `spin` is not a drop-in replacement for `std::sync` (and [should not be considered as such](https://matklad.github.io/2020/01/02/spinlocks-considered-harmful.html) )",
            "an effort is made to keep this crate reasonably consistent with `std::sync` .",
            "Many of the types defined in this crate have ‘additional capabilities’ when compared to `std::sync`",
            "`portable-atomic` enables usage of the `portable-atomic` crate",
            "to support platforms without native atomic operations (Cortex-M0, etc.).",
            "See the documentation for the `portable-atomic` crate for more information",
            "with some requirements for no-std build:",
            "https://github.com/taiki-e/portable-atomic",
            "Because synchronization is done through spinning,\nthe primitives are suitable for use in `no_std` environments.",
            "Because synchronization is done through spinning,\nthe primitives are suitable for use in `no_std` environments."
          ]
        },
        {
          "title": "Reddit: What's a good Mutex to use for #![no_std]?",
          "url": "https://www.reddit.com/r/rust/comments/dfmv25/whats_a_good_mutex_to_use_for_no_std/",
          "excerpts": [
            "/)\n\nThe 2 main options I know of are [`spin`](https://crates.io/crates/spin) and [`lock_api`](https://crates.io/crates/lock_api).",
            ". If you just want something simple, `spin`.",
            "The 2 main options I know of are [`spin`](https://crates.io/crates/spin) and [`lock_api`](https://crates.io/crates/lock_api). `spin` is seen a bit more commonly among `no_std` projects.",
            "If you just want something simple, `spin`.",
            "The 2 main options I know of are [`spin`](https://crates.io/crates/spin) and [`lock_api`](https://crates.io/crates/lock_api).",
            "The 2 main options I know of are [`spin`](https://crates.io/crates/spin) and [`lock_api`](https://crates.io/crates/lock_api).",
            "There is not one `no_std` environment. It's simply everything that is not std.",
            "There is not one `no_std` environment. It's simply everything that is not std.",
            "We're working on defining a generic no_std Mutex trait in the Embedded Working Group, you might be interested in checking it out!"
          ]
        },
        {
          "title": "spin crate - Crates.io",
          "url": "https://crates.io/crates/spin",
          "excerpts": [
            "Spin-based synchronization primitives",
            "This crate provides spin-based versions of the primitives in\nstd::sync . Because synchronization is done\nthrough spinning, the primitives are suitable for use in\nno_std environments.",
            "Include the following under the\n[dependencies] section in your\nCargo.toml file. spin = \"x.y\"",
            "Feature flags",
            "The crate comes with a few feature flags that you may wish to use. * mutex enables the\nMutex type. * spin_mutex enables the\nSpinMutex type. * ticket_mutex enables the\nTicketMutex type. * use_ticket_mutex switches to a ticket lock for the implementation of\nMutex . This\nis recommended only on targets for which ordinary spinning locks perform very badly\nbecause it will change the implementation used by other crates that depend on\nspin .",
            "portable-atomic enables usage of the\nportable-atomic crate\nto support platforms without native atomic operations (Cortex-M0, etc.). The\nportable_atomic_unsafe_assume_single_core or\ncritical-section feature\nof\nportable-atomic crate must also be set by the final binary crate.",
            "Remarks\nIt is often desirable to have a lock shared between threads. Wrapping the lock in an\nstd::sync::Arc is route through which this might be achieved."
          ]
        },
        {
          "title": "Benchmarking a #! [no_std] Microcontroller - embedded - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/benchmarking-a-no-std-microcontroller/50031",
          "excerpts": [
            "t\nlet mut pset = Sieve::new();",
            "There’s this very straightforward way of telling that the heap is used by a type: On the [docs page of `Sieve`](https://docs.rs/primes/0.3.0/primes/struct.Sieve.html) , you press the little “[src]” button in the top right corner, and you’ll see that indeed, the `Sieve` contains a `Vec` . No need to guess here, it clearly uses the heap. Moreover the crate doesn’t even support no-std.",
            "\n\nI found the `num_primes` crate too after your first post. What about using the [heapless](https://docs.rs/heapless/0.5.6/heapless/) crate for data structures on the stack?"
          ]
        },
        {
          "title": "IndexSet in heapless - Rust - Docs.rs",
          "url": "https://docs.rs/heapless/latest/heapless/struct.IndexSet.html",
          "excerpts": [
            "IndexSet is a fixed capacity set, generic around the hashing algorithm, and cannot be used directly. Its capacity must be a power of 2."
          ]
        },
        {
          "title": "embedded_hal_bus - Rust",
          "url": "https://docs.rs/embedded-hal-bus",
          "excerpts": [
            "embedded_hal_bus provides bus sharing utilities for embedded-hal, enabling hardware-independent adapters for sharing a single bus between multiple devices."
          ]
        },
        {
          "title": "heapless - Rust - RIOT Documentation",
          "url": "https://doc.riot-os.org/rustdoc/latest/heapless/index.html",
          "excerpts": [
            "The core principle behind heapless is that its data structures are backed by a static memory allocation. For example, you can think of heapless::Vec as an ..."
          ]
        },
        {
          "title": "alloc::sync::Arc for core - libs - Rust Internals",
          "url": "https://internals.rust-lang.org/t/alloc-arc-for-core/14368",
          "excerpts": [
            "basically I want core::sync::atomic::AtomicCounter that lets you manually increment or decrement the strong/weak counts and perhaps has some ..."
          ]
        },
        {
          "title": "Making Rust core and alloc panic free - language design",
          "url": "https://internals.rust-lang.org/t/making-rust-core-and-alloc-panic-free/18826",
          "excerpts": [
            "The core and alloc (to some extent) seem to be present to allow using Rust where only basic C or similar low-level language can be used."
          ]
        },
        {
          "title": "Attributes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/attributes.html",
          "excerpts": [
            "Doc comments are transformed into doc attributes. Preludes. no_std — Removes std from the prelude. no_implicit_prelude — Disables prelude lookups within a ..."
          ]
        },
        {
          "title": "no global memory allocator found but one is required",
          "url": "https://stackoverflow.com/questions/74012369/no-global-memory-allocator-found-but-one-is-required-link-to-std-or-add-glob",
          "excerpts": [
            "If you link with alloc you need to have a global allocator. That is usually provided by std, but if you omit the std crate then you need to provide it yourself."
          ]
        },
        {
          "title": "The Rust Alloc crate documentation",
          "url": "https://doc.rust-lang.org/alloc/",
          "excerpts": [
            "). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead.",
            "The Rust core allocation and collections library. This library provides smart pointers and collections for managing heap-allocated values.",
            "The Rust core allocation and collections library",
            "This library, like core, normally doesn’t need to be used directly\nsince its contents are re-exported in the [`std` crate](../std/index.html). Crates that use the `#! [no_std]` attribute however will typically\nnot depend on `std`, so they’d use this crate instead.",
            "dex.html) module defines the low-level interface to the\ndefault global allocator."
          ]
        },
        {
          "title": "Similar items in core and std",
          "url": "https://users.rust-lang.org/t/similar-items-in-core-and-std/60167",
          "excerpts": [
            "May 23, 2021 — As a beginner to Rust, I am a bit confused by same (similar ?) items I find in the core and std libraries. For example there is core::iter::iterator and std:: ..."
          ]
        },
        {
          "title": "Clarify std vs no-std · Issue #148 · esp-rs/book",
          "url": "https://github.com/esp-rs/book/issues/148",
          "excerpts": [
            "Mar 13, 2024 — The book currently says: When You Might Want to Use the Core Library (no_std) Small memory footprint: If your embedded system has limited ..."
          ]
        },
        {
          "title": "Help enabling `no-std` feature in a crate - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/help-enabling-no-std-feature-in-a-crate/61192",
          "excerpts": [
            "I want enable a feature in my crate for compile in a no-std environment, for this in the Cargo.toml I have: [dependencies] num = { version = \"0.4\", default- ..."
          ]
        },
        {
          "title": "What's the difference of the module core and std",
          "url": "https://users.rust-lang.org/t/whats-the-difference-of-the-module-core-and-std/2923",
          "excerpts": [
            "Sep 19, 2015 — Core should be self-contained. std depends on core , and a lot of other stuff, to provide a kind of \"facade\" to the end user."
          ]
        },
        {
          "title": "What is the rust core crate??",
          "url": "https://www.reddit.com/r/rust/comments/bpmy21/what_is_the_rust_core_crate/",
          "excerpts": [
            "The reason for both is that std is everything the language provides, but core is the subset of that which doesn't require features from the ..."
          ]
        },
        {
          "title": "Conditionally use different types based on no_std",
          "url": "https://users.rust-lang.org/t/conditionally-use-different-types-based-on-no-std/70947",
          "excerpts": [
            "Jan 27, 2022 — no_std isn't a feature of the environment; it is a modifier you can apply to your crate, removing the default dependency of your crate on the std crate."
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "\n ... ",
            "The Embedded Rust Book"
          ]
        },
        {
          "title": "What are binary crate MSRV policy best practices? : r/rust - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/zmv1j9/what_are_binary_crate_msrv_policy_best_practices/",
          "excerpts": [
            "The key thing with a binary is that if your MSRV is \"too new\" for a distro, then the distro can just package an older version of your binary that satisfies ..."
          ]
        },
        {
          "title": "How many of you actually use/look for no_std in crates?",
          "url": "https://www.reddit.com/r/rust/comments/1639zkk/how_many_of_you_actually_uselook_for_no_std_in/",
          "excerpts": [
            "I typically support no_std when authoring libraries that don't actually require std. In the most extreme case I supported embedding lookup tables."
          ]
        },
        {
          "title": "Practical guides on no_std and wasm support - tutorials",
          "url": "https://users.rust-lang.org/t/practical-guides-on-no-std-and-wasm-support/94762",
          "excerpts": [
            "I have drafted a \"Rust no_std Playbook\" summarizing my (admittedly limited) experience on making Rust libraries no_std and WASM supports."
          ]
        },
        {
          "title": "Minimum Support Rust Version (MSRV) - Hyper",
          "url": "https://hyper.rs/contrib/msrv/",
          "excerpts": [
            "hyper's current policy is to always support a Rust version at least 6 months old . That is, a compiler version released within the last 6 months can compile hyper. It is possible that an older compiler can work, but that is not guaranteed."
          ]
        },
        {
          "title": "Conventions around no_std · Issue #23 · rust-lang/api-guidelines",
          "url": "https://github.com/rust-lang/api-guidelines/issues/23",
          "excerpts": [
            "I strongly prefer std over with_std or use_std . It aligns better with the optional dependency / implicit feature mechanism. If you have an ..."
          ]
        },
        {
          "title": "The Embedded Rust book.pdf",
          "url": "https://kolegite.com/EE_library/books_and_lectures/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%80%D0%B0%D0%BD%D0%B5/Rust/The%20Embedded%20Rust%20book.pdf",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust. Programming Language on \"Bare Metal\" embedded systems, such as."
          ]
        },
        {
          "title": "The smallest #![no_std] program - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html",
          "excerpts": [
            "#![no_std] is a crate level attribute that indicates that the crate will link to the core crate instead of the std crate.See more"
          ]
        },
        {
          "title": "STM32F4 Embedded Rust at the HAL: DMA Controllers",
          "url": "https://dev.to/theembeddedrustacean/stm32f4-embedded-rust-at-the-hal-dma-controllers-daf",
          "excerpts": [
            "#! [no_std]"
          ]
        },
        {
          "title": "Portability - Rust Embedded MB2 Discovery Book",
          "url": "https://docs.rust-embedded.org/discovery-mb2/06-hello-world/portability.html",
          "excerpts": [
            "#! [no_std]",
            "One cool advantage, though, is that our code becomes really portable.",
            "Portability - Rust Embedded MB2 Discovery Book"
          ]
        },
        {
          "title": "Why I like programming for #![no_std] in Rust (even without ...",
          "url": "https://www.reddit.com/r/rust/comments/emq98r/why_i_like_programming_for_no_std_in_rust_even/",
          "excerpts": [
            "The main limitation is that you can't ever have a Vec or a HashMap or a HashSet or a Box, basically anything that goes on the heap."
          ]
        },
        {
          "title": "Bare Metal Rust on RISC-V With Dynamic Memory",
          "url": "https://popovicu.com/posts/bare-metal-rust-risc-v-with-dynamic-memory/",
          "excerpts": [
            "The memory allocation happens on a static blob of 50k bytes, marked as `ARENA`. Rust has an abstraction layer for memory allocation that can also work under the bare metal environment.",
            ". This library is the reason why we needed `#! [feature(const_mut_refs)]` above; without it, we cannot modify the statically allocated `ARENA`.",
            "Finally, I’d like to note that I’ve run into some issues with the dynamic strings, and that *may* be due to the `Talc` librar",
            "Rust code.\nRust logic\n----------\n\nAgain inside the `src` directory, we should have a file called `main.rs`. The logic of the file will be simple, we just want to write to the UART device. This is done by writing bytes to the address `0x10000000`, as simple as that. We’ll write some messages, and actually, some of them will be dynamic strings, constructed in a way similar to `sprintf` in C. What we’ll do is we’ll count the periods (and we’ll do that by busy waiting some number of iterations to emulate the sleep behavior) and we’ll write to the UART something like `Tick N`, where N is the current number of the tick. However, to use Rust’s string formatting functionality, we’ll have to use dynamic memory allocation. This is typical of the regular apps running on top of an operating system, not so much of the bare metal applications. Let’s look at the code and comment it bit by bit. ```\n#! [no_std]\n#! [no_main]\n#! [feature(const_mut_refs)]\n\nuse core::arch::global_asm;\nuse core::ptr;\nuse core::panic::PanicInfo;\nuse talc::{Talck, Talc, ClaimOnOom, Span};\n\n#[macro_use]\nextern crate alloc;\n\nglobal_asm!(include_str!\n(\"entry.s\"));\n\nstatic mut ARENA: [u8; 50000] = [0; 50000];\n\n#[global_allocator]\nstatic ALLOCATOR: Talck<spin::Mutex<()>, ClaimOnOom> = Talc::new(unsafe {ClaimOnOom::new(Span::from_array(&mut ARENA))}).lock();\n\nfn uart_print(message: &str) {\n   const UART: *mut u8 = 0x10000000 as *mut u8;\n\n   for c in message.chars() {\n       unsafe {\n       \t      ptr::write_volatile(UART, c as u8);\n       }\n   }\n}\n\n#[no_mangle]\npub extern \"C\" fn main() -> ! {\n   uart_print(\"Hello, world!\\n\");\n\n   let mut ctr = 1;\n\n   loop {\n\tlet message = format! (\"Ticks: {}\\n\", ctr);\n\tlet temp_str = message.as_str();\n\n\tuart_print(temp_str);\n\tfor _ in 0..5000000 {}\n\n\tctr += 1;\n   }\n}\n\n#[panic_handler]\nfn panic(_info: &PanicInfo) -> ! {\n   uart_print(\"Something went wrong. \");\n   loop {}\n}\n```\n\n1. We specify that we’re not in the `std` environment. The code executes on a bare metal platform, so we cannot use the standard library, for obvious reasons. 2. There is really no `main` in the traditional sense. Basically, we’re instructing the compiler to not generate any entrance/warmup code for the main and jump into it, because there is no traditional entry. This may be confusing for some. The catch here is that even though when you normally write your program, the logic begins at the `main` function, that doesn’t mean that whatever is enclosed by `main` is the only logic that the CPU executes between the start and the end of the process."
          ]
        },
        {
          "title": "Optimizing Rust Compilation: Smaller, Faster, or Both?",
          "url": "https://leapcell.medium.com/optimizing-rust-compilation-smaller-faster-or-both-1cdac7bfd93c",
          "excerpts": [
            "panic = \"abort\" # Use 'abort' instead of 'unwind' for panic handling strip = \"debuginfo\" # Remove debug information. Generate a Faster ...",
            "\n[profile.release]  \nopt-level = \"z\"       # Optimize for the smallest code size  \nlto = true            # Enable Link Time Optimization (LTO)  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but reducing binary size  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip = \"debuginfo\"   # Remove debug information\n",
            "\"thin\" : Enable Thin LTO. \"fat\" : Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. You only need to add the following configuration to your `Cargo.toml` file and run:\n\n```\ncargo b --release\n```",
            "Generate a Faster Executable\n============================\n\n```\n[profile.release]  \nopt-level = 3         # Optimize for maximum execution speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling\n```",
            "Balance Between Size and Speed\n==============================\n\n```\n[profile.release]  \nopt-level = \"s\"       # Optimize for size while considering speed  \nlto = \"fat\"           # Enable the most aggressive Link Time Optimization  \ncodegen-units = 1     # Reduce the number of code generation units, increasing optimization time but improving performance  \npanic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip =\n\"symbols\"     # Remove symbol information while retaining necessary debugging info\n```",
            "Description: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable.",
            "codegen-units\n=============\n\nDescription: Controls the number of code generation units. Default value: Usually `16`. Setting it to `1` enables the highest level of optimization. Reasoning: Reducing the number of code generation units gives the compiler more information for global optimizations, resulting in a smaller and faster executable. Setting it to `1` maximizes optimization but increases compilation time.",
            "panic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling  \nstrip =\n\"symbols\"     # Remove symbol information while retaining necessary debugging info",
            "Explanation of Configurations\n=============================\n\nopt-level\n=========\n\nDescription: Specifies the level of compiler optimizations. Possible values:\n\n* `0`: No optimization, fastest compilation time. * `1`: Optimize for faster compilation. * `2`: Balance between compilation speed and runtime performance (default). * `3`: Optimize for maximum runtime performance. * `\"s\"`: Optimize for smaller code size. * `\"z\"`: Further optimize for code size, more aggressively than `\"s\"`. Reasoning: Use `\"z\"` to generate the smallest executable; use `3` to generate the fastest executable.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "lto\n===\n\nDescription: Enables Link Time Optimization (LTO). Possible values:\n\n* `false`: Disable LTO (default). * `true`: Enable LTO. * `\"thin\"`: Enable Thin LTO. * `\"fat\"`: Enable the most aggressive LTO. Reasoning: Enabling LTO reduces binary size and improves runtime performance. `\"thin\"` is a moderate choice, while `\"fat\"` provides the best optimization but increases compilation time.",
            "strip = \"debuginfo\"   # Remove debug information",
            "lto = \"fat\"           # Enable the most aggressive Link Time Optimization",
            "panic = \"abort\"       # Use 'abort' instead of 'unwind' for panic handling",
            "strip =",
            "\"symbols\"     # Remove symbol information while retaining necessary debugging info"
          ]
        },
        {
          "title": "The Rust compiler is now compiled with (thin) LTO (finally) ...",
          "url": "https://www.reddit.com/r/rust/comments/ycmqml/the_rust_compiler_is_now_compiled_with_thin_lto/",
          "excerpts": [
            "rustc is now compiled with (thin) LTO (PR), which resulted in very nice gains across the board, and even without any noticeable regressions!See more",
            "The Rust compiler is now compiled with (thin) LTO (finally) for 5-10% improvements. There was a post about this already, apparently ..."
          ]
        },
        {
          "title": "Should default recommended opt-level for minimizing ...",
          "url": "https://internals.rust-lang.org/t/should-default-recommended-opt-level-for-minimizing-binary-size-be-s-or-z/19685",
          "excerpts": [
            "I have historically recommended opt-level = \"z\" since from the docs it seems like it should be \"s\" + also don't unroll loops (ie strictly better)."
          ]
        },
        {
          "title": "Distributed ThinLTO support in Rustc - compiler",
          "url": "https://internals.rust-lang.org/t/distributed-thinlto-support-in-rustc/22157",
          "excerpts": [
            "Having support for Distributed Thin LTO is an important thing for warehouse-like Rust applications that want to use ThinLTO as an additional optimization step.See more"
          ]
        },
        {
          "title": "Build Configuration - The Rust Performance Book",
          "url": "https://nnethercote.github.io/perf-book/build-configuration.html",
          "excerpts": [
            "If you want to minimize binary size, consider opt-level = \"z\" , codegen-units = 1 , lto = \"fat\" , panic = \"abort\" , and strip = \"symbols\" . In either case, ..."
          ]
        },
        {
          "title": "emit_stack_sizes - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html",
          "excerpts": [
            "The rustc flag -Z emit-stack-sizes makes LLVM emit stack size metadata. NOTE: This LLVM feature only supports the ELF object format as of LLVM 8.0."
          ]
        },
        {
          "title": "Cargo-call-stack Static Call-stack Analysis for Rust - IEEE Xplore",
          "url": "https://ieeexplore.ieee.org/document/8972088",
          "excerpts": [
            "In this paper we present an integrated tool for call-stack analysis of Rust applications. We cover both theoretical and practical challenges, ..."
          ]
        },
        {
          "title": "Help test out ThinLTO! - compiler",
          "url": "https://internals.rust-lang.org/t/help-test-out-thinlto/6017",
          "excerpts": [
            "Oct 9, 2017 — In this chapter of the war against Rust's long compile times we're going to take a look at LLVM optimizations and code generation."
          ]
        },
        {
          "title": "Truly abort on any panic - embedded - Rust Users Forum",
          "url": "https://users.rust-lang.org/t/truly-abort-on-any-panic/72873",
          "excerpts": [
            "I am writing code for a custom RISC-V target and I am optimizing for small code size. When any panic happens, I want the code to jump to my custom abort ..."
          ]
        },
        {
          "title": "Panic handler binary size bloat #41 - rust-embedded/wg - GitHub",
          "url": "https://github.com/rust-embedded/wg/issues/41",
          "excerpts": [
            "Panic strings kept in the binary. Even when panic_fmt (the panic handler) is defined to simply abort the compiler still produces machine code ..."
          ]
        },
        {
          "title": "(Zero cost) stack overflow protection · Issue #34",
          "url": "https://github.com/rust-embedded/cortex-m-rt/issues/34",
          "excerpts": [
            "Sep 27, 2017 — Other options for stack overflow protection · Use the MPU (Memory Protection Unit) to mark the upper boundary of the static region as read-only."
          ]
        },
        {
          "title": "What do the optimization levels `-Os` and `-Oz` do in rustc?",
          "url": "https://stackoverflow.com/questions/45608392/what-do-the-optimization-levels-os-and-oz-do-in-rustc",
          "excerpts": [
            "s means optimize for size, and z means optimize for size some more. All optimizations seem to be performed by the LLVM code-generation engine."
          ]
        },
        {
          "title": "Min-Sized Rust",
          "url": "https://github.com/johnthagen/min-sized-rust",
          "excerpts": [
            "LTO instructs the linker to optimize at the link stage. This can, for example, remove dead code and often times reduces binary size.",
            "Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true",
            "Build in Release Mode\nBy default,\ncargo build builds the Rust binary in debug mode. Debug mode disables many\noptimizations, which helps debuggers (and IDEs that run them) provide a better debugging\nexperience. Debug binaries can be 30% or more larger than release binaries. To minimize binary size, build in release mode:\n$ cargo build --release",
            "strip Symbols from Binary\nBy default on Linux and macOS, symbol information is included in the compiled\n.elf file. This\ninformation is not needed to properly execute the binary. Cargo can be configured to automatically\nstrip binaries . Modify\nCargo.toml in this way:\n[ profile . release ] strip = true # Automatically strip symbols from the binary. Prior to Rust 1.59 , run\nstrip directly on\nthe\n.elf file instead:\n$ strip target/release/min-sized-rust",
            "Optimize For Size\nCargo defaults its optimization level to\n3 for release builds ,\nwhich optimizes the binary for speed . To instruct Cargo to optimize for minimal binary size , use the\nz optimization level in\nCargo.toml :\n[ profile . release ] opt-level = \" z \" # Optimize for size.",
            "Note\nIn some cases the\n\"s\" level may result in a smaller binary than\n\"z\" , as explained in the\nopt-level documentation :\nIt is recommended to experiment with different levels to find the right balance for your project.",
            "Enable Link Time Optimization (LTO)\nBy default, Cargo instructs compilation units to be compiled and optimized in isolation . LTO instructs the linker to optimize at the\nlink stage. This can, for example, remove dead code and often times reduces binary size. Enable LTO in\nCargo.toml :\n[ profile . release ] lto = true"
          ]
        },
        {
          "title": "Cargo-call-stack: No-Std Stack Usage Analysis (ARM Cortex-M)",
          "url": "https://github.com/japaric/cargo-call-stack",
          "excerpts": [
            "In this case, cargo-call-stack will use its own stack usage analysis based on machine code, which only supports the ARM Cortex-M architecture.",
            "Hardware ... (\"\") does *not* use the stack",
            "warning: assuming that llvm_asm! (\"\") does *not* use the stack",
            "Graphviz's `dot` can then be used to generate an image from this dot file. ```",
            "$ dot -Tsvg cg.dot > cg.svg",
            "[! [Call graph with direct function calls](/japaric/cargo-call-stack/raw/main/assets/direct.png)](https://japaric.github.io/cargo-call-stack/direct.svg)",
            "Each node in this graph represents a function, which could be a free function,",
            "an inherent method or a trait method. Each directed edge indicates a \"calls\"",
            "relationship. For example, in the above graph `Reset` calls both `main` and",
            "DefaultPreInit`. Each node also contains its `local` stack usage in bytes and its `max`-imum",
            "stack usage, also in bytes. The maximum stack usage includes the stack usage of",
            "all the other functions that the function could invoke. This is the `no_std` program used to generate the call graph shown above. ```",
            "#! [feature(llvm_asm)",
            "#! [no_main",
            "#! [no_std",
            "extern crate panic_halt;",
            "use core::ptr;",
            "use cortex_m_rt::{entry, exception};",
            "#[entry]",
            "fn main() -> ! {",
            "    foo();",
            "    bar();",
            "    loop {}",
            "fn foo() {",
            "    // spill variables onto the stack",
            "#[inline(never)]",
            "#[inline(never)]",
            "fn bar() {",
            "    unsafe { llvm_asm! (\"\" : : \"r\"(0) \"r\"(1) \"r\"(2) \"r\"(3) \"r\"(4) \"r\"(5)) }",
            "    unsafe { llvm_asm! (\"\" : : \"r\"(0) \"r\"(1) \"r\"(2) \"r\"(3) \"r\"(4) \"r\"(5)) }",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Embedded Rust with Embassy UART Example",
          "url": "https://dev.to/theembeddedrustacean/embedded-rust-embassy-uart-serial-communication-4fd3",
          "excerpts": [
            "#! [no_main",
            "#! [no_std"
          ]
        },
        {
          "title": "Panic - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/panic.html",
          "excerpts": [
            "#! [no_std"
          ]
        },
        {
          "title": "etherparse/ lib.rs",
          "url": "https://docs.rs/etherparse/latest/src/etherparse/lib.rs.html",
          "excerpts": [
            "#! [no_std"
          ]
        },
        {
          "title": "Codegen Options - The rustc book - Rust Documentation",
          "url": "https://doc.rust-lang.org/rustc/codegen-options/index.html",
          "excerpts": [
            "When -C lto is not specified, LTO is disabled if codegen units is 1 or optimizations are disabled ( -C opt-level=0 ). That is: When -C lto is not specified:."
          ]
        },
        {
          "title": "Enable Link-Time Optimization (LTO) · rustcoreutils posixutils-rs ...",
          "url": "https://github.com/rustcoreutils/posixutils-rs/discussions/197",
          "excerpts": [
            "Another question - did you use Thin or Fat LTO? ThinLTO has lower build time overhead (in the price of a bit less aggressive optimizations but in practice it's ..."
          ]
        },
        {
          "title": "EventLoop::new() can panic with \"Bad File Descriptor\" #7680 - GitHub",
          "url": "https://github.com/alacritty/alacritty/issues/7680",
          "excerpts": [
            "* Use `thin` instead of `fat` LTO The performance between `thin` and `fat` is in the margin of error, however `thin` LTO is way faster to build."
          ]
        },
        {
          "title": "Rust no_std Profiling and Build Optimization (Cargo Profiles)",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "Profiles provide a way to alter the compiler settings, influencing things like optimizations and debugging symbols.",
            "Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "The valid options are:\n    * 0 : no optimizations\n    * 1 : basic optimizations\n    * 2 : some optimizations\n    * 3 : all optimizations\n    * \"s\" : optimize for binary size\n    * \"z\" : optimize for binary size, but also turn off loop vectorization.",
            "The\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary.",
            "There may be surprising results, such as level\n3 being slower than\n2 , or the\n\"s\" and\n\"z\" levels not being necessarily\nsmaller"
          ]
        },
        {
          "title": "Quickstart",
          "url": "https://probe.rs/docs/library/quickstart/",
          "excerpts": [
            "probe-rs can be used to automate your workflow. Want to do. hardware-in-the-loop testing? automatic WCET analysis? automatic firmware downloads in your project?"
          ]
        },
        {
          "title": "Continuous Integration - The Cargo Book - Rust Documentation",
          "url": "https://doc.rust-lang.org/cargo/guide/continuous-integration.html",
          "excerpts": [
            "A basic CI will build and test your projects. GitHub Actions To test your package on GitHub Actions, here is a sample .github/workflows/ci.yml file."
          ]
        },
        {
          "title": "Paired values in github actions matrix",
          "url": "https://stackoverflow.com/questions/66025220/paired-values-in-github-actions-matrix",
          "excerpts": [
            "You can nest arrays in a build matrix, but it's undocumented. Therefore, you can create an array of arrays of compilers in your job.matrix."
          ]
        },
        {
          "title": "Github Actions to build Rust Binaries Automatically - Reddit",
          "url": "https://www.reddit.com/r/rust/comments/gayd3h/github_actions_to_build_rust_binaries/",
          "excerpts": [
            "Whenever you make a release on github, it will build the binaries, and add them as release assets as seen here."
          ]
        },
        {
          "title": "embedded_crc_macros - Rust",
          "url": "https://docs.rs/embedded-crc-macros",
          "excerpts": [
            "This crate provides macros that define portable CRC-8 algorithm implementations with the parameters directly provided at compile time and without any dependencies. Intended for use in `no_std`."
          ]
        },
        {
          "title": "EEPROM emulation for MC9S08AC128 - NXP Community",
          "url": "https://community.nxp.com/t5/-/-/m-p/155694?db=5",
          "excerpts": [
            "In order to implement EEPROM emulation using Flash memory, it is required to have a Flash driver that allows erase and write the Flash. When these actions are ..."
          ]
        },
        {
          "title": "AN1095 | Application Note",
          "url": "https://www.microchip.com/en-us/application-notes/an1095",
          "excerpts": [
            "Title. AN1095 - Emulating Data EEPROM for PIC18 and PIC24 Microcontrollers and dsPIC® Digital Signal Controllers · Name. AN1095 · Date. 06/18/2025 · Description."
          ]
        },
        {
          "title": "Protected EEPROM Operations in MAXQ Environments",
          "url": "https://www.analog.com/en/resources/technical-articles/protected-eeprom-operations-in-maxq-environments.html",
          "excerpts": [
            "A problem with any type of nonvolatile storage—from EEPROM to flash to rotating storage—is data loss due to interrupted write cycles. If power ..."
          ]
        },
        {
          "title": "apache/mynewt-nffs",
          "url": "https://github.com/apache/mynewt-nffs",
          "excerpts": [
            "The Newtron Flash File System (NFFS) is a flash file system with the following priorities: Minimal RAM usage; Reliability. RTOS support. NFFS currently supports ..."
          ]
        },
        {
          "title": "Mynewt Documentation",
          "url": "https://mynewt.apache.org/Mynewt.pdf",
          "excerpts": [
            "Sep 26, 2024 — Apache Mynewt is an operating system that makes it easy to develop applications for microcontroller environments."
          ]
        },
        {
          "title": "pellepl/spiffs: Wear-leveled SPI flash file system for ...",
          "url": "https://github.com/pellepl/spiffs",
          "excerpts": [
            "Spiffs is a file system intended for SPI NOR flash devices on embedded targets. Spiffs is designed with following characteristics in mind."
          ]
        },
        {
          "title": "Software-Managed Read and Write Wear-Leveling for Non-Volatile ...",
          "url": "https://dl.acm.org/doi/full/10.1145/3483839",
          "excerpts": [
            "We design a method to approximate read and write accesses to the memory to allow aging aware coarse-grained wear-leveling in the absence of special hardware."
          ]
        },
        {
          "title": "nvs vs spiff vs wear_levelling",
          "url": "https://esp32.com/viewtopic.php?t=3462",
          "excerpts": [
            "Oct 29, 2017 — The \"wear leveling\" library is a layer that is applied to fatfs, which can help to avoid dead blocks. fatfs and spiffs are two different types of file ..."
          ]
        },
        {
          "title": "MSPM0G1507: Problem with eeprom emulation type B - TI E2E",
          "url": "https://e2e.ti.com/administrators1/f/1/t/1470132",
          "excerpts": [
            "I´m using the eeprom emulation type B from the MSPM0 SDK (Version 2_03_00_07) and I encounter the following problem: After running my application on the device ..."
          ]
        },
        {
          "title": "Standard practice for saving data during power off : r/embedded",
          "url": "https://www.reddit.com/r/embedded/comments/yz6mtj/standard_practice_for_saving_data_during_power_off/",
          "excerpts": [
            "I have an array of about 60 bytes that I would like retain in memory when the mcu (STM32) is powered off. Is there a standard practice for this ?"
          ]
        },
        {
          "title": "Can I write directly to flash/partition without fatfs/wear lvl etc ...",
          "url": "https://esp32.com/viewtopic.php?t=18164",
          "excerpts": [
            "Nov 18, 2020 — I am writing to 2 files in the storage section where 1 is a configuration file that only needs to be ~40 bytes and the other is for measurement logging."
          ]
        },
        {
          "title": "AN1095, Emulating Data EEPROM for PIC18/PIC24 ...",
          "url": "https://ww1.microchip.com/downloads/en/appnotes/01095c.pdf",
          "excerpts": [
            "AN1095 emulates a data EEPROM for PIC18/PIC24 MCUs and dsPIC DSCs, using program memory for non-volatile data, as an alternative to external EEPROMs."
          ]
        },
        {
          "title": "AN4894 Application Note: EEPROM Emulation on STM32 ...",
          "url": "https://www.studocu.com/row/document/shahid-chamran-university-of-ahvaz/electronic/an4894-how-to-use-eeprom-emulation-on-stm32-mcus-stmicroelectronics/114451547",
          "excerpts": [
            "Simple API consisting of a few functions to format, initialize, read and write data, and clean up flash memory pages. • At least two flash memory pages to be ..."
          ]
        },
        {
          "title": "Data EEPROM Emulation Library (DEE) for dsPIC33 DSCs ...",
          "url": "https://www.microchip.com/en-us/software-library/dspic33-pic24-data-eeprom-emulation",
          "excerpts": [
            "The DEE library implementation is based on Application Note AN1095 - Emulating Data EEPROM for PIC24 Microcontrollers and dsPIC® Digital Signal Controllers."
          ]
        },
        {
          "title": "NVS Documentation (ESP-IDF) - ESP32 Non-Volatile Storage",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/nvs_flash.html",
          "excerpts": [
            "NVS component includes flash wear levelling by design.",
            "Set operations are appending new data to the free space after existing entries.",
            "Invalidation of old values doesn't require immediate flash erase operations.",
            "The organization of NVS space to pages and entries effectively reduces the frequency of flash erase to flash write operations by a factor of 126."
          ]
        },
        {
          "title": "ESP-IDF Wear Leveling Documentation",
          "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/wear-levelling.html",
          "excerpts": [
            "The wear levelling component provides API functions related to reading, writing, erasing, and memory mapping of data in external SPI flash through the partition ... memory sector. ",
            "The wear levelling component helps to distribute wear and tear among sectors more evenly without requiring any attention from the user.",
            "The wear levelling component, together with the FAT FS component, uses FAT FS sectors of 4096 bytes, which is a standard size for flash memory.",
            "With this size, the component shows the best performance but needs additional memory in RAM.",
            "*Performance mode. ** Erase sector operation data is stored in RAM, the sector is erased, and then data is copied back to flash memory. However, if a device is powered off for any reason, all 4096 bytes of data is lost.",
            "  **Safety mode. ** The data is first saved to flash memory, and after the sector is erased, the data is saved back. If a device is powered off, the data can be recovered as soon as the device boots up.",
            "The wear levelling component does not cache data in RAM."
          ]
        },
        {
          "title": "AN4868 EEPROM emulation (NXP)",
          "url": "https://www.nxp.com/docs/en/application-note/AN4868.pdf",
          "excerpts": [
            "During the block swap\nprocedure, if a critical error occurs or if power is removed from the device before the software can write every record back\ninto flash memory, the data in these records will be lost.",
            "For most applications, a minimum of two flash blocks is\nrecommended so that a non-volatile copy of the data is always available to recover from such issues.",
            "5.4 Cyclic redundancy check",
            "In addition to hardware ECC, the EEPROM emulation software can include a cyclic redundancy check (CRC) to detect",
            "record errors.",
            "CRC-32-IEEE standard"
          ]
        },
        {
          "title": "littlefs2 - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/littlefs2",
          "excerpts": [
            "Idiomatic Rust API for the littlefs microcontroller filesystem by Chris Haster. Number 2 refers to the on-disk format version, supporting inline files."
          ]
        },
        {
          "title": "nRF5 SDK v12.1.0: Experimental: Flash Data Storage",
          "url": "https://docs.nordicsemi.com/bundle/sdk_nrf5_v12.1.0/page/lib_fds.html",
          "excerpts": [
            "Jun 27, 2024 — The Flash Data Storage (FDS) module is a minimalistic file system for the flash storage on the chip that minimizes the risk of data corruption ..."
          ]
        },
        {
          "title": "Non-Volatile Storage (NVS) - Zephyr Project Documentation",
          "url": "https://docs.zephyrproject.org/latest/services/storage/nvs/nvs.html",
          "excerpts": [
            "The flash area is divided into sectors. Elements are appended to a sector until storage space in the sector is exhausted. Then a new sector in the flash area is ..."
          ]
        },
        {
          "title": "An4894 Eeprom Emulation Techniques and Software For ...",
          "url": "https://www.scribd.com/document/647540745/an4894-eeprom-emulation-techniques-and-software-for-stm32-microcontrollers-stmicroelectronics",
          "excerpts": [
            "4.2 Wear leveling algorithm and Flash page allocation. A wear leveling algorithm allows monitoring and even distribution of Flash Write and Erase operations ..."
          ]
        },
        {
          "title": "EEPROM wear leveling algorithm",
          "url": "https://electronics.stackexchange.com/questions/742939/eeprom-wear-leveling-algorithm",
          "excerpts": [
            "I am using an EEPROM to store some configurations for the MCU logic that must be retained if a power down condition occurs."
          ]
        },
        {
          "title": "embedded_storage::nor_flash - Rust",
          "url": "https://docs.rs/embedded-storage/latest/embedded_storage/nor_flash/index.html",
          "excerpts": [
            "The `nor_flash` module provides technology-specific traits for NOR Flashes, including `NorFlash`, `ReadNorFlash`, and `MultiwriteNorFlash` traits."
          ]
        },
        {
          "title": "Storage in embedded_storage - Rust",
          "url": "https://docs.rs/embedded-storage/latest/embedded_storage/trait.Storage.html",
          "excerpts": [
            "Write a slice of data to the storage peripheral, starting the write operation at the given address offset (between 0 and self.capacity() )."
          ]
        },
        {
          "title": "Sequential-storage － Efficiently Store Data in Flash | Interrupt",
          "url": "https://interrupt.memfault.com/blog/sequential-storage-crate",
          "excerpts": [
            "A discussion of a sequential storage crate which can be used in Rust projects for efficiently storing data in NOR flash."
          ]
        },
        {
          "title": "crc-any - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/crc-any/2.0.0",
          "excerpts": [
            "Jul 6, 2019 — To compute CRC values by providing the length of bits, expression, reflection, an initial value and a final xor value. It has many built-in CRC functions."
          ]
        },
        {
          "title": "crc-any - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/crc-any",
          "excerpts": [
            "May 1, 2024 — To compute CRC values by providing the length of bits, expression, reflection, an initial value and a final xor value. It has many built-in CRC functions."
          ]
        },
        {
          "title": "Rust implementation of CRC.",
          "url": "https://lib.rs/crates/crc",
          "excerpts": [
            "no-std crc. Rust implementation of CRC with support of various standards. by Rui Hu, Akhil Velagapudi and 17 contributors · Audit · Install · API reference ..."
          ]
        },
        {
          "title": "New non-volatile storage system · Issue #77929 - GitHub",
          "url": "https://github.com/zephyrproject-rtos/zephyr/issues/77929",
          "excerpts": [
            "This storage needs to support millions of entries with solid CRC protection and multiple advanced features. Problem description. In Zephyr, ..."
          ]
        },
        {
          "title": "Non-volatile storage best practices (Zephyr / NCS) - Nordic DevZone",
          "url": "https://devzone.nordicsemi.com/f/nordic-q-a/81154/non-volatile-storage-best-practices-zephyr-ncs",
          "excerpts": [
            "Fill in the sector size and sector count and calculate the expected life time: SECTOR_COUNT * SECTOR_SIZE * 10000 / (0,01667 * (30+8)) minutes."
          ]
        },
        {
          "title": "littlefs2-sys - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/littlefs2-sys",
          "excerpts": [
            "Low-level bindings to the littlefs microcontroller filesystem. You probably want the high-level, idiomatic Rust bindings: littlefs2."
          ]
        },
        {
          "title": "Is there a general algorithm for microcontroller EEPROM ...",
          "url": "https://stackoverflow.com/questions/10667491/is-there-a-general-algorithm-for-microcontroller-eeprom-wear-leveling",
          "excerpts": [
            "The algorithm is very simple: set a \"dirty\" bit in every element you write, and scan for this bit when you need to read the last element or write a new one."
          ]
        },
        {
          "title": "Porting and using X-CUBE-EEPROM with any STM32",
          "url": "https://community.st.com/t5/stm32-mcus/porting-and-using-x-cube-eeprom-with-any-stm32/ta-p/570539",
          "excerpts": [
            "By increasing the CYCLES_NUMBER, the wear leveling algorithm used in the emulated EEPROM needs to increase the number of pages used to achieve ..."
          ]
        },
        {
          "title": "sequential-storage crate (crates.io)",
          "url": "https://crates.io/crates/sequential-storage",
          "excerpts": [
            "A crate for storing data in flash with minimal erase cycles.",
            "A key-value pair store",
            "A fifo store",
            "Item header CRC protected",
            "Item data CRC protected",
            "Power-fail safe",
            "The system is always fine or fully recoverable",
            "Wear leveling. Pages are used cyclically, so all pages get erased an equal amount. Built on embedded-storage. This is the only required ...",
            "Built on [`embedded-storage`]",
            "Wear leveling"
          ]
        },
        {
          "title": "embedded_storage - Rust",
          "url": "https://docs.rs/embedded-storage",
          "excerpts": [
            "§embedded-storage - A Storage Abstraction Layer for Embedded Systems. Storage traits to allow on and off board storage devices to read and write data."
          ]
        },
        {
          "title": "embedded_storage_file - Rust - Docs.rs",
          "url": "https://docs.rs/embedded-storage-file",
          "excerpts": [
            "Exposed interface works as NOR flash where file is used as a storage medium. Under the hood we use memory mapped file from memmap2. Interface for using just in- ..."
          ]
        },
        {
          "title": "The design of the little filesystem - MCUXpresso SDK",
          "url": "https://mcuxpresso.nxp.com/api_doc/dev/1620/a00014.html",
          "excerpts": [
            "Power-loss resilient - This is the main goal of the littlefs and the focus of this project. Embedded systems are usually designed without a shutdown routine and ..."
          ]
        },
        {
          "title": "Poor performance during lfs_file_open() and lfs_file_close ...",
          "url": "https://github.com/littlefs-project/littlefs/issues/827",
          "excerpts": [
            "May 15, 2023 — littlefs uses the on-disk state to seed each metadata block's revision count, this can lead to relocation/wear-leveling occuring at ..."
          ]
        },
        {
          "title": "Firmware updates, part 1: Bootloader",
          "url": "https://blog.drogue.io/firmware-updates-part-1/",
          "excerpts": [
            "The embassy-boot bootloader is a lightweight bootloader supporting firmware application upgrades in a power-fail-safe way, with trial boots and rollbacks."
          ]
        },
        {
          "title": "I've made a library for easy EEPROM wear-leveling ...",
          "url": "https://www.reddit.com/r/C_Programming/comments/kujhkj/ive_made_a_library_for_easy_eeprom_wearleveling/",
          "excerpts": [
            "My approach is to store a key alongside a value and always write a new value to the next free block in EEPROM. We can track where each parameter is currently ..."
          ]
        },
        {
          "title": "Flash Memory Demystified: NOR Flash Vs. NAND Flash",
          "url": "https://semiengineering.com/flash-memory-demystified-nor-flash-vs-nand-flash/",
          "excerpts": [
            "NOR Flash: Has lower storage density compared to NAND flash, which means it's less suitable for high-capacity storage applications. It is ..."
          ]
        },
        {
          "title": "eeprom24x - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/eeprom24x/0.1.1",
          "excerpts": [
            "Aug 22, 2018 — This is a platform agnostic Rust driver for the 24x series serial EEPROM, based on the embedded-hal traits. This driver allows you to: Read a ..."
          ]
        },
        {
          "title": "Secure boot for 32-bit Microcontrollers! - MCUboot",
          "url": "https://docs.mcuboot.com/design.html",
          "excerpts": [
            "The algorithm does two erase cycles on the primary slot and one on the secondary slot during each swap. Assuming that receiving a new image by the DFU ..."
          ]
        },
        {
          "title": "EEPROM wear levelling techniques",
          "url": "https://www.eevblog.com/forum/microcontrollers/eeprom-wear-levelling-techniques/",
          "excerpts": [
            "Oct 7, 2022 — Each preset has a fixed area in the EEPROM, and in each area wear leveling is done writing sequentially in 16 different slots."
          ]
        },
        {
          "title": "embedded-storage - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/embedded-storage",
          "excerpts": [
            "A Storage Abstraction Layer for Embedded Systems",
            "This crate defines a set of traits that can be implemented to provide\nnon-volatile storage of different kinds, including but not limited to EEPROM,\nNOR-flash & NAND-flash, both external and internal."
          ]
        },
        {
          "title": "Embedded-storage and no_std persistent storage discussion",
          "url": "https://github.com/rust-embedded-community/embedded-storage/issues/9",
          "excerpts": [
            "Marker trait for MultiwriteNorFlash. What we found is that most people wanting to utilize the more advanced features of a nor flash needs to ...",
            "\n\t/// Read a slice of data from the storage peripheral, starting the read",
            "/// operation at the given address, and reading `bytes.len()` bytes. ///\n\t///",
            "/\n\t///\tThis should throw an error in case `bytes.len()` will be larger than",
            "\n\t/// the peripheral end address. fn try_read(&mut self, address: u32, bytes: &mut [u8]) -> Result<(), Self::Error>;",
            "\n\t/// The capacity of the peripheral in bytes. fn capacity(&self) -> usize;",
            "}\n\n/// NOR flash trait. pub trait NorFlash<const READ_SIZE: usize, const WRITE_SIZE: usize, const ERASE_SIZE: usize>:\n\tReadNorFlash<READ_SIZE>\n{",
            "\n\t/// Erase the given storage range, clearing all data within `[from..to]`. /// The given range will contain all 1s afterwards. ///",
            "\n\t/// This should return an error if the range is not aligned to a proper",
            " erase resolution\n    ",
            "\n\t/// Erases page at addr, sets it all to 0xFF",
            "\n\t/// If power is lost during erase, contents of the page are undefined. /// `from` and `to` must both be multiples of `erase_size()` and `from` <= `to`. fn try_erase(&mut self, from: u32, to: u32) -> Result<(), Self::Error>;",
            "\n\t/// Writes data to addr, bitwise ANDing if there's already data written at that location,",
            "\n\t/// If power is lost during write, the contents of the written words are undefined. /// The rest of the page is guaranteed to be unchanged. /// It is not allowed to write to the same word twice.",
            ". fn try_write(&mut self, address: u32, bytes: &[u8]) -> Result<(), Self::Error>;",
            "\n\t/// The erase granularity of the storage peripheral",
            "\n\tfn erase_size(&self) -> usize;",
            "\n\t/// The minumum write size of the storage peripheral",
            " `fn minimum_write_size(&self) -> usize;",
            "}",
            "}"
          ]
        },
        {
          "title": "Rust Embedded Interrupts - Start/Interrupts (cortex-m-rt)",
          "url": "https://docs.rust-embedded.org/book/start/interrupts.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Hardware - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/hardware.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Memory layout - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/memory-layout.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "DESIGN.md (Zephyrproject-rtos littlefs)",
          "url": "https://github.com/zephyrproject-rtos/littlefs/blob/zephyr/DESIGN.md",
          "excerpts": [
            "Power-loss resilience** - On these systems, power can be lost at any time. If a power loss corrupts any persistent data structures, this can cause the\n   device to become unrecover",
            " wear leveling. Wear leveling is the process of distributing wear across all blocks in the\nstorage to prevent the filesystem from experiencing an early death due to\nwear on a single block in the storage.",
            "littlefs uses a statistical wear leveling algorithm. What this\nmeans is that we don’t actively track wear, instead we rely on a uniform\ndistribution of wear across storage to approximate a dynamic wear leveling\nalgorithm.",
            "Error detection can be provided with a checksum, and in littlefs's case we\nuse a 32-bit [CRC",
            "littlefs by itself does **not** provide ECC. The block nature and relatively\nlarge footprint of ECC does not work well with the dynamically sized data of\nfilesystems, correcting errors without RAM is complicated, and ECC fits better\nwith the geometry of block devi",
            "To avoid read errors, we need to be proactive, as opposed to reactive as we\nwere with write errors.\nOne way to do this is to detect when the number of errors in a block exceeds\nsome threshold, but is still recoverable. With ECC we can do this at write\ntime, and treat the error as a write error, evicting the block before fatal\nread errors have a chance to develop.",
            "The block allocator has a secondary role: wear leveling. Wear leveling is the process of distributing wear across all blocks in the\nstorage to prevent the filesystem from experiencing an early death due to\nwear on a single block in the storage.",
            "this random offset is uniform, the combined allocation\npattern is also a uniform distribution."
          ]
        },
        {
          "title": "DESIGN.html (LittleFS design overview)",
          "url": "https://mcuxpresso.nxp.com/mcuxsdk/25.09.00-pvw1/html/middleware/littlefs/DESIGN.html",
          "excerpts": [
            "1. **Power-loss resilience** - On these systems, power can be lost at any time.",
            "2. **Wear leveling** - Writing to flash is destructive. If a filesystem\n   repeatedly writes to the same block, eventually that block will wear o",
            "littlefs has two methods of protecting against wear:",
            "1. Detection and recovery from bad blocks",
            "2. Evenly distributing wear across dynamic blocks",
            "littlefs uses a statistical wear leveling algorithm.",
            "a 32-bit [CRC",
            "The embedded systems littlefs targets are usually 32-bit microcontrollers with\naround 32 KiB of RAM and 512 KiB of ROM.",
            "littlefs was originally built as an experiment to learn about filesystem design\nin the context of microcontrollers.",
            "This document covers the high-level design of littlefs, how it is different than other filesystems, and the design decisions that got us here."
          ]
        },
        {
          "title": "Tock TicKV Documentation",
          "url": "https://github.com/tock/tock/blob/master/libraries/tickv/README.md",
          "excerpts": [
            "CRC-32 checksums to check data integrity",
            "TicKV ensures durability and once a transaction has completed",
            "and been committed to flash it will remain there",
            "TicKV uses CRC-32 checksums to check data integrity",
            "requires that the flash medium allow at least two writes to a word between\nerase operations",
            "Wear leveling",
            "Fully implemented in no_std Rust",
            "Power loss resilient",
            "Maintain data integrity and detect media errors"
          ]
        },
        {
          "title": "littlefs2 Documentation",
          "url": "https://docs.rs/littlefs2",
          "excerpts": [
            "the [`Storage`](driver/trait.Storage.html) trait defines a block device in\nterms of actual and `typenum` constants, and an implementation supplies methods to read, erase and write.",
            "td`\n\nThis library is `no_std` compatible, but there are two gotchas. * The dev-dependency `memchr` of `littlefs2-sys` has its `std` features activated. To prevent this, upgrade to at least Rust 1.51\n  and add `resolver = \"2\"` in the consuming code’s `[package]` section. This will be the default in Rust 2021 edition. * At link time, `lfs.c` has a dependency on `strcpy`. When not linking to a `libc` with this symbol, activate the `c-stubs` feature\n  to provide an implementation. #### [§]()Design notes\n\nAll operations on the filesystem require passing a `&mut Storage`, which guarantees by Rust’s\nborrow checker that only one thread can manipulate the filesystem. This design choice (as opposed to consuming the Storage, which would be less verbose) was made to\nenable use of the underlying flash peripheral outside of the filesystem (the `Storage` can be\ndropped and reconstructed). For instance, one could setup an additional filesystem,\nor handle some flash data manually.",
            "The filesystem and each open file need memory for state and caching, this has to be allocated\nbeforehand and passed to constructors.",
            "All operations on the filesystem require passing a `&mut Storage`, which guarantees by Rust’s\nborrow checker that only one thread can manipulate the filesystem",
            "This library is `no_std` compatible, but there are two gotchas."
          ]
        },
        {
          "title": "TickKV No_std Persistence and IC Concepts",
          "url": "https://docs.rs/tickv",
          "excerpts": [
            "Wear leveling",
            "Fully implemented in no_std Rust",
            "Power loss resilient",
            "Maintain data integrity and detect media errors",
            "Low memory usage",
            "Low storage overhead",
            "TicKV was written to allow the Tock OS kernel to persistently store app data\non flash",
            "It was written to be generic though, so other Rust applications can\nuse it if they want",
            "TicKV is based on similar concepts as",
            "ACID characteristics",
            "TicKV provides ACID properties",
            "FlashController`\nimplementation complete all transactions in a single operatio",
            "the\nflash `write()` function must either successfully write all of the data or\nnone",
            "If the implementation completes a partial operation, then the Atomicity\nand Consistency traits will be lost",
            "If the implementation reports completion\nwhen the data hasn’t been written yet, then the Isolation trait will be lost"
          ]
        },
        {
          "title": "AN4894 How to Use EEPROM Emulation on STM32 MCUs",
          "url": "https://www.st.com/resource/en/application_note/an4894-how-to-use-eeprom-emulation-on-stm32-mcus-stmicroelectronics.pdf",
          "excerpts": [
            "ear leveling algorithm allows monitoring and even distribution of flash memory write and erase operations  \nbetween flash memory pages",
            "he EEPROM  \nemulation software always returns the latest valid data value by finding the previous value for this data stored in  \nflash memo",
            "The EEPROM emulation software is designed and validated to be robust against power failures and  \nasynchronous reset",
            "To detect corrupted data (virtual address and/or data value), a 16-bit CRC (cyclic redundancy check) has been  \nimplemented. It is based on the ANSI CRC-16 with the following polynomial: x15 + x2 + 1 (represented as  \n0x80",
            "To store 4000 individual bytes, and knowing that each page can store up to 252 elements, a set of pages must  \ncomprise 16 flash memory pages. A second set of pages, of the same size, is required to transfer data when the  \nfirst one is f",
            "When writing a variable element, it is stored with its corresponding CRC value. When reading or transferring a  \nvariable element, the CRC is computed and checked against the value stored in the variable element. If it  \nmatches, the variable element is considered as valid. In the case of a mismatch, the variable element is  \ninvali",
            "In an embedded application, it is possible that a power failure or asynchronous reset might occur while  \nprogramming or erasing the flash memory. In this case, the content of the flash memory line (if programming) or  \nthe complete flash memory page (if erasing) is unkn"
          ]
        },
        {
          "title": "Item 16: Avoid writing unsafe code - Effective Rust",
          "url": "https://effective-rust.com/unsafe.html",
          "excerpts": [
            "These features may still need a little caution to be used correctly, but the unsafe code has been encapsulated in a way that removes whole classes of problems."
          ]
        },
        {
          "title": "Stubbing - The Kani Rust Verifier",
          "url": "https://model-checking.github.io/kani/reference/experimental/stubbing.html",
          "excerpts": [
            "Stubbing (or mocking) is an unstable feature which allows users to specify that certain items should be replaced with stubs (mocks) of those items during ..."
          ]
        },
        {
          "title": "The Rustonomicon: What Unsafe Rust Can Do",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "The only things that are different in Unsafe Rust are that you can:\n\n* Dereference raw pointers\n* Call `unsafe` functions (including C functions, compiler intrinsics, and the raw allocator)\n* Implement `unsafe` traits\n* Access or modify mutable statics\n* Access fields of `union` s\n\nThat's it. The reason these operations are relegated to Unsafe is that misusing\nany of these things will cause the ever dreaded Undefined Behavior. Invoking\nUndefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program. You definitely _should not_ invoke Undefined Behavior. Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)\nFor a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) . \"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation. A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers. That's it. That's all the causes of Undefined Behavior baked into Rust. Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.\nSome additional constraints may also derive from compiler\nintrinsics that make special assumptions about how code can be optimized. For instance,\nVec and Box make use of intrinsics that require their pointers to be non-null at all times. Rust is otherwise quite permissive with respect to other dubious operations. Rust considers it \"safe\" to:\n\n* Deadlock\n* Have a [race condition](races.html)\n* Leak memory\n* Overflow integers (with the built-in operators such as `+` etc.) * Abort the program\n* Delete the production database\n\nFor more detailed information, you may refer to [the reference](../reference/behavior-not-considered-unsafe.html) . However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent."
          ]
        },
        {
          "title": "Rust Verification Tools for Std Safety Verification",
          "url": "https://rust-lang.github.io/rust-project-goals/2024h2/std-verification.html",
          "excerpts": [
            "Virtually every verification tool has its own contract specification language,\nwhich makes it hard to combine tools to verify the same system."
          ]
        },
        {
          "title": "Model-checking/verify-rust-std and related verification tools",
          "url": "https://github.com/model-checking/verify-rust-std",
          "excerpts": [
            "The goal is to have a verified Rust standard library and prove that it is safe. A",
            "This repository is a fork of the official Rust programming\nlanguage repository, created solely to verify the Rust standard\nlibrary.",
            "For questions, suggestions or feedback, feel free to open an [issue here"
          ]
        },
        {
          "title": "Nondeterministic variables - The Kani Rust Verifier",
          "url": "https://model-checking.github.io/kani/tutorial-nondeterministic-variables.html",
          "excerpts": [
            "Kani is able to reason about programs and their execution paths by allowing users to create nondeterministic (also called symbolic) values using kani::any() ."
          ]
        },
        {
          "title": "prusti-std - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/prusti-std",
          "excerpts": [
            "Sep 4, 2023 — Provides specifications for std functions. By importing this and adding extern crate prusti_std; to your root file, one can avoid needing to ..."
          ]
        },
        {
          "title": "About | Rust Verification Tools",
          "url": "https://project-oak.github.io/rust-verification-tools/about.html",
          "excerpts": [
            "Verification tools don't support every intrinsic function for every architecture: so they may reject hand-vectorized code. This article describes how to bypass ..."
          ]
        },
        {
          "title": "Havelsan's Revenue in 2024",
          "url": "https://aws.amazon.com/blogs/opensource/how-open-source-projects-are-using-kani-to-write-better-software-in-rust/",
          "excerpts": [
            " It also supports the typical features of date time management libraries, like the formatting and parsing of date times in a no-std environment using the typical C89 tokens",
            "It is useful wherever a monotonic clock is needed, even in the presence of leap seconds or remote time corrections (like for Network Time Protocol or Precise Time Protocol).",
            "This blog post on the Kani Rust Verifier Blog shows how Kani helped solve a number of important non-trivial bugs in hifitime.",
            "analysis of the code using Kani has proven a valuable defense-in-depth measure for Firecracker, nicely complementing the existing testing infrastructure."
          ]
        },
        {
          "title": "Rust on an STM32 microcontroller",
          "url": "https://medium.com/digitalfrontiers/rust-on-a-stm32-microcontroller-90fac16f6342",
          "excerpts": [
            "Consider following this pattern by implementing unsafe features in encapsulated parts of the code that are well-tested and hard to use wrong."
          ]
        },
        {
          "title": "Learning Rust",
          "url": "https://lwn.net/Articles/1007981/",
          "excerpts": [
            "As long as `unsafe` blocks uphold the invariants, they are safe globally. And if you violate invariants inside the `unsafe` blocks, then the ..."
          ]
        },
        {
          "title": "verus-lang/verus: Verified Rust for low-level systems code",
          "url": "https://github.com/verus-lang/verus",
          "excerpts": [
            "Verus is a tool for verifying the correctness of code written in Rust. Developers write specifications of what their code should do.See more"
          ]
        },
        {
          "title": "A List of companies that use formal verification methods in software ...",
          "url": "https://github.com/ligurio/practical-fm",
          "excerpts": [
            "... CBMC Model Checking Boot Code ... Blockchain, Distributed Systems, Quint Quint specification language, TLA+ Apalache, Symbolic Model Checker for TLA+, Rust ..."
          ]
        },
        {
          "title": "Using the C Bounded Model Checker as a TLA+ - Philip Zucker",
          "url": "https://www.philipzucker.com/high_cbmc/",
          "excerpts": [
            "CBMC is a tool I'm pretty bullish on. It is a bounded model checker for C code. It more or less unrolls all loops in normal compileable C to ..."
          ]
        },
        {
          "title": "fips203 - Rust",
          "url": "https://docs.rs/fips203",
          "excerpts": [
            "This crate implements the released FIPS 203 standard in pure Rust with minimal and mainstream dependencies, and without any unsafe code. All three security ..."
          ]
        },
        {
          "title": "Is there anything that can be done to make rust embedded ...",
          "url": "https://www.reddit.com/r/rust/comments/15i1ntk/is_there_anything_that_can_be_done_to_make_rust/",
          "excerpts": [
            "Despite being relatively young, Rust has a wonderful collection of useful no_std libraries: serde and minicbor for sending custom messages ..."
          ]
        },
        {
          "title": "Unsafe register access option. · Issue #714 · rust-embedded/svd2rust",
          "url": "https://github.com/rust-embedded/svd2rust/issues/714",
          "excerpts": [
            "Following the definition of unsafety as described in Ferrocene spec and Rust reference, unsafe code may result in undefined behavior."
          ]
        },
        {
          "title": "https://rust-training.ferrous-systems.com/latest/book/kani",
          "url": "https://rust-training.ferrous-systems.com/latest/book/kani",
          "excerpts": [
            " [Building Robust Programs with Kani",
            " [Rust Guarantees are Very Strong",
            "\n* No `null` \\-dereferencing",
            "* No uninitialized memory access",
            "* No use-after-free",
            "* No double-free",
            "* No data races",
            "\"Does my program panic ?\" is a hard question in Rust",
            "panic-never. triggers a linker error if there's panicking code path in the binary"
          ]
        }
      ],
      "reasoning": "The provided text describes a multi-layered testing strategy for `no_std` Rust, covering host-side, emulation-based, and hardware-based testing. Each layer is supported by specific tools and techniques mentioned in the excerpts. \n\nFor **Host-Side Testing**, the strategy involves conditionally enabling the `std` library for test builds. Several excerpts discuss how to achieve this using `cfg` attributes and feature flags, allowing the use of standard testing tools. For instance, it is noted that integration tests are compiled separately and depend on `std` by default, and that a `std` feature can be used to enable `std` for testing purposes. The `embedded-hal-mock` crate is explicitly mentioned as a tool for mocking hardware interactions, enabling testing of drivers without physical hardware by defining expected transactions and verifying them.\n\nFor **Emulation-Based Testing**, QEMU is highlighted as a key tool for running compiled firmware on simulated target architectures like ARM Cortex-M or RISC-V. Excerpts detail how to configure QEMU as a `runner` in `Cargo.toml` and enable semihosting for debug output to the host console. This allows for testing code closer to the hardware, including interrupt handlers and basic peripheral interactions, without needing physical devices.\n\nFor **Hardware-Based Testing**, the `probe-rs` ecosystem is presented as the modern, Rust-native toolchain. `cargo-flash` is mentioned for simple flashing, while `cargo-embed` provides a comprehensive workflow including flashing, RTT logging, and GDB server functionality for debugging. The `defmt` framework is identified as the idiomatic choice for efficient logging, sending compressed data over RTT to the host. `defmt-test` is specified as a test harness for automated on-target testing, reporting results via `defmt` logs. The concept of programmatic fault injection and ISR simulation using a debugger to manipulate memory-mapped registers of interrupt controllers (like NVIC) is also mentioned as an advanced technique.\n\nCollectively, these excerpts provide a comprehensive overview of the described multi-layered testing strategy, detailing the tools, techniques, and underlying principles for each layer.",
      "confidence": "high"
    }
  ],
  "outputSchema": {
    "type": "object",
    "properties": {
      "executive_summary": {
        "type": "object",
        "properties": {
          "overview": {
            "type": "string",
            "description": "A concise high-level summary of the topic."
          },
          "key_highlights": {
            "type": "string",
            "description": "Highlights of the main idea and findings."
          }
        },
        "required": [
          "overview",
          "key_highlights"
        ],
        "additionalProperties": false
      },
      "learning_curriculum_and_diagram_strategy": {
        "type": "object",
        "properties": {
          "structured_curriculum": {
            "type": "string",
            "description": "A detailed guide to teaching the topic effectively."
          },
          "diagram_taxonomy": {
            "type": "string",
            "description": "A classification of diagram types and uses."
          }
        },
        "required": [
          "structured_curriculum",
          "diagram_taxonomy"
        ],
        "additionalProperties": false
      },
      "foundational_concepts_and_project_setup": {
        "type": "string",
        "description": "Explains the core concepts of `no_std` vs `std`, the `core` and `alloc` crates, and the essential setup for a bare-metal project. Includes examples on setting up `#![no_std]`, `#![no_main]`, custom entry points (`#[entry]`), and mandatory panic handlers (`panic-halt`, `panic-probe`)."
      },
      "memory_management_and_allocators": {
        "type": "object",
        "properties": {
          "stack_memory_management": {
            "type": "string",
            "description": "Details on managing stack memory."
          },
          "memory_allocator_comparison": {
            "type": "string",
            "description": "Comparison of different allocator types."
          }
        },
        "required": [
          "stack_memory_management",
          "memory_allocator_comparison"
        ],
        "additionalProperties": false
      },
      "error_handling_and_observability": {
        "type": "string",
        "description": "Details idiomatic error handling without `std`. Covers the use of `Result`/`Option`, custom lightweight error enums, and non-panicking API design. Explains logging and tracing strategies using `defmt` and semihosting, and patterns for non-blocking operations with the `nb` crate."
      },
      "concurrency_atomics_and_synchronization": {
        "type": "string",
        "description": "Explains concurrency primitives available in `core::sync::atomic`. Covers memory orderings, fences, and the use of `portable-atomic` for broader architecture support. Details safe shared-state patterns using critical sections (`critical-section` crate) and contrasts them with spinlocks and the RTIC framework's priority-based locking."
      },
      "interrupts_and_exception_handling": {
        "type": "string",
        "description": "Covers defining and managing Interrupt Service Routines (ISRs) and exceptions on ARM Cortex-M and RISC-V. Explains the use of `#[interrupt]` and `#[exception]` attributes, configuring controllers (NVIC/PLIC), and safe ISR-to-main communication using lock-free SPSC queues (`heapless::spsc`)."
      },
      "memory_mapped_io_and_register_abstraction": {
        "type": "string",
        "description": "Details safe interaction with hardware registers (MMIO). Covers the use of `read_volatile`/`write_volatile`, the role of `svd2rust`-generated Peripheral Access Crates (PACs), and building safe, zero-cost wrappers. Explains the typestate pattern for encoding peripheral state into types."
      },
      "driver_development_with_embedded_hal": {
        "type": "string",
        "description": "A guide to implementing and consuming `embedded-hal` traits for peripherals like GPIO, I2C, SPI, and UART. Compares blocking, non-blocking (`nb`), and asynchronous (`async`) driver designs and discusses how to write portable, platform-agnostic drivers."
      },
      "toolchain_linking_and_memory_layout": {
        "type": "string",
        "description": "Explains the `no_std` build and linking process. Covers the role of linker scripts (`memory.x`), placing data in specific memory sections with `#[link_section]`, and configuring stack/heap layout. Details startup code provided by `cortex-m-rt` and `riscv-rt`."
      },
      "testing_simulation_and_debugging": {
        "type": "string",
        "description": "Outlines a multi-layered testing strategy for `no_std` code. Covers host-side unit testing with mocks (`embedded-hal-mock`), emulation with QEMU, and on-target testing and debugging using the `probe-rs` ecosystem (`cargo-embed`, `defmt-test`)."
      },
      "foreign_function_interface_integration": {
        "type": "string",
        "description": "Covers integrating C and assembly code into a `no_std` Rust project. Explains `extern \"C\"`, `#[repr(C)]`, using `build.rs` with the `cc` crate, and generating bindings with `bindgen` for a `no_std` target. Discusses safety at the FFI boundary."
      },
      "inline_assembly_and_architecture_intrinsics": {
        "type": "string",
        "description": "Details the use of low-level CPU features. Explains the `asm!` macro for inline assembly (e.g., `wfi`, `cpsid`) and the use of `core::arch` for vendor-specific intrinsics on ARM, RISC-V, and x86_64. Contrasts these with safer abstractions provided by HAL crates."
      },
      "portability_and_conditional_compilation": {
        "type": "string",
        "description": "Strategies for writing a single codebase that supports multiple MCUs and architectures. Covers `#[cfg]` patterns (by `target_arch`, `feature`), trait-driven design with `embedded-hal`, and CI strategies for build matrices."
      },
      "persistent_storage_on_flash_and_eeprom": {
        "type": "string",
        "description": "Covers patterns for non-volatile storage. Explains the `embedded-storage` traits, wear-leveling techniques, data integrity with CRCs, and power-fail safe designs. Discusses `no_std` filesystems like LittleFS and key-value stores."
      },
      "networking_stacks_and_zero_copy_patterns": {
        "type": "string",
        "description": "Explains networking in a `no_std` environment. Covers zero-copy packet parsing (`etherparse`), checksums, and integrating lightweight TCP/IP stacks like `smoltcp`. Details DMA buffer ownership models for high-performance network drivers."
      },
      "bare_metal_os_kernel_development_basics": {
        "type": "string",
        "description": "An introduction to OS kernel development concepts in `no_std` Rust, focusing on x86_64. Covers bootloader handoffs (Multiboot2/UEFI), setting up GDT/IDT, basic paging, and implementing frame/slab allocators."
      },
      "safety_verification_and_formal_methods": {
        "type": "string",
        "description": "Discusses advanced safety and verification techniques. Covers patterns for encapsulating `unsafe` code, using the typestate pattern to enforce invariants, and applying tools like Miri (for UB detection) and Kani (model checking) to `no_std` code."
      },
      "performance_optimization_and_benchmarking": {
        "type": "string",
        "description": "Covers techniques for optimizing and measuring performance, determinism, and code size. Explains cycle-accurate benchmarking with DWT/PMU, `Cargo.toml` profile settings (LTO, `opt-level`), and static analysis of stack usage with `cargo-call-stack`."
      },
      "real_world_design_case_studies": {
        "type": "string",
        "description": "Compares alternative designs for common subsystems like UART or SPI drivers. Analyzes the trade-offs between polling, interrupt-driven, and DMA-based approaches in terms of latency, CPU usage, code size, and implementation complexity."
      }
    },
    "required": [
      "executive_summary",
      "learning_curriculum_and_diagram_strategy",
      "foundational_concepts_and_project_setup",
      "memory_management_and_allocators",
      "error_handling_and_observability",
      "concurrency_atomics_and_synchronization",
      "interrupts_and_exception_handling",
      "memory_mapped_io_and_register_abstraction",
      "driver_development_with_embedded_hal",
      "toolchain_linking_and_memory_layout",
      "testing_simulation_and_debugging",
      "foreign_function_interface_integration",
      "inline_assembly_and_architecture_intrinsics",
      "portability_and_conditional_compilation",
      "persistent_storage_on_flash_and_eeprom",
      "networking_stacks_and_zero_copy_patterns",
      "bare_metal_os_kernel_development_basics",
      "safety_verification_and_formal_methods",
      "performance_optimization_and_benchmarking",
      "real_world_design_case_studies"
    ],
    "additionalProperties": false
  }
}