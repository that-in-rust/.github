#!/bin/bash

# git-union-merge - Atomic union merge tool for multiple Git branches
# Version: 1.0.0
# Author: Git Union Merge Tool

set -euo pipefail

# Global variables
readonly SCRIPT_NAME="git-union-merge"
readonly VERSION="1.0.0"

# Command flags
DRY_RUN=false
EXECUTE=false
ROLLBACK=false
VERBOSE=false
CONFIG_FILE=""

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_INVALID_ARGS=2
readonly EXIT_GIT_ERROR=3
readonly EXIT_CONFIG_ERROR=4
readonly EXIT_CONFLICT_ERROR=5
readonly EXIT_CHECKPOINT_ERROR=6
readonly EXIT_VALIDATION_ERROR=7

# Global state variables
OUTPUT_FORMAT="text"  # text or json
TEMP_FILES=()
TEMP_DIRS=()
WORKTREES=()
CLEANUP_REGISTERED=false

# Display help information
show_help() {
    cat << EOF
$SCRIPT_NAME - Atomic union merge tool for multiple Git branches

USAGE:
    $SCRIPT_NAME [OPTIONS]

OPTIONS:
    -h, --help          Show this help message and exit
    -d, --dry-run       Preview the merge operation without executing
    -x, --execute       Execute the union merge operation
    -r, --rollback      Rollback the last union merge operation
    -c, --config FILE   Use specified configuration file (default: .git-union-merge.json)
    -v, --verbose       Enable verbose output
    --json              Output results in JSON format
    --version           Show version information

EXAMPLES:
    $SCRIPT_NAME --dry-run              # Preview merge operation
    $SCRIPT_NAME --execute              # Execute union merge
    $SCRIPT_NAME --rollback             # Rollback last merge
    $SCRIPT_NAME --config custom.json  # Use custom config file
    $SCRIPT_NAME --verbose --dry-run    # Verbose preview

DESCRIPTION:
    This tool performs atomic union merges of multiple feature branches into the main branch.
    It intelligently resolves conflicts, preserves commit history, and provides rollback capability.

    The tool operates in three main modes:
    - Preview mode (--dry-run): Analyze branches and conflicts without making changes
    - Execute mode (--execute): Perform the actual union merge operation
    - Rollback mode (--rollback): Restore repository to pre-merge state

EOF
}

# Display version information
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Parse command line arguments
parse_arguments() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit $EXIT_SUCCESS
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -x|--execute)
                EXECUTE=true
                shift
                ;;
            -r|--rollback)
                ROLLBACK=true
                shift
                ;;
            -c|--config)
                if [[ -n "${2:-}" ]]; then
                    CONFIG_FILE="$2"
                    shift 2
                else
                    echo "Error: --config requires a file path" >&2
                    exit $EXIT_INVALID_ARGS
                fi
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --json)
                OUTPUT_FORMAT="json"
                shift
                ;;
            --version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Use '$SCRIPT_NAME --help' for usage information." >&2
                exit $EXIT_INVALID_ARGS
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                echo "Use '$SCRIPT_NAME --help' for usage information." >&2
                exit $EXIT_INVALID_ARGS
                ;;
        esac
    done
}

# Validate command line arguments
validate_arguments() {
    local mode_count=0
    
    # Count how many modes are specified
    [[ "$DRY_RUN" == true ]] && ((mode_count++))
    [[ "$EXECUTE" == true ]] && ((mode_count++))
    [[ "$ROLLBACK" == true ]] && ((mode_count++))
    
    # Ensure exactly one mode is specified
    if [[ $mode_count -eq 0 ]]; then
        echo "Error: Must specify one of --dry-run, --execute, or --rollback" >&2
        echo "Use '$SCRIPT_NAME --help' for usage information." >&2
        exit $EXIT_INVALID_ARGS
    elif [[ $mode_count -gt 1 ]]; then
        echo "Error: Cannot specify multiple modes simultaneously" >&2
        echo "Use '$SCRIPT_NAME --help' for usage information." >&2
        exit $EXIT_INVALID_ARGS
    fi
    
    # Validate config file if specified
    if [[ -n "$CONFIG_FILE" && ! -f "$CONFIG_FILE" ]]; then
        echo "Error: Configuration file '$CONFIG_FILE' not found" >&2
        exit $EXIT_INVALID_ARGS
    fi
}

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

# Log levels: DEBUG=0, INFO=1, WARN=2, ERROR=3
readonly LOG_DEBUG=0
readonly LOG_INFO=1
readonly LOG_WARN=2
readonly LOG_ERROR=3

# Current log level (INFO by default, DEBUG if verbose)
LOG_LEVEL=$LOG_INFO

# Set log level based on verbosity
set_log_level() {
    if [[ "$VERBOSE" == true ]]; then
        LOG_LEVEL=$LOG_DEBUG
    else
        LOG_LEVEL=$LOG_INFO
    fi
}

# Internal logging function with level checking
_log() {
    local level=$1
    local level_name=$2
    local color_code=$3
    shift 3
    
    if [[ $level -ge $LOG_LEVEL ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        if [[ -t 2 ]]; then  # If stderr is a terminal, use colors
            echo -e "\033[${color_code}m[$level_name] $timestamp: $*\033[0m" >&2
        else
            echo "[$level_name] $timestamp: $*" >&2
        fi
    fi
}

# Public logging functions
log_debug() {
    _log $LOG_DEBUG "DEBUG" "36" "$@"  # Cyan
}

log_info() {
    _log $LOG_INFO "INFO" "32" "$@"   # Green
}

log_warn() {
    _log $LOG_WARN "WARN" "33" "$@"   # Yellow
}

log_error() {
    _log $LOG_ERROR "ERROR" "31" "$@" # Red
}

# Verbose logging (alias for debug when verbose mode is enabled)
log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        log_debug "$@"
    fi
}

# ============================================================================
# ERROR HANDLING AND REPORTING
# ============================================================================

# Structured error reporting with JSON support
report_error() {
    local error_type="$1"
    local error_msg="$2"
    local suggestions="${3:-}"
    local exit_code="${4:-$EXIT_GENERAL_ERROR}"
    
    log_error "$error_type: $error_msg"
    
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        local json_output
        json_output=$(cat << EOF
{
  "success": false,
  "error": {
    "type": "$error_type",
    "message": "$error_msg",
    "exit_code": $exit_code,
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
EOF
)
        if [[ -n "$suggestions" ]]; then
            json_output+=", \"suggestions\": \"$suggestions\""
        fi
        json_output+="}"
        echo "$json_output"
    else
        [[ -n "$suggestions" ]] && echo "Suggestions: $suggestions" >&2
    fi
}

# Specific error handlers
handle_git_error() {
    local error_msg="$1"
    local suggestions="Check Git repository state and permissions. Ensure you're in a valid Git repository."
    cleanup_on_exit
    report_error "GIT_ERROR" "$error_msg" "$suggestions" $EXIT_GIT_ERROR
    exit $EXIT_GIT_ERROR
}

handle_config_error() {
    local error_msg="$1"
    local suggestions="Verify configuration file syntax. Use 'jq .' to validate JSON format."
    cleanup_on_exit
    report_error "CONFIG_ERROR" "$error_msg" "$suggestions" $EXIT_CONFIG_ERROR
    exit $EXIT_CONFIG_ERROR
}

handle_conflict_error() {
    local file="$1"
    local error_msg="$2"
    local suggestions="Manually resolve conflicts in $file, or exclude problematic branches in configuration."
    cleanup_on_exit
    report_error "CONFLICT_ERROR" "$error_msg" "$suggestions" $EXIT_CONFLICT_ERROR
    exit $EXIT_CONFLICT_ERROR
}

handle_checkpoint_error() {
    local error_msg="$1"
    local suggestions="Check disk space and permissions in .git directory. Manual recovery may be required."
    cleanup_on_exit
    report_error "CHECKPOINT_ERROR" "$error_msg" "$suggestions" $EXIT_CHECKPOINT_ERROR
    exit $EXIT_CHECKPOINT_ERROR
}

handle_validation_error() {
    local error_msg="$1"
    local suggestions="Ensure repository is in clean state and all dependencies are available."
    cleanup_on_exit
    report_error "VALIDATION_ERROR" "$error_msg" "$suggestions" $EXIT_VALIDATION_ERROR
    exit $EXIT_VALIDATION_ERROR
}

# ============================================================================
# CLEANUP FUNCTIONS
# ============================================================================

# Register cleanup function to run on script exit
register_cleanup() {
    if [[ "$CLEANUP_REGISTERED" == false ]]; then
        trap cleanup_on_exit EXIT INT TERM
        CLEANUP_REGISTERED=true
        log_debug "Cleanup handlers registered"
    fi
}

# Add temporary file for cleanup tracking
add_temp_file() {
    local file="$1"
    TEMP_FILES+=("$file")
    log_debug "Registered temp file for cleanup: $file"
}

# Add temporary directory for cleanup tracking
add_temp_dir() {
    local dir="$1"
    TEMP_DIRS+=("$dir")
    log_debug "Registered temp directory for cleanup: $dir"
}

# Add git worktree for cleanup tracking
add_worktree() {
    local worktree_path="$1"
    WORKTREES+=("$worktree_path")
    log_debug "Registered worktree for cleanup: $worktree_path"
}

# Clean up temporary files
cleanup_temp_files() {
    log_debug "Cleaning up temporary files..."
    
    for file in "${TEMP_FILES[@]}"; do
        if [[ -f "$file" ]]; then
            rm -f "$file" && log_debug "Removed temp file: $file" || log_warn "Failed to remove temp file: $file"
        fi
    done
    
    for dir in "${TEMP_DIRS[@]}"; do
        if [[ -d "$dir" ]]; then
            rm -rf "$dir" && log_debug "Removed temp directory: $dir" || log_warn "Failed to remove temp directory: $dir"
        fi
    done
    
    # Clear arrays
    TEMP_FILES=()
    TEMP_DIRS=()
}

# Clean up git worktrees
cleanup_worktrees() {
    log_debug "Cleaning up git worktrees..."
    
    for worktree in "${WORKTREES[@]}"; do
        if [[ -d "$worktree" ]]; then
            # Remove worktree using git command
            if git worktree remove "$worktree" 2>/dev/null; then
                log_debug "Removed worktree: $worktree"
            else
                # Force removal if normal removal fails
                log_warn "Force removing worktree: $worktree"
                rm -rf "$worktree" 2>/dev/null || log_warn "Failed to remove worktree: $worktree"
                # Clean up worktree reference from git
                git worktree prune 2>/dev/null || true
            fi
        fi
    done
    
    # Clear array
    WORKTREES=()
}

# Comprehensive cleanup function
cleanup_on_exit() {
    local exit_code=$?
    
    # Prevent multiple cleanup calls
    if [[ "${CLEANUP_IN_PROGRESS:-false}" == "true" ]]; then
        return $exit_code
    fi
    CLEANUP_IN_PROGRESS=true
    
    local cleaned_something=false
    
    if [[ ${#TEMP_FILES[@]} -gt 0 || ${#TEMP_DIRS[@]} -gt 0 ]]; then
        log_debug "Performing cleanup of temporary files and directories..."
        cleanup_temp_files
        cleaned_something=true
    fi
    
    if [[ ${#WORKTREES[@]} -gt 0 ]]; then
        log_debug "Performing cleanup of git worktrees..."
        cleanup_worktrees
        cleaned_something=true
    fi
    
    # Only log cleanup completion if we actually cleaned something
    if [[ "$cleaned_something" == "true" ]]; then
        log_debug "Cleanup completed"
    fi
    
    return $exit_code
}

# Create temporary file with automatic cleanup registration
create_temp_file() {
    local prefix="${1:-git-union-merge}"
    local temp_file
    temp_file=$(mktemp -t "${prefix}.XXXXXX") || {
        handle_validation_error "Failed to create temporary file"
    }
    add_temp_file "$temp_file"
    echo "$temp_file"
}

# Create temporary directory with automatic cleanup registration
create_temp_dir() {
    local prefix="${1:-git-union-merge}"
    local temp_dir
    temp_dir=$(mktemp -d -t "${prefix}.XXXXXX") || {
        handle_validation_error "Failed to create temporary directory"
    }
    add_temp_dir "$temp_dir"
    echo "$temp_dir"
}

# Create git worktree with automatic cleanup registration
create_worktree() {
    local worktree_path="$1"
    local branch="$2"
    
    log_debug "Attempting to create worktree at: $worktree_path for branch: $branch"
    
    local git_error
    if git_error=$(git worktree add "$worktree_path" "$branch" 2>&1); then
        add_worktree "$worktree_path"
        log_debug "Created worktree: $worktree_path"
        echo "$worktree_path"
    else
        log_error "Git worktree add failed with error: $git_error"
        handle_git_error "Failed to create worktree at $worktree_path: $git_error"
    fi
}

# Command execution dispatcher
execute_command() {
    # Initialize logging and cleanup systems
    set_log_level
    register_cleanup
    
    log_info "Starting $SCRIPT_NAME v$VERSION with mode: $(get_current_mode)"
    log_debug "Verbose logging enabled"
    log_debug "Output format: $OUTPUT_FORMAT"
    log_debug "Configuration file: ${CONFIG_FILE:-default}"
    
    if [[ "$DRY_RUN" == true ]]; then
        execute_dry_run
    elif [[ "$EXECUTE" == true ]]; then
        execute_merge
    elif [[ "$ROLLBACK" == true ]]; then
        execute_rollback
    else
        handle_validation_error "Internal error: No valid mode selected"
    fi
}

# Get current operation mode for logging
get_current_mode() {
    if [[ "$DRY_RUN" == true ]]; then
        echo "dry-run"
    elif [[ "$EXECUTE" == true ]]; then
        echo "execute"
    elif [[ "$ROLLBACK" == true ]]; then
        echo "rollback"
    else
        echo "unknown"
    fi
}

# ============================================================================
# COMMAND IMPLEMENTATIONS (Placeholder functions for future implementation)
# ============================================================================

# ============================================================================
# REPOSITORY VALIDATION FUNCTIONS
# ============================================================================

validate_repository() {
    log_verbose "Validating Git repository..."
    
    # Check if we're in a Git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a Git repository. Please run this command from within a Git repository."
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Check if working directory is clean
    if ! is_working_directory_clean; then
        log_error "Working directory is not clean. Please commit or stash your changes before running union merge."
        log_info "Uncommitted changes:"
        git status --porcelain
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Verify we can identify the main branch
    if ! get_main_branch >/dev/null; then
        log_error "Cannot identify main branch. Please ensure you have a 'main', 'master', or 'develop' branch."
        exit $EXIT_GENERAL_ERROR
    fi
    
    log_verbose "Repository validation passed"
}

is_working_directory_clean() {
    # Returns 0 (true) if working directory is clean, 1 (false) otherwise
    [[ -z "$(git status --porcelain)" ]]
}

get_main_branch() {
    # Try to find the main branch in order of preference
    local main_candidates=("main" "master" "develop")
    
    for branch in "${main_candidates[@]}"; do
        if git show-ref --verify --quiet "refs/heads/$branch"; then
            echo "$branch"
            return 0
        fi
    done
    
    return 1
}

# ============================================================================
# BRANCH DISCOVERY FUNCTIONS
# ============================================================================

# Global array to store discovered branches
DISCOVERED_BRANCHES=()

discover_branches() {
    log_verbose "Discovering branches for union merge..."
    
    local main_branch
    main_branch=$(get_main_branch)
    
    if [[ -z "$main_branch" ]]; then
        log_error "Cannot determine main branch"
        return 1
    fi
    
    log_verbose "Main branch identified as: $main_branch"
    
    # Get all local branches excluding main branches
    local branches=()
    while IFS= read -r branch; do
        # Skip if empty line
        [[ -n "$branch" ]] || continue
        
        # Apply basic filtering
        if should_include_branch "$branch" "$main_branch"; then
            branches+=("$branch")
            log_verbose "Including branch: $branch"
        else
            log_verbose "Excluding branch: $branch"
        fi
    done < <(git branch --format='%(refname:short)' | grep -v "^$main_branch$")
    
    if [[ ${#branches[@]} -eq 0 ]]; then
        log_warn "No feature branches found to merge"
        return 1
    fi
    
    log_info "Found ${#branches[@]} branches to merge: ${branches[*]}"
    
    # Store branches in global array for other functions to use
    DISCOVERED_BRANCHES=("${branches[@]}")
    return 0
}

should_include_branch() {
    local branch="$1"
    local main_branch="$2"
    
    # Basic exclusion patterns
    local exclude_patterns=(
        "^$main_branch$"
        "^master$"
        "^main$" 
        "^develop$"
        "^HEAD$"
        "^origin/"
        "^release/"
        "^hotfix/"
    )
    
    # Check exclusion patterns first
    for pattern in "${exclude_patterns[@]}"; do
        if [[ "$branch" =~ $pattern ]]; then
            return 1  # Exclude this branch
        fi
    done
    
    # Basic inclusion patterns (simple defaults)
    local include_patterns=(
        "^feature/"
        "^bugfix/"
        "^fix/"
    )
    
    # Check inclusion patterns
    for pattern in "${include_patterns[@]}"; do
        if [[ "$branch" =~ $pattern ]]; then
            return 0  # Include this branch
        fi
    done
    
    # For branches that don't match naming conventions, include them
    # but only if they're not in the exclusion list
    return 0
}

get_branch_info() {
    local branch="$1"
    local main_branch
    main_branch=$(get_main_branch)
    
    local commit_sha
    local commit_count
    local last_commit_msg
    
    commit_sha=$(git rev-parse "$branch" 2>/dev/null) || return 1
    commit_count=$(git rev-list --count "$branch" ^"$main_branch" 2>/dev/null) || commit_count="unknown"
    last_commit_msg=$(git log -1 --format="%s" "$branch" 2>/dev/null) || last_commit_msg="unknown"
    
    echo "Branch: $branch"
    echo "  SHA: $commit_sha"
    echo "  Commits ahead of $main_branch: $commit_count"
    echo "  Last commit: $last_commit_msg"
}

# ============================================================================
# CONFLICT DETECTION FUNCTIONS
# ============================================================================

# Global arrays to store conflict information
CONFLICT_FILES=()
CONFLICT_DETAILS=()

# Detect conflicts between branches using git merge-tree
detect_conflicts() {
    log_verbose "Detecting conflicts between branches..."
    
    local main_branch
    main_branch=$(get_main_branch)
    
    # Clear previous conflict data
    CONFLICT_FILES=()
    CONFLICT_DETAILS=()
    
    local total_conflicts=0
    local branch_pairs_checked=0
    
    # Check conflicts between each branch and main
    for branch in "${DISCOVERED_BRANCHES[@]}"; do
        log_verbose "Checking conflicts for branch: $branch"
        
        # Get merge base between branch and main
        local merge_base
        merge_base=$(git merge-base "$main_branch" "$branch" 2>/dev/null) || {
            log_warn "Cannot find merge base for branch $branch, skipping conflict detection"
            continue
        }
        
        # Use git merge-tree to detect conflicts
        local merge_tree_output
        merge_tree_output=$(git merge-tree "$merge_base" "$main_branch" "$branch" 2>/dev/null) || {
            log_verbose "No conflicts detected for branch $branch"
            ((branch_pairs_checked++))
            continue
        }
        
        # If merge-tree produces output, there are conflicts
        if [[ -n "$merge_tree_output" ]]; then
            log_verbose "Conflicts detected for branch $branch"
            
            # Parse conflict files from merge-tree output
            local conflict_files_for_branch=()
            while IFS= read -r line; do
                # Look for conflict markers or file paths in merge-tree output
                if [[ "$line" =~ ^[[:space:]]*[+\-] ]] || [[ "$line" =~ ^\+\+\+|^--- ]]; then
                    # Extract file path from diff header
                    if [[ "$line" =~ ^\+\+\+[[:space:]]b/(.+)$ ]]; then
                        local file_path="${BASH_REMATCH[1]}"
                        if [[ ! " ${conflict_files_for_branch[*]} " =~ " ${file_path} " ]]; then
                            conflict_files_for_branch+=("$file_path")
                        fi
                    fi
                fi
            done <<< "$merge_tree_output"
            
            # If we couldn't parse files from diff, try alternative method
            if [[ ${#conflict_files_for_branch[@]} -eq 0 ]]; then
                # Get list of modified files in the branch
                while IFS= read -r file; do
                    if [[ -n "$file" ]]; then
                        conflict_files_for_branch+=("$file")
                    fi
                done < <(git diff --name-only "$main_branch".."$branch" 2>/dev/null)
            fi
            
            # Store conflict information
            for file in "${conflict_files_for_branch[@]}"; do
                # Check if file is already in CONFLICT_FILES array
                local file_already_exists=false
                if [[ ${#CONFLICT_FILES[@]} -gt 0 ]]; then
                    for existing_file in "${CONFLICT_FILES[@]}"; do
                        if [[ "$existing_file" == "$file" ]]; then
                            file_already_exists=true
                            break
                        fi
                    done
                fi
                
                if [[ "$file_already_exists" == false ]]; then
                    CONFLICT_FILES+=("$file")
                    
                    # Analyze conflict type
                    local conflict_type
                    conflict_type=$(analyze_conflict_type "$file" "$main_branch" "$branch")
                    
                    # Store detailed conflict information
                    local conflict_detail="$file|$branch|$conflict_type"
                    CONFLICT_DETAILS+=("$conflict_detail")
                    
                    ((total_conflicts++))
                fi
            done
        fi
        
        ((branch_pairs_checked++))
    done
    
    log_verbose "Conflict detection complete: $total_conflicts conflicts found across $branch_pairs_checked branch pairs"
    return 0
}

# Analyze the type of conflict for a specific file
analyze_conflict_type() {
    local file="$1"
    local main_branch="$2"
    local feature_branch="$3"
    
    # Check if file exists in both branches
    local main_has_file=false
    local branch_has_file=false
    
    if git cat-file -e "$main_branch:$file" 2>/dev/null; then
        main_has_file=true
    fi
    
    if git cat-file -e "$feature_branch:$file" 2>/dev/null; then
        branch_has_file=true
    fi
    
    # Determine conflict type based on file existence and content
    if [[ "$main_has_file" == false && "$branch_has_file" == true ]]; then
        echo "NEW_FILE"
    elif [[ "$main_has_file" == true && "$branch_has_file" == false ]]; then
        echo "DELETED_FILE"
    elif [[ "$main_has_file" == true && "$branch_has_file" == true ]]; then
        # Both branches have the file, check for content differences
        if git diff --quiet "$main_branch:$file" "$feature_branch:$file" 2>/dev/null; then
            echo "NO_CONFLICT"
        else
            # Check if it's just whitespace differences
            if git diff --ignore-space-change --quiet "$main_branch:$file" "$feature_branch:$file" 2>/dev/null; then
                echo "WHITESPACE_ONLY"
            else
                echo "CONTENT_CONFLICT"
            fi
        fi
    else
        echo "UNKNOWN"
    fi
}

# Generate conflict summary for preview
generate_conflict_summary() {
    local total_files=${#CONFLICT_FILES[@]}
    local auto_resolvable=0
    local manual_required=0
    
    # Categorize conflicts
    for detail in "${CONFLICT_DETAILS[@]}"; do
        IFS='|' read -r file branch conflict_type <<< "$detail"
        
        case "$conflict_type" in
            "NEW_FILE"|"WHITESPACE_ONLY")
                ((auto_resolvable++))
                ;;
            "CONTENT_CONFLICT"|"DELETED_FILE")
                ((manual_required++))
                ;;
        esac
    done
    
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        generate_json_conflict_summary "$total_files" "$auto_resolvable" "$manual_required"
    else
        generate_text_conflict_summary "$total_files" "$auto_resolvable" "$manual_required"
    fi
}

# Generate JSON format conflict summary
generate_json_conflict_summary() {
    local total_files="$1"
    local auto_resolvable="$2"
    local manual_required="$3"
    
    local conflicts_json="["
    local first=true
    
    for detail in "${CONFLICT_DETAILS[@]}"; do
        IFS='|' read -r file branch conflict_type <<< "$detail"
        
        if [[ "$first" == true ]]; then
            first=false
        else
            conflicts_json+=","
        fi
        
        conflicts_json+="{\"file\":\"$file\",\"branch\":\"$branch\",\"type\":\"$conflict_type\"}"
    done
    conflicts_json+="]"
    
    cat << EOF
{
  "success": true,
  "preview": {
    "branch_count": ${#DISCOVERED_BRANCHES[@]},
    "branches": [$(printf '"%s",' "${DISCOVERED_BRANCHES[@]}" | sed 's/,$//')],
    "conflicts": {
      "total_files": $total_files,
      "auto_resolvable": $auto_resolvable,
      "manual_required": $manual_required,
      "details": $conflicts_json
    },
    "estimated_time": "$(estimate_merge_time)",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
EOF
}

# Generate text format conflict summary
generate_text_conflict_summary() {
    local total_files="$1"
    local auto_resolvable="$2"
    local manual_required="$3"
    
    echo "=== Union Merge Preview ==="
    echo "Branches to merge: ${#DISCOVERED_BRANCHES[@]}"
    echo "Branch list: ${DISCOVERED_BRANCHES[*]}"
    echo ""
    echo "=== Conflict Analysis ==="
    echo "Total files with conflicts: $total_files"
    echo "Auto-resolvable conflicts: $auto_resolvable"
    echo "Manual resolution required: $manual_required"
    echo ""
    
    if [[ $total_files -gt 0 ]]; then
        echo "=== Conflict Details ==="
        for detail in "${CONFLICT_DETAILS[@]}"; do
            IFS='|' read -r file branch conflict_type <<< "$detail"
            
            local resolution_strategy
            case "$conflict_type" in
                "NEW_FILE")
                    resolution_strategy="AUTO (new file will be added)"
                    ;;
                "WHITESPACE_ONLY")
                    resolution_strategy="AUTO (whitespace normalization)"
                    ;;
                "CONTENT_CONFLICT")
                    resolution_strategy="MANUAL (overlapping changes detected)"
                    ;;
                "DELETED_FILE")
                    resolution_strategy="MANUAL (file deletion conflict)"
                    ;;
                *)
                    resolution_strategy="UNKNOWN"
                    ;;
            esac
            
            echo "  $file (from $branch): $conflict_type - $resolution_strategy"
        done
        echo ""
    fi
    
    echo "=== Estimated Merge Time ==="
    echo "$(estimate_merge_time)"
    echo ""
    
    if [[ $manual_required -gt 0 ]]; then
        echo "⚠️  WARNING: $manual_required conflicts require manual resolution"
        echo "   Consider resolving these conflicts before running --execute"
    else
        echo "✅ All conflicts can be auto-resolved"
    fi
    
    echo ""
    echo "=== Next Steps ==="
    if [[ $total_files -eq 0 ]]; then
        echo "✅ No conflicts detected. Run with --execute to perform the merge."
    elif [[ $manual_required -eq 0 ]]; then
        echo "✅ All conflicts are auto-resolvable. Run with --execute to perform the merge."
    else
        echo "⚠️  Manual conflicts detected. Review the conflicts above and consider:"
        echo "   1. Resolving conflicts manually in individual branches first"
        echo "   2. Excluding problematic branches using configuration"
        echo "   3. Proceeding with --execute (manual conflicts will halt the merge)"
    fi
}

# Estimate merge time based on branch and conflict complexity
estimate_merge_time() {
    local branch_count=${#DISCOVERED_BRANCHES[@]}
    local conflict_count=${#CONFLICT_FILES[@]}
    
    # Base time: 2 seconds per branch
    local base_time=$((branch_count * 2))
    
    # Additional time for conflicts: 3 seconds per conflict file
    local conflict_time=$((conflict_count * 3))
    
    # Manual conflicts add more time: 10 seconds per manual conflict
    local manual_conflicts=0
    for detail in "${CONFLICT_DETAILS[@]}"; do
        IFS='|' read -r file branch conflict_type <<< "$detail"
        if [[ "$conflict_type" == "CONTENT_CONFLICT" || "$conflict_type" == "DELETED_FILE" ]]; then
            ((manual_conflicts++))
        fi
    done
    local manual_time=$((manual_conflicts * 10))
    
    local total_seconds=$((base_time + conflict_time + manual_time))
    
    # Format time nicely
    if [[ $total_seconds -lt 60 ]]; then
        echo "${total_seconds}s"
    elif [[ $total_seconds -lt 3600 ]]; then
        local minutes=$((total_seconds / 60))
        local seconds=$((total_seconds % 60))
        echo "${minutes}m ${seconds}s"
    else
        local hours=$((total_seconds / 3600))
        local minutes=$(((total_seconds % 3600) / 60))
        echo "${hours}h ${minutes}m"
    fi
}

# ============================================================================
# CHECKPOINT SYSTEM FUNCTIONS
# ============================================================================

# Global variables for checkpoint management
CHECKPOINT_DIR=".git/union-merge-checkpoints"
CURRENT_CHECKPOINT=""

# Create a checkpoint to save current repository state
create_checkpoint() {
    log_verbose "Creating repository checkpoint..."
    
    # Create checkpoint directory if it doesn't exist
    if [[ ! -d "$CHECKPOINT_DIR" ]]; then
        mkdir -p "$CHECKPOINT_DIR" || {
            handle_checkpoint_error "Failed to create checkpoint directory: $CHECKPOINT_DIR"
        }
    fi
    
    # Generate unique checkpoint ID with timestamp
    local checkpoint_id="union-merge-$(date +%Y%m%d-%H%M%S)"
    local checkpoint_path="$CHECKPOINT_DIR/$checkpoint_id"
    
    # Create checkpoint subdirectory
    mkdir -p "$checkpoint_path" || {
        handle_checkpoint_error "Failed to create checkpoint path: $checkpoint_path"
    }
    
    log_verbose "Checkpoint ID: $checkpoint_id"
    
    # Save current HEAD SHA
    local current_head
    current_head=$(git rev-parse HEAD) || {
        handle_checkpoint_error "Failed to get current HEAD SHA"
    }
    echo "$current_head" > "$checkpoint_path/head_sha" || {
        handle_checkpoint_error "Failed to save HEAD SHA to checkpoint"
    }
    
    # Save current branch name
    local current_branch
    current_branch=$(git branch --show-current) || {
        handle_checkpoint_error "Failed to get current branch name"
    }
    echo "$current_branch" > "$checkpoint_path/current_branch" || {
        handle_checkpoint_error "Failed to save current branch to checkpoint"
    }
    
    # Save all branch references
    git branch -a > "$checkpoint_path/branch_refs" || {
        handle_checkpoint_error "Failed to save branch references to checkpoint"
    }
    
    # Save stash state
    git stash list > "$checkpoint_path/stash_state" || {
        handle_checkpoint_error "Failed to save stash state to checkpoint"
    }
    
    # Save repository status
    git status --porcelain > "$checkpoint_path/repo_status" || {
        handle_checkpoint_error "Failed to save repository status to checkpoint"
    }
    
    # Save timestamp
    date -u +%Y-%m-%dT%H:%M:%SZ > "$checkpoint_path/timestamp" || {
        handle_checkpoint_error "Failed to save timestamp to checkpoint"
    }
    
    # Save the list of branches that will be merged
    printf '%s\n' "${DISCOVERED_BRANCHES[@]}" > "$checkpoint_path/merged_branches" || {
        handle_checkpoint_error "Failed to save merged branches list to checkpoint"
    }
    
    # Set global checkpoint variable
    CURRENT_CHECKPOINT="$checkpoint_id"
    
    log_info "Checkpoint created: $checkpoint_id"
    log_verbose "Checkpoint saved to: $checkpoint_path"
    
    echo "$checkpoint_id"
}

# Find the most recent checkpoint
find_latest_checkpoint() {
    if [[ ! -d "$CHECKPOINT_DIR" ]]; then
        return 1
    fi
    
    # Find the most recent checkpoint directory
    local latest_checkpoint
    latest_checkpoint=$(ls -1t "$CHECKPOINT_DIR" 2>/dev/null | head -n1)
    
    if [[ -n "$latest_checkpoint" && -d "$CHECKPOINT_DIR/$latest_checkpoint" ]]; then
        echo "$latest_checkpoint"
        return 0
    fi
    
    return 1
}

# Validate checkpoint integrity
validate_checkpoint() {
    local checkpoint_id="$1"
    local checkpoint_path="$CHECKPOINT_DIR/$checkpoint_id"
    
    if [[ ! -d "$checkpoint_path" ]]; then
        log_error "Checkpoint directory not found: $checkpoint_path"
        return 1
    fi
    
    # Check required files exist
    local required_files=("head_sha" "current_branch" "branch_refs" "timestamp")
    for file in "${required_files[@]}"; do
        if [[ ! -f "$checkpoint_path/$file" ]]; then
            log_error "Checkpoint file missing: $checkpoint_path/$file"
            return 1
        fi
    done
    
    # Validate HEAD SHA format
    local head_sha
    head_sha=$(cat "$checkpoint_path/head_sha")
    if [[ ! "$head_sha" =~ ^[a-f0-9]{40}$ ]]; then
        log_error "Invalid HEAD SHA in checkpoint: $head_sha"
        return 1
    fi
    
    # Verify the commit still exists
    if ! git cat-file -e "$head_sha" 2>/dev/null; then
        log_error "Checkpoint HEAD SHA no longer exists in repository: $head_sha"
        return 1
    fi
    
    log_verbose "Checkpoint validation passed: $checkpoint_id"
    return 0
}

# ============================================================================
# CORE MERGE EXECUTION FUNCTIONS
# ============================================================================

# Execute the union merge of all discovered branches
execute_union_merge() {
    log_info "Starting union merge execution..."
    
    local main_branch
    main_branch=$(get_main_branch) || {
        handle_git_error "Cannot determine main branch for merge"
    }
    
    log_info "Merging ${#DISCOVERED_BRANCHES[@]} branches into $main_branch"
    log_verbose "Branches to merge: ${DISCOVERED_BRANCHES[*]}"
    
    # Ensure we're on the main branch
    local current_branch
    current_branch=$(git branch --show-current)
    if [[ "$current_branch" != "$main_branch" ]]; then
        log_info "Switching to main branch: $main_branch"
        git checkout "$main_branch" || {
            handle_git_error "Failed to checkout main branch: $main_branch"
        }
    fi
    
    # Perform merge operations directly in the main repository
    # The checkpoint system provides the safety we need for atomic operations
    log_verbose "Performing merge operations in main repository with checkpoint safety"
    
    # Track merge statistics
    local successful_merges=0
    local failed_merges=0
    local failed_branches=()
    
    # Merge each branch sequentially
    for branch in "${DISCOVERED_BRANCHES[@]}"; do
        log_info "Merging branch: $branch"
        
        if merge_single_branch "$branch" "$main_branch"; then
            ((successful_merges++))
            log_verbose "Successfully merged branch: $branch"
        else
            ((failed_merges++))
            failed_branches+=("$branch")
            log_warn "Failed to merge branch: $branch"
            
            # For now, continue with other branches
            # In a production version, we might want to make this configurable
            log_info "Continuing with remaining branches..."
        fi
    done
    
    # Merge operations completed in main repository
    
    # Generate final merge commit with all branch information
    if [[ $successful_merges -gt 0 ]]; then
        log_info "Creating union merge commit..."
        if [[ ${#failed_branches[@]} -gt 0 ]]; then
            create_union_merge_commit "$successful_merges" "$failed_merges" "${failed_branches[@]}"
        else
            create_union_merge_commit "$successful_merges" "$failed_merges"
        fi
        
        # Create tag for this merge
        create_merge_tag
        
        log_info "Union merge completed successfully!"
        log_info "Merged branches: $successful_merges"
        if [[ $failed_merges -gt 0 ]]; then
            log_warn "Failed branches: $failed_merges (${failed_branches[*]})"
        fi
    else
        handle_git_error "No branches were successfully merged"
    fi
    
    # Generate merge report
    if [[ ${#failed_branches[@]} -gt 0 ]]; then
        generate_merge_report "$successful_merges" "$failed_merges" "${failed_branches[@]}"
    else
        generate_merge_report "$successful_merges" "$failed_merges"
    fi
}

# Merge a single branch into the current branch
merge_single_branch() {
    local branch="$1"
    local main_branch="$2"
    
    log_verbose "Attempting to merge branch $branch into $main_branch"
    
    # Verify the branch exists
    if ! git show-ref --verify --quiet "refs/heads/$branch"; then
        log_error "Branch does not exist: $branch"
        return 1
    fi
    
    # Attempt the merge with no-ff to preserve branch history
    if git merge --no-ff --no-edit "$branch" 2>/dev/null; then
        log_verbose "Clean merge successful for branch: $branch"
        return 0
    else
        log_verbose "Merge conflict detected for branch: $branch"
        
        # Check if there are conflicts to resolve
        local conflicted_files
        conflicted_files=$(git diff --name-only --diff-filter=U 2>/dev/null)
        
        if [[ -n "$conflicted_files" ]]; then
            log_verbose "Attempting automatic conflict resolution for: $conflicted_files"
            
            # Try to auto-resolve conflicts
            if auto_resolve_conflicts "$conflicted_files"; then
                # Complete the merge after auto-resolution
                git add . && git commit --no-edit || {
                    log_error "Failed to complete merge after auto-resolution for branch: $branch"
                    git merge --abort 2>/dev/null || true
                    return 1
                }
                log_verbose "Auto-resolved conflicts and completed merge for branch: $branch"
                return 0
            else
                log_warn "Could not auto-resolve conflicts for branch: $branch"
                git merge --abort 2>/dev/null || true
                return 1
            fi
        else
            log_error "Merge failed for unknown reason for branch: $branch"
            git merge --abort 2>/dev/null || true
            return 1
        fi
    fi
}

# Attempt to automatically resolve merge conflicts
auto_resolve_conflicts() {
    local conflicted_files="$1"
    local resolved_count=0
    local total_count=0
    
    while IFS= read -r file; do
        [[ -n "$file" ]] || continue
        ((total_count++))
        
        log_verbose "Attempting to resolve conflict in: $file"
        
        # For now, implement basic conflict resolution strategies
        if resolve_file_conflict "$file"; then
            ((resolved_count++))
            log_verbose "Resolved conflict in: $file"
        else
            log_verbose "Could not resolve conflict in: $file"
        fi
    done <<< "$conflicted_files"
    
    log_verbose "Auto-resolved $resolved_count out of $total_count conflicted files"
    
    # Return success if we resolved all conflicts
    [[ $resolved_count -eq $total_count ]]
}

# Resolve conflict in a single file
resolve_file_conflict() {
    local file="$1"
    
    # Check if file has conflict markers
    if ! grep -q "^<<<<<<< " "$file" 2>/dev/null; then
        log_verbose "No conflict markers found in: $file"
        return 0
    fi
    
    # For basic implementation, try simple strategies
    
    # Strategy 1: If it's a simple addition conflict (both sides added different content)
    # and the file extension suggests it's safe to merge both sides
    case "$file" in
        *.md|*.txt|*.rst)
            # For documentation files, try to merge both sides
            if merge_both_sides "$file"; then
                return 0
            fi
            ;;
        *.json|*.yml|*.yaml)
            # For config files, be more conservative
            log_verbose "Config file conflict requires manual resolution: $file"
            return 1
            ;;
        *)
            # For other files, try basic resolution
            if attempt_basic_resolution "$file"; then
                return 0
            fi
            ;;
    esac
    
    return 1
}

# Attempt to merge both sides of a conflict (for documentation files)
merge_both_sides() {
    local file="$1"
    local temp_file
    temp_file=$(create_temp_file "conflict-resolution")
    
    # Simple strategy: remove conflict markers and keep both sides
    if sed -e '/^<<<<<<< /d' -e '/^=======/d' -e '/^>>>>>>> /d' "$file" > "$temp_file"; then
        if mv "$temp_file" "$file"; then
            log_verbose "Merged both sides for: $file"
            return 0
        fi
    fi
    
    return 1
}

# Attempt basic conflict resolution
attempt_basic_resolution() {
    local file="$1"
    
    # Count conflict sections
    local conflict_count
    conflict_count=$(grep -c "^<<<<<<< " "$file" 2>/dev/null || echo "0")
    
    # If there's only one conflict and it's small, try to resolve it
    if [[ $conflict_count -eq 1 ]]; then
        local conflict_size
        conflict_size=$(sed -n '/^<<<<<<< /,/^>>>>>>> /p' "$file" | wc -l)
        
        # If conflict is small (less than 10 lines), try simple resolution
        if [[ $conflict_size -lt 10 ]]; then
            # For now, just take the "ours" version (remove theirs)
            if sed -i.bak -e '/^<<<<<<< /,/^=======/d' -e '/^>>>>>>> /d' "$file"; then
                log_verbose "Applied 'ours' strategy for small conflict in: $file"
                return 0
            fi
        fi
    fi
    
    return 1
}

# Create the final union merge commit with detailed information
create_union_merge_commit() {
    local successful_merges="$1"
    local failed_merges="$2"
    shift 2
    local failed_branches=("$@")
    
    log_verbose "Creating union merge commit..."
    
    # Generate comprehensive commit message
    local commit_message
    if [[ ${#failed_branches[@]} -gt 0 ]]; then
        commit_message=$(generate_union_commit_message "$successful_merges" "$failed_merges" "${failed_branches[@]}")
    else
        commit_message=$(generate_union_commit_message "$successful_merges" "$failed_merges")
    fi
    
    # Create the commit (this should already be done by individual merges, but ensure it's committed)
    if git diff --cached --quiet && git diff --quiet; then
        log_verbose "No additional changes to commit"
    else
        git add . && git commit -m "$commit_message" || {
            handle_git_error "Failed to create union merge commit"
        }
    fi
    
    log_info "Union merge commit created successfully"
}

# Generate detailed commit message for union merge
generate_union_commit_message() {
    local successful_merges="$1"
    local failed_merges="$2"
    shift 2
    local failed_branches=("$@")
    
    local message="Union merge: Merged $successful_merges branches"
    
    if [[ $failed_merges -gt 0 ]]; then
        message+=" ($failed_merges failed)"
    fi
    
    message+="\n\nMerged branches:"
    for branch in "${DISCOVERED_BRANCHES[@]}"; do
        # Check if this branch failed
        local branch_failed=false
        if [[ ${#failed_branches[@]} -gt 0 ]]; then
            for failed_branch in "${failed_branches[@]}"; do
                if [[ "$branch" == "$failed_branch" ]]; then
                    branch_failed=true
                    break
                fi
            done
        fi
        
        if [[ "$branch_failed" == true ]]; then
            message+="\n  ❌ $branch (merge failed)"
        else
            message+="\n  ✅ $branch"
        fi
    done
    
    message+="\n\nMerge summary:"
    message+="\n- Total branches processed: ${#DISCOVERED_BRANCHES[@]}"
    message+="\n- Successful merges: $successful_merges"
    message+="\n- Failed merges: $failed_merges"
    message+="\n- Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    
    if [[ -n "$CURRENT_CHECKPOINT" ]]; then
        message+="\n- Checkpoint: $CURRENT_CHECKPOINT"
    fi
    
    echo -e "$message"
}

# Create a tag for the union merge
create_merge_tag() {
    local tag_name="union-merge-$(date +%Y%m%d-%H%M%S)"
    local current_commit
    current_commit=$(git rev-parse HEAD)
    
    log_verbose "Creating merge tag: $tag_name"
    
    if git tag -a "$tag_name" -m "Union merge completed at $(date)" "$current_commit"; then
        log_info "Created merge tag: $tag_name"
    else
        log_warn "Failed to create merge tag: $tag_name"
    fi
}

# Generate merge report
generate_merge_report() {
    local successful_merges="$1"
    local failed_merges="$2"
    shift 2
    local failed_branches=("$@")
    
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        if [[ ${#failed_branches[@]} -gt 0 ]]; then
            generate_json_merge_report "$successful_merges" "$failed_merges" "${failed_branches[@]}"
        else
            generate_json_merge_report "$successful_merges" "$failed_merges"
        fi
    else
        if [[ ${#failed_branches[@]} -gt 0 ]]; then
            generate_text_merge_report "$successful_merges" "$failed_merges" "${failed_branches[@]}"
        else
            generate_text_merge_report "$successful_merges" "$failed_merges"
        fi
    fi
}

# Generate JSON format merge report
generate_json_merge_report() {
    local successful_merges="$1"
    local failed_merges="$2"
    shift 2
    local failed_branches=("$@")
    
    local failed_branches_json="["
    local first=true
    if [[ ${#failed_branches[@]} -gt 0 ]]; then
        for branch in "${failed_branches[@]}"; do
            if [[ "$first" == true ]]; then
                first=false
            else
                failed_branches_json+=","
            fi
            failed_branches_json+="\"$branch\""
        done
    fi
    failed_branches_json+="]"
    
    cat << EOF
{
  "success": true,
  "merge_result": {
    "total_branches": ${#DISCOVERED_BRANCHES[@]},
    "successful_merges": $successful_merges,
    "failed_merges": $failed_merges,
    "failed_branches": $failed_branches_json,
    "checkpoint": "${CURRENT_CHECKPOINT:-}",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
EOF
}

# Generate text format merge report
generate_text_merge_report() {
    local successful_merges="$1"
    local failed_merges="$2"
    shift 2
    local failed_branches=("$@")
    
    echo ""
    echo "=== Union Merge Complete ==="
    echo "Total branches processed: ${#DISCOVERED_BRANCHES[@]}"
    echo "Successful merges: $successful_merges"
    echo "Failed merges: $failed_merges"
    
    if [[ $failed_merges -gt 0 && ${#failed_branches[@]} -gt 0 ]]; then
        echo ""
        echo "Failed branches:"
        for branch in "${failed_branches[@]}"; do
            echo "  - $branch"
        done
    fi
    
    if [[ -n "$CURRENT_CHECKPOINT" ]]; then
        echo ""
        echo "Checkpoint created: $CURRENT_CHECKPOINT"
        echo "Use 'git union-merge --rollback' to restore previous state if needed"
    fi
    
    echo ""
    echo "Merge completed at: $(date)"
}

# ============================================================================
# ROLLBACK FUNCTIONALITY
# ============================================================================

# Execute rollback to restore repository to pre-merge state
execute_rollback_operation() {
    log_info "Starting rollback operation..."
    
    # Find the checkpoint to rollback to
    local checkpoint_id="$1"
    
    if [[ -z "$checkpoint_id" ]]; then
        # Find the latest checkpoint
        checkpoint_id=$(find_latest_checkpoint) || {
            log_error "No checkpoints found for rollback"
            log_info "Available checkpoints:"
            list_available_checkpoints
            exit $EXIT_CHECKPOINT_ERROR
        }
        log_info "Using latest checkpoint: $checkpoint_id"
    fi
    
    # Validate checkpoint
    if ! validate_checkpoint "$checkpoint_id"; then
        handle_checkpoint_error "Invalid checkpoint: $checkpoint_id"
    fi
    
    local checkpoint_path="$CHECKPOINT_DIR/$checkpoint_id"
    
    # Read checkpoint data
    local saved_head_sha
    local saved_branch
    saved_head_sha=$(cat "$checkpoint_path/head_sha")
    saved_branch=$(cat "$checkpoint_path/current_branch")
    
    log_info "Rolling back to checkpoint: $checkpoint_id"
    log_info "Target HEAD SHA: $saved_head_sha"
    log_info "Target branch: $saved_branch"
    
    # Confirm rollback with user (unless in non-interactive mode)
    if [[ -t 0 && -t 1 ]]; then  # Check if running interactively
        echo ""
        echo "⚠️  WARNING: This will reset your repository to the state before the union merge."
        echo "   Current HEAD: $(git rev-parse HEAD)"
        echo "   Rollback HEAD: $saved_head_sha"
        echo ""
        read -p "Are you sure you want to proceed with rollback? (y/N): " -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Rollback cancelled by user"
            exit $EXIT_SUCCESS
        fi
    fi
    
    # Perform rollback operations
    log_info "Performing rollback operations..."
    
    # Stash any current changes to avoid losing work
    local stash_created=false
    if ! git diff --quiet || ! git diff --cached --quiet; then
        log_info "Stashing current changes before rollback..."
        if git stash push -m "Pre-rollback stash $(date)"; then
            stash_created=true
            log_info "Current changes stashed"
        else
            log_warn "Failed to stash current changes"
        fi
    fi
    
    # Switch to the saved branch
    if [[ "$saved_branch" != "$(git branch --show-current)" ]]; then
        log_info "Switching to branch: $saved_branch"
        git checkout "$saved_branch" || {
            handle_git_error "Failed to checkout branch: $saved_branch"
        }
    fi
    
    # Reset to the saved HEAD
    log_info "Resetting to saved HEAD: $saved_head_sha"
    git reset --hard "$saved_head_sha" || {
        handle_git_error "Failed to reset to saved HEAD: $saved_head_sha"
    }
    
    # Clean up any untracked files that might have been created during merge
    log_verbose "Cleaning up untracked files..."
    git clean -fd || {
        log_warn "Failed to clean untracked files"
    }
    
    # Verify rollback success
    local current_head
    current_head=$(git rev-parse HEAD)
    if [[ "$current_head" == "$saved_head_sha" ]]; then
        log_info "✅ Rollback completed successfully"
        log_info "Repository restored to checkpoint: $checkpoint_id"
        
        if [[ "$stash_created" == true ]]; then
            log_info "Your previous changes are available in the stash"
            log_info "Use 'git stash pop' to restore them if needed"
        fi
        
        # Generate rollback report
        generate_rollback_report "$checkpoint_id" "$saved_head_sha" "$stash_created"
    else
        handle_checkpoint_error "Rollback verification failed. Current HEAD: $current_head, Expected: $saved_head_sha"
    fi
}

# List available checkpoints
list_available_checkpoints() {
    if [[ ! -d "$CHECKPOINT_DIR" ]]; then
        echo "No checkpoints directory found"
        return 1
    fi
    
    local checkpoints
    checkpoints=$(ls -1t "$CHECKPOINT_DIR" 2>/dev/null)
    
    if [[ -z "$checkpoints" ]]; then
        echo "No checkpoints available"
        return 1
    fi
    
    echo "Available checkpoints:"
    while IFS= read -r checkpoint; do
        if [[ -f "$CHECKPOINT_DIR/$checkpoint/timestamp" ]]; then
            local timestamp
            timestamp=$(cat "$CHECKPOINT_DIR/$checkpoint/timestamp")
            echo "  - $checkpoint (created: $timestamp)"
        else
            echo "  - $checkpoint"
        fi
    done <<< "$checkpoints"
}

# Generate rollback report
generate_rollback_report() {
    local checkpoint_id="$1"
    local restored_head="$2"
    local stash_created="$3"
    
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        cat << EOF
{
  "success": true,
  "rollback_result": {
    "checkpoint_id": "$checkpoint_id",
    "restored_head": "$restored_head",
    "stash_created": $stash_created,
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
EOF
    else
        echo ""
        echo "=== Rollback Complete ==="
        echo "Checkpoint: $checkpoint_id"
        echo "Restored HEAD: $restored_head"
        echo "Stash created: $stash_created"
        echo "Rollback completed at: $(date)"
        echo ""
        echo "Repository has been restored to its pre-merge state."
    fi
}

# ============================================================================
# COMMAND EXECUTION FUNCTIONS
# ============================================================================

execute_dry_run() {
    log_info "Executing dry-run mode..."
    log_verbose "Configuration file: ${CONFIG_FILE:-default}"
    
    validate_repository
    
    if discover_branches; then
        log_verbose "Branch discovery successful, proceeding with conflict detection..."
        
        # Perform conflict detection
        if detect_conflicts; then
            log_verbose "Conflict detection completed successfully"
            
            # Generate and display the preview
            if [[ "$OUTPUT_FORMAT" == "json" ]]; then
                generate_conflict_summary
            else
                # For text output, log through our logging system but also output the summary
                generate_conflict_summary
            fi
        else
            log_error "Conflict detection failed"
            exit $EXIT_GENERAL_ERROR
        fi
    else
        log_error "Branch discovery failed"
        exit $EXIT_GENERAL_ERROR
    fi
}

execute_merge() {
    log_info "Executing union merge..."
    log_verbose "Configuration file: ${CONFIG_FILE:-default}"
    
    validate_repository
    
    if discover_branches; then
        log_info "Starting union merge of ${#DISCOVERED_BRANCHES[@]} branches..."
        
        # Create checkpoint before starting merge
        log_info "Creating checkpoint before merge..."
        create_checkpoint || {
            handle_checkpoint_error "Failed to create checkpoint before merge"
        }
        
        # Perform conflict detection first
        log_info "Analyzing conflicts before merge..."
        if detect_conflicts; then
            log_verbose "Conflict analysis completed"
            
            # Check if there are any manual conflicts that would block the merge
            local manual_conflicts=0
            for detail in "${CONFLICT_DETAILS[@]}"; do
                IFS='|' read -r file branch conflict_type <<< "$detail"
                if [[ "$conflict_type" == "CONTENT_CONFLICT" || "$conflict_type" == "DELETED_FILE" ]]; then
                    ((manual_conflicts++))
                fi
            done
            
            if [[ $manual_conflicts -gt 0 ]]; then
                log_warn "Found $manual_conflicts conflicts that may require manual resolution"
                log_info "Proceeding with merge - conflicts will be handled automatically where possible"
            fi
        else
            log_verbose "Conflict detection completed with no issues"
        fi
        
        # Execute the actual union merge
        execute_union_merge
        
    else
        log_error "Branch discovery failed"
        exit $EXIT_GENERAL_ERROR
    fi
}

execute_rollback() {
    log_info "Executing rollback..."
    log_verbose "Configuration file: ${CONFIG_FILE:-default}"
    
    validate_repository
    
    # Execute the rollback operation
    execute_rollback_operation
}

# Main function
main() {
    parse_arguments "$@"
    validate_arguments
    execute_command
    
    # Explicit cleanup call for normal exit
    cleanup_on_exit
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi